var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var goog;
(function (goog) {
    var Arguments = /** @class */ (function () {
        function Arguments() {
        }
        return Arguments;
    }());
    goog.Arguments = Arguments;
})(goog || (goog = {}));
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will attempt to load Closure's deps file, unless
 * the global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects
 * to include their own deps file(s) from different locations.
 *
 * Avoid including base.js more than once. This is strictly discouraged and not
 * supported. goog.require(...) won't work properly in that case.
 *
 * @provideGoog
 */
/**
* @define {boolean} Overridden to true by the compiler.
*/
var COMPILED = false;
var globalDef;
(function (globalDef) {
    var goog = goog || {};
    goog.global = window;
    goog.global.CLOSURE_UNCOMPILED_DEFINES;
    goog.global.CLOSURE_DEFINES;
})(globalDef || (globalDef = {}));
var goog;
(function (goog) {
    var global;
    (function (global) {
        // inherit from window;
        global.addEventListener = window.addEventListener;
        global.removeEventListener = window.removeEventListener;
        global.setTimeout = window.setTimeout;
        global.setImmediate = window.setImmediate;
        global.clearTimeout = window.clearTimeout;
        global.Error = global.Error;
        global.Blob = window.Blob;
        function execScript(a, b) {
        }
        global.execScript = execScript;
        function eval(a) {
        }
        global.eval = eval;
    })(global = goog.global || (goog.global = {}));
})(goog || (goog = {}));
(function (goog) {
    /**
     * Returns true if the specified value is not undefined.
     *
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is defined.
     */
    function isDef(val) {
        // void 0 always evaluates to undefined and hence we do not need to depend on
        // the definition of the global variable named 'undefined'.
        return val !== void 0;
    }
    goog.isDef = isDef;
    /**
     * Returns true if the specified value is a string.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is a string.
     */
    function isString(val) {
        return typeof val == 'string';
    }
    goog.isString = isString;
    ;
    /**
     * Returns true if the specified value is a boolean.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is boolean.
     */
    function isBoolean(val) {
        return typeof val == 'boolean';
    }
    goog.isBoolean = isBoolean;
    /**
     * Returns true if the specified value is a number.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is a number.
     */
    function isNumber(val) {
        return typeof val == 'number';
    }
    goog.isNumber = isNumber;
    /**
     * Builds an object structure for the provided namespace path, ensuring that
     * names that already exist are not overwritten. For example:
     * "a.b.c" -> a = {};a.b={};a.b.c={};
     * Used by goog.provide and goog.exportSymbol.
     * @param {string} name name of the object that this file defines.
     * @param {*=} opt_object the object to expose at the end of the path.
     * @param {Object=} opt_objectToExportTo The object to add the path to; default
     *     is `goog.global`.
     * @private
     */
    function exportPath_(name, opt_object, opt_objectToExportTo) {
        var parts = name.split('.');
        var cur = opt_objectToExportTo || goog.global;
        // Internet Explorer exhibits strange behavior when throwing errors from
        // methods externed in this manner.  See the testExportSymbolExceptions in
        // base_test.html for an example.
        if (!(parts[0] in cur) && cur.execScript) {
            cur.execScript('var' + parts[0]);
        }
        for (var part; parts.length && (part = parts.shift());) {
            if (!parts.length && goog.isDef(opt_object)) {
                // last part and we have an object; use it
                cur[part] = opt_object;
            }
            else if (cur[part] && cur[part] !== Object.prototype[part]) {
                cur = cur[part];
            }
            else {
                cur = cur[part] = {};
            }
        }
    }
    goog.exportPath_ = exportPath_;
    /**
     * Defines a named value. In uncompiled mode, the value is retrieved from
     * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
     * has the property specified, and otherwise used the defined defaultValue.
     * When compiled the default can be overridden using the compiler
     * options or the value set in the CLOSURE_DEFINES object.
     *
     * @param {string} name The distinguished name to provide.
     * @param {string|number|boolean} defaultValue
     */
    function define(name, defaultValue) {
        var value = defaultValue;
        if (!COMPILED) {
            var uncompiledDefines = goog.global.CLOSURE_UNCOMPILED_DEFINES;
            var defines = goog.global.CLOSURE_DEFINES;
            if (uncompiledDefines
                // Anti DOM-clobbering runtime check (b/37736576).
                && uncompiledDefines.nodeType === undefined
                && Object.prototype.hasOwnProperty.call(uncompiledDefines, name)) {
                value = uncompiledDefines[name];
            }
            else if (defines
                && defines.nodeType === undefined
                && Object.prototype.hasOwnProperty.call(defines, name)) {
                value = defines[name];
            }
        }
        goog.exportPath_(name, value);
    }
    goog.define = define;
    ;
    /**
     * @define {boolean} DEBUG is provided as a convenience so that debugging code
     * that should not be included in a production. It can be easily stripped
     * by specifying --define goog.DEBUG=false to the Closure Compiler aka
     * JSCompiler. For example, most toString() methods should be declared inside an
     * "if (goog.DEBUG)" conditional because they are generally used for debugging
     * purposes and it is difficult for the JSCompiler to statically determine
     * whether they are used.
     */
    goog.define('goog.DEBUG', true);
    goog.DEBUG = true;
    /**
     * @define {string} LOCALE defines the locale being used for compilation. It is
     * used to select locale specific data to be compiled in js binary. BUILD rule
     * can specify this value by "--define goog.LOCALE=<locale_name>" as a compiler
     * option.
     *
     * Take into account that the locale code format is important. You should use
     * the canonical Unicode format with hyphen as a delimiter. Language must be
     * lowercase, Language Script - Capitalized, Region - UPPERCASE.
     * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
     *
     * See more info about locale codes here:
     * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
     *
     * For language codes you should use values defined by ISO 693-1. See it here
     * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
     * this rule: the Hebrew language. For legacy reasons the old code (iw) should
     * be used instead of the new code (he).
     *
     */
    goog.define('goog.LOCALE', 'en'); // default to en
    goog.LOCALE = 'en';
    /**
     * @define {boolean} Whether this code is running on trusted sites.
     *
     * On untrusted sites, several native functions can be defined or overridden by
     * external libraries like Prototype, Datejs, and JQuery and setting this flag
     * to false forces closure to use its own implementations when possible.
     *
     * If your JavaScript can be loaded by a third party site and you are wary about
     * relying on non-standard implementations, specify
     * "--define goog.TRUSTED_SITE=false" to the compiler.
     */
    goog.define('goog.TRUSTED_SITE', true);
    goog.TRUSTED_SITE = true;
    /**
     * @define {boolean} Whether a project is expected to be running in strict mode.
     *
     * This define can be used to trigger alternate implementations compatible with
     * running in EcmaScript Strict mode or warn about unavailable functionality.
     * @see https://goo.gl/PudQ4y
     *
     */
    goog.define('goog.STRICT_MODE_COMPATIBLE', false);
    goog.STRICT_MODE_COMPATIBLE = false;
    /**
     * @define {boolean} Whether code that calls {@link goog.setTestOnly} should
     *     be disallowed in the compilation unit.
     */
    goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);
    goog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;
    /**
     * @define {boolean} Whether to use a Chrome app CSP-compliant method for
     *     loading scripts via goog.require. @see appendScriptSrcNode_.
     */
    goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);
    goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = false;
    /**
     * Defines a namespace in Closure.
     *
     * A namespace may only be defined once in a codebase. It may be defined using
     * goog.provide() or goog.module().
     *
     * The presence of one or more goog.provide() calls in a file indicates
     * that the file defines the given objects/namespaces.
     * Provided symbols must not be null or undefined.
     *
     * In addition, goog.provide() creates the object stubs for a namespace
     * (for example, goog.provide("goog.foo.bar") will create the object
     * goog.foo.bar if it does not already exist).
     *
     * Build tools also scan for provide/require/module statements
     * to discern dependencies, build dependency files (see deps.js), etc.
     *
     * @see goog.require
     * @see goog.module
     * @param {string} name Namespace provided by this file in the form
     *     "goog.package.part".
     */
    function provide(name) {
        if (goog.isInModuleLoader_()) {
            throw new Error('goog.provide can not be used within a goog.module');
        }
        if (!COMPILED) {
            // Ensure that the same namespace isn't provided twice.
            // A goog.module/goog.provide maps a goog.require to a specific file
            if (goog.isProvided_(name)) {
                throw new Error('Namespace "' + name + '" already declared.');
            }
        }
        goog.constructNamespace_(name);
    }
    goog.provide = provide;
    /**
     * @param {string} name Namespace provided by this file in the form
     *     "goog.package.part".
     * @param {Object=} opt_obj The object to embed in the namespace.
     * @private
     */
    function constructNamespace_(name, opt_obj) {
        if (!COMPILED) {
            delete goog.implicitNamespaces_[name];
            var namespace = name;
            while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
                if (goog.getObjectByName(namespace)) {
                    break;
                }
                goog.implicitNamespaces_[namespace] = true;
            }
        }
        goog.exportPath_(name, opt_obj);
    }
    goog.constructNamespace_ = constructNamespace_;
    /**
     * Module identifier validation regexp.
     * Note: This is a conservative check, it is very possible to be more lenient,
     *   the primary exclusion here is "/" and "\" and a leading ".", these
     *   restrictions are intended to leave the door open for using goog.require
     *   with relative file paths rather than module identifiers.
     * @private
     */
    goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
    /**
     * Defines a module in Closure.
     *
     * Marks that this file must be loaded as a module and claims the namespace.
     *
     * A namespace may only be defined once in a codebase. It may be defined using
     * goog.provide() or goog.module().
     *
     * goog.module() has three requirements:
     * - goog.module may not be used in the same file as goog.provide.
     * - goog.module must be the first statement in the file.
     * - only one goog.module is allowed per file.
     *
     * When a goog.module annotated file is loaded, it is enclosed in
     * a strict function closure. This means that:
     * - any variables declared in a goog.module file are private to the file
     * (not global), though the compiler is expected to inline the module.
     * - The code must obey all the rules of "strict" JavaScript.
     * - the file will be marked as "use strict"
     *
     * NOTE: unlike goog.provide, goog.module does not declare any symbols by
     * itself. If declared symbols are desired, use
     * goog.module.declareLegacyNamespace().
     *
     *
     * See the public goog.module proposal: http://goo.gl/Va1hin
     *
     * @param {string} name Namespace provided by this file in the form
     *     "goog.package.part", is expected but not required.
     * @return {void}
     */
    function module(name) {
        if (!goog.isString(name) || !name ||
            name.search(goog.VALID_MODULE_RE_) == -1) {
            throw new Error('Invalid module identifier');
        }
        if (!goog.isInModuleLoader_()) {
            throw new Error('Module ' + name + ' has been loaded incorrectly. Note, ' +
                'modules cannot be loaded as normal scripts. They require some kind of ' +
                'pre-processing step. You\'re likely trying to load a module via a ' +
                'script tag or as a part of a concatenated bundle without rewriting the ' +
                'module. For more info see: ' +
                'https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.');
        }
        if (goog.moduleLoaderState_.moduleName) {
            throw new Error('goog.module may only be called once per module.');
        }
        // Store the module name for the loader.
        goog.moduleLoaderState_.moduleName = name;
        if (!COMPILED) {
            // Ensure that the same namespace isn't provided twice.
            // A goog.module/goog.provide maps a goog.require to a specific file
            if (goog.isProvided_(name)) {
                throw new Error('Namespace "' + name + '" already declared.');
            }
            delete goog.implicitNamespaces_[name];
        }
    }
    goog.module = module;
    (function (module) {
        /**
         * @param {string} name The module identifier.
         * @return {?} The module exports for an already loaded module or null.
         *
         * Note: This is not an alternative to goog.require, it does not
         * indicate a hard dependency, instead it is used to indicate
         * an optional dependency or to access the exports of a module
         * that has already been loaded.
         * @suppress {missingProvide}
         */
        function get(name) {
            return goog.module.getInternal_(name);
        }
        module.get = get;
        /**
         * @param {string} name The module identifier.
         * @return {?} The module exports for an already loaded module or null.
         * @private
         */
        function getInternal_(name) {
            if (!COMPILED) {
                if (name in goog.loadedModules_) {
                    return goog.loadedModules_[name];
                }
                else if (!goog.implicitNamespaces_[name]) {
                    var ns = goog.getObjectByName(name);
                    return ns != null ? ns : null;
                }
            }
            return null;
        }
        module.getInternal_ = getInternal_;
        /**
         * Provide the module's exports as a globally accessible object under the
         * module's declared name.  This is intended to ease migration to goog.module
         * for files that have existing usages.
         * @suppress {missingProvide}
         */
        function declareLegacyNamespace() {
            if (!COMPILED && !goog.isInModuleLoader_()) {
                throw new Error('goog.module.declareLegacyNamespace must be called from ' +
                    'within a goog.module');
            }
            if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
                throw new Error('goog.module must be called prior to ' +
                    'goog.module.declareLegacyNamespace.');
            }
            goog.moduleLoaderState_.declareLegacyNamespace = true;
        }
        module.declareLegacyNamespace = declareLegacyNamespace;
    })(module = goog.module || (goog.module = {}));
    /**
     * @private {?{moduleName: (string|undefined), declareLegacyNamespace:boolean}}
     */
    goog.moduleLoaderState_ = null;
    /**
     * @private
     * @return {boolean} Whether a goog.module is currently being initialized.
     */
    function isInModuleLoader_() {
        return goog.moduleLoaderState_ != null;
    }
    goog.isInModuleLoader_ = isInModuleLoader_;
    ;
    /**
     * Marks that the current file should only be used for testing, and never for
     * live code in production.
     *
     * In the case of unit tests, the message may optionally be an exact namespace
     * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
     * provide (if not explicitly defined in the code).
     *
     * @param {string=} opt_message Optional message to add to the error that's
     *     raised when used in production code.
     */
    function setTestOnly(opt_message) {
        if (goog.DISALLOW_TEST_ONLY_CODE) {
            opt_message = opt_message || '';
            throw new Error('Importing test-only code into non-debug environment' +
                (opt_message ? ': ' + opt_message : '.'));
        }
    }
    goog.setTestOnly = setTestOnly;
    /**
     * Forward declares a symbol. This is an indication to the compiler that the
     * symbol may be used in the source yet is not required and may not be provided
     * in compilation.
     *
     * The most common usage of forward declaration is code that takes a type as a
     * function parameter but does not need to require it. By forward declaring
     * instead of requiring, no hard dependency is made, and (if not required
     * elsewhere) the namespace may never be required and thus, not be pulled
     * into the JavaScript binary. If it is required elsewhere, it will be type
     * checked as normal.
     *
     * Before using goog.forwardDeclare, please read the documentation at
     * https://github.com/google/closure-compiler/wiki/Bad-Type-Annotation to
     * understand the options and tradeoffs when working with forward declarations.
     *
     * @param {string} name The namespace to forward declare in the form of
     *     "goog.package.part".
     */
    function forwardDeclare(name) {
    }
    goog.forwardDeclare = forwardDeclare;
    ;
    /**
     * Returns an object based on its fully qualified external name.  The object
     * is not found if null or undefined.  If you are using a compilation pass that
     * renames property names beware that using this function will not find renamed
     * properties.
     *
     * @param {string} name The fully qualified name.
     * @param {Object=} opt_obj The object within which to look; default is
     *     |goog.global|.
     * @return {?} The value (object or primitive) or, if not found, null.
     */
    function getObjectByName(name, opt_obj) {
        var parts = name.split('.');
        var cur = opt_obj || goog.global;
        for (var i = 0; i < parts.length; i++) {
            cur = cur[parts[i]];
            if (!goog.isDefAndNotNull(cur)) {
                return null;
            }
        }
        return cur;
    }
    goog.getObjectByName = getObjectByName;
    /**
     * Globalizes a whole namespace, such as goog or goog.lang.
     *
     * @param {!Object} obj The namespace to globalize.
     * @param {Object=} opt_global The object to add the properties to.
     * @deprecated Properties may be explicitly exported to the global scope, but
     *     this should no longer be done in bulk.
     */
    function globalize(obj, opt_global) {
        var global = opt_global || goog.global;
        for (var x in obj) {
            global[x] = obj[x];
        }
    }
    goog.globalize = globalize;
    /**
     * Adds a dependency from a file to the files it requires.
     * @param {string} relPath The path to the js file.
     * @param {!Array<string>} provides An array of strings with
     *     the names of the objects this file provides.
     * @param {!Array<string>} requires An array of strings with
     *     the names of the objects this file requires.
     * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating
     *     how the file must be loaded.  The boolean 'true' is equivalent
     *     to {'module': 'goog'} for backwards-compatibility.  Valid properties
     *     and values include {'module': 'goog'} and {'lang': 'es6'}.
     */
    function addDependency(relPath, provides, requires, opt_loadFlags) {
        if (goog.DEPENDENCIES_ENABLED) {
            var loader = goog.getLoader_();
            if (loader) {
                loader.addDependency(relPath, provides, requires, opt_loadFlags);
            }
        }
    }
    goog.addDependency = addDependency;
    /**
     * @param {string} msg
     * @private
     */
    function logToConsole_(msg) {
        if (goog.global.console) {
            goog.global.console['error'](msg);
        }
    }
    goog.logToConsole_ = logToConsole_;
    /**
     * Implements a system for the dynamic resolution of dependencies that works in
     * parallel with the BUILD system. Note that all calls to goog.require will be
     * stripped by the compiler.
     * @see goog.provide
     * @param {string} name Namespace to include (as was given in goog.provide()) in
     *     the form "goog.package.part".
     * @return {?} If called within a goog.module file, the associated namespace or
     *     module otherwise null.
     */
    function require(name) {
        if (goog.ENABLE_DEBUG_LOADER && goog.debugLoader_) {
            goog.getLoader_().earlyProcessLoad(name);
        }
        // If the object already exists we do not need to do anything.
        if (!COMPILED) {
            if (goog.isProvided_(name)) {
                if (goog.isInModuleLoader_()) {
                    return goog.module.getInternal_(name);
                }
            }
            else if (goog.ENABLE_DEBUG_LOADER) {
                var moduleLoaderState = goog.moduleLoaderState_;
                goog.moduleLoaderState_ = null;
                try {
                    var loader = goog.getLoader_();
                    if (loader) {
                        loader.load(name);
                    }
                    else {
                        goog.logToConsole_('Could not load ' + name + ' because there is no debug loader.');
                    }
                }
                finally {
                    goog.moduleLoaderState_ = moduleLoaderState;
                }
            }
            return null;
        }
    }
    goog.require = require;
    /**
     * Path for included scripts.
     * @type {string}
     */
    goog.bastPath = '';
    /**
     * Null function used for default values of callbacks, etc.
     * @return {void} Nothing.
     */
    function nullFunction() {
    }
    goog.nullFunction = nullFunction;
    /**
     * When defining a class Foo with an abstract method bar(), you can do:
     * Foo.prototype.bar = goog.abstractMethod
     *
     * Now if a subclass of Foo fails to override bar(), an error will be thrown
     * when bar() is invoked.
     *
     * @type {!Function}
     * @throws {Error} when invoked to indicate the method should be overridden.
     */
    function abstractMethod() {
        throw new Error('unimplemented abstract method');
    }
    goog.abstractMethod = abstractMethod;
    /**
     * Adds a {@code getInstance} static method that always returns the same
     * instance object.
     * @param {!Function} ctor The constructor for the class to add the static
     *     method to.
     */
    function addSingletonGetter(ctor) {
        // instance_ is immediately set to prevent issues with sealed constructors
        // such as are encountered when a constructor is returned as the export object
        // of a goog.module in unoptimized code.
        ctor.instance_ = undefined;
        ctor.getInstance = function () {
            if (ctor.instance_) {
                return ctor.instance_;
            }
            if (goog.DEBUG) {
                // NOTE: JSCompiler can't optimize away Array#push.
                goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
            }
            return ctor.instance_ = new ctor;
        };
    }
    goog.addSingletonGetter = addSingletonGetter;
    /**
     * All singleton classes that have been instantiated, for testing. Don't read
     * it directly, use the {@code goog.testing.singleton} module. The compiler
     * removes this variable if unused.
     * @type {!Array<!Function>}
     * @private
     */
    goog.instantiatedSingletons_ = [];
    /**
     * The registry of initialized modules:
     * the module identifier to module exports map.
     * @private @const {!Object<string, ?>}
     */
    goog.loadedModules_ = {};
    /**
     * True if goog.dependencies_ is available.
     * @const {boolean}
     */
    goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
    /**
     * @package {?boolean}
     * Visible for testing.
     */
    goog.hasBadLetScoping = null;
    /**
     * @return {boolean}
     * @package Visible for testing.
     */
    function useSafari10Workaround() {
        if (goog.hasBadLetScoping == null) {
            var hasBadLetScoping;
            try {
                hasBadLetScoping = !eval('"use strict";' +
                    'let x = 1; function f() { return typeof x; };' +
                    'f() == "number";');
            }
            catch (e) {
                // Assume that ES6 syntax isn't supported.
                hasBadLetScoping = false;
            }
            goog.hasBadLetScoping = hasBadLetScoping;
        }
        return goog.hasBadLetScoping;
    }
    goog.useSafari10Workaround = useSafari10Workaround;
    ;
    /**
     * @param {string} moduleDef
     * @return {string}
     * @package Visible for testing.
     */
    function workaroundSafari10EvalBug(moduleDef) {
        return '(function(){' + moduleDef +
            '\n' + // Terminate any trailing single line comment.
            ';' + // Terminate any trailing expression.
            '})();\n';
    }
    goog.workaroundSafari10EvalBug = workaroundSafari10EvalBug;
    ;
    /**
     * @param {function(?):?|string} moduleDef The module definition.
     */
    function loadModule(moduleDef) {
        // NOTE: we allow function definitions to be either in the from
        // of a string to eval (which keeps the original source intact) or
        // in a eval forbidden environment (CSP) we allow a function definition
        // which in its body must call {@code goog.module}, and return the exports
        // of the module.
        var previousState = goog.moduleLoaderState_;
        try {
            goog.moduleLoaderState_ = {
                moduleName: undefined,
                declareLegacyNamespace: false
            };
            var exports;
            if (goog.isFunction(moduleDef)) {
                exports = moduleDef.call(undefined, {});
            }
            else if (goog.isString(moduleDef)) {
                if (goog.useSafari10Workaround()) {
                    moduleDef = goog.workaroundSafari10EvalBug(moduleDef);
                }
                exports = goog.loadModuleFromSource_.call(undefined, moduleDef);
            }
            else {
                throw new Error('Invalid module definition');
            }
            var moduleName = goog.moduleLoaderState_.moduleName;
            if (goog.isString(moduleName) && moduleName) {
                // Don't seal legacy namespaces as they may be used as a parent of
                // another namespace
                if (goog.moduleLoaderState_.declareLegacyNamespace) {
                    goog.constructNamespace_(moduleName, exports);
                }
                else if (goog.SEAL_MODULE_EXPORTS && Object.seal &&
                    typeof exports == 'object' && exports != null) {
                    Object.seal(exports);
                }
                goog.loadedModules_[moduleName] = exports;
            }
            else {
                throw new Error('Invalid module name \"' + moduleName + '\"');
            }
        }
        finally {
            goog.moduleLoaderState_ = previousState;
        }
    }
    goog.loadModule = loadModule;
    ;
    /**
     * @private @const
     */
    function loadModuleFromSource_() {
        // NOTE: we avoid declaring parameters or local variables here to avoid
        // masking globals or leaking values into the module definition.
        'use strict';
        var exports = {};
        eval(arguments[0]);
        return exports;
    }
    goog.loadModuleFromSource_ = loadModuleFromSource_;
    ;
    /**
     * Normalize a file path by removing redundant ".." and extraneous "." file
     * path components.
     * @param {string} path
     * @return {string}
     * @private
     */
    function normalizePath_(path) {
        var components = path.split('/');
        var i = 0;
        while (i < components.length) {
            if (components[i] == '.') {
                components.splice(i, 1);
            }
            else if (i && components[i] == '..' && components[i - 1] &&
                components[i - 1] != '..') {
                components.splice(--i, 2);
            }
            else {
                i++;
            }
        }
        return components.join('/');
    }
    goog.normalizePath_ = normalizePath_;
    /**
 * Loads file by synchronous XHR. Should not be used in production environments.
 * @param {string} src Source URL.
 * @return {?string} File contents, or null if load failed.
 * @private
 */
    function loadFileSync_(src) {
        if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
            return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
        }
        else {
            try {
                /** @type {XMLHttpRequest} */
                var xhr = new goog.global['XMLHttpRequest']();
                xhr.open('get', src, false);
                xhr.send();
                // NOTE: Successful http: requests have a status of 200, but successful
                // file: requests may have a status of zero.  Any other status, or a
                // thrown exception (particularly in case of file: requests) indicates
                // some sort of error, which we treat as a missing or unavailable file.
                return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null;
            }
            catch (err) {
                // No need to rethrow or log, since errors should show up on their own.
                return null;
            }
        }
    }
    goog.loadFileSync_ = loadFileSync_;
    ;
    /**
     * Lazily retrieves the transpiler and applies it to the source.
     * @param {string} code JS code.
     * @param {string} path Path to the code.
     * @return {string} The transpiled code.
     * @private
     */
    function transpile_(code, path) {
        var jscomp = goog.global['$jscomp'];
        if (!jscomp) {
            goog.global['$jscomp'] = jscomp = {};
        }
        var transpile = jscomp.transpile;
        if (!transpile) {
            var transpilerPath = goog.basePath + goog.TRANSPILER;
            var transpilerCode = goog.loadFileSync_(transpilerPath);
            if (transpilerCode) {
                // This must be executed synchronously, since by the time we know we
                // need it, we're about to load and write the ES6 code synchronously,
                // so a normal script-tag load will be too slow. Wrapped in a function
                // so that code is eval'd in the global scope.
                (function () {
                    eval(transpilerCode + '\n//# sourceURL=' + transpilerPath);
                }).call(goog.global);
                // Even though the transpiler is optional, if $gwtExport is found, it's
                // a sign the transpiler was loaded and the $jscomp.transpile *should*
                // be there.
                if (goog.global['$gwtExport'] && goog.global['$gwtExport']['$jscomp'] &&
                    !goog.global['$gwtExport']['$jscomp']['transpile']) {
                    throw new Error('The transpiler did not properly export the "transpile" ' +
                        'method. $gwtExport: ' + JSON.stringify(goog.global['$gwtExport']));
                }
                // transpile.js only exports a single $jscomp function, transpile. We
                // grab just that and add it to the existing definition of $jscomp which
                // contains the polyfills.
                goog.global['$jscomp'].transpile =
                    goog.global['$gwtExport']['$jscomp']['transpile'];
                jscomp = goog.global['$jscomp'];
                transpile = jscomp.transpile;
            }
        }
        if (!transpile) {
            // The transpiler is an optional component.  If it's not available then
            // replace it with a pass-through function that simply logs.
            var suffix = ' requires transpilation but no transpiler was found.';
            transpile = jscomp.transpile = function (code, path) {
                // TODO(user): figure out some way to get this error to show up
                // in test results, noting that the failure may occur in many
                // different ways, including in loadModule() before the test
                // runner even comes up.
                goog.logToConsole_(path + suffix);
                return code;
            };
        }
        // Note: any transpilation errors/warnings will be logged to the console.
        return transpile(code, path);
    }
    goog.transpile_ = transpile_;
    ;
    //==============================================================================
    // Language Enhancements
    //==============================================================================
    /**
     * This is a "fixed" version of the typeof operator.  It differs from the typeof
     * operator in such a way that null returns 'null' and arrays return 'array'.
     * @param {?} value The value to get the type of.
     * @return {string} The name of the type.
     */
    function typeOf(value) {
        var s = typeof value;
        if (s == 'object') {
            if (value) {
                // Check these first, so we can avoid calling Object.prototype.toString if
                // possible.
                //
                // IE improperly marshals typeof across execution contexts, but a
                // cross-context object will still return false for "instanceof Object".
                if (value instanceof Array) {
                    return 'array';
                }
                else if (value instanceof Object) {
                    return s;
                }
                // HACK: In order to use an Object prototype method on the arbitrary
                //   value, the compiler requires the value be cast to type Object,
                //   even though the ECMA spec explicitly allows it.
                var className = Object.prototype.toString.call(
                /** @type {!Object} */ (value));
                // In Firefox 3.6, attempting to access iframe window objects' length
                // property throws an NS_ERROR_FAILURE, so we need to special-case it
                // here.
                if (className == '[object Window]') {
                    return 'object';
                }
                // We cannot always use constructor == Array or instanceof Array because
                // different frames have different Array objects. In IE6, if the iframe
                // where the array was created is destroyed, the array loses its
                // prototype. Then dereferencing val.splice here throws an exception, so
                // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
                // so that will work. In this case, this function will return false and
                // most array functions will still work because the array is still
                // array-like (supports length and []) even though it has lost its
                // prototype.
                // Mark Miller noticed that Object.prototype.toString
                // allows access to the unforgeable [[Class]] property.
                //  15.2.4.2 Object.prototype.toString ( )
                //  When the toString method is called, the following steps are taken:
                //      1. Get the [[Class]] property of this object.
                //      2. Compute a string value by concatenating the three strings
                //         "[object ", Result(1), and "]".
                //      3. Return Result(2).
                // and this behavior survives the destruction of the execution context.
                if ((className == '[object Array]' ||
                    // In IE all non value types are wrapped as objects across window
                    // boundaries (not iframe though) so we have to do object detection
                    // for this edge case.
                    typeof value.length == 'number' &&
                        typeof value.splice != 'undefined' &&
                        typeof value.propertyIsEnumerable != 'undefined' &&
                        !value.propertyIsEnumerable('splice'))) {
                    return 'array';
                }
                // HACK: There is still an array case that fails.
                //     function ArrayImpostor() {}
                //     ArrayImpostor.prototype = [];
                //     var impostor = new ArrayImpostor;
                // this can be fixed by getting rid of the fast path
                // (value instanceof Array) and solely relying on
                // (value && Object.prototype.toString.vall(value) === '[object Array]')
                // but that would require many more function calls and is not warranted
                // unless closure code is receiving objects from untrusted sources.
                // IE in cross-window calls does not correctly marshal the function type
                // (it appears just as an object) so we cannot use just typeof val ==
                // 'function'. However, if the object has a call property, it is a
                // function.
                if ((className == '[object Function]' ||
                    typeof value.call != 'undefined' &&
                        typeof value.propertyIsEnumerable != 'undefined' &&
                        !value.propertyIsEnumerable('call'))) {
                    return 'function';
                }
            }
            else {
                return 'null';
            }
        }
        else if (s == 'function' && typeof value.call == 'undefined') {
            // In Safari typeof nodeList returns 'function', and on Firefox typeof
            // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
            // would like to return object for those and we can detect an invalid
            // function by making sure that the function object has a call method.
            return 'object';
        }
        return s;
    }
    goog.typeOf = typeOf;
    ;
    /**
     * Returns true if the specified value is null.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is null.
     */
    function isNull(val) {
        return val === null;
    }
    goog.isNull = isNull;
    ;
    /**
     * Returns true if the specified value is defined and not null.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is defined and not null.
     */
    function isDefAndNotNull(val) {
        // Note that undefined == null.
        return val != null;
    }
    goog.isDefAndNotNull = isDefAndNotNull;
    ;
    /**
     * Returns true if the specified value is an array.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is an array.
     */
    function isArray(val) {
        return goog.typeOf(val) == 'array';
    }
    goog.isArray = isArray;
    ;
    /**
     * Returns true if the object looks like an array. To qualify as array like
     * the value needs to be either a NodeList or an object with a Number length
     * property. As a special case, a function value is not array like, because its
     * length property is fixed to correspond to the number of expected arguments.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is an array.
     */
    function isArrayLike(val) {
        var type = goog.typeOf(val);
        // We do not use goog.isObject here in order to exclude function values.
        return type == 'array' || type == 'object' && typeof val.length == 'number';
    }
    goog.isArrayLike = isArrayLike;
    ;
    /**
     * Returns true if the object looks like a Date. To qualify as Date-like the
     * value needs to be an object and have a getFullYear() function.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is a like a Date.
     */
    function isDateLike(val) {
        return goog.isObject(val) && typeof val.getFullYear == 'function';
    }
    goog.isDateLike = isDateLike;
    ;
    /**
     * Returns true if the specified value is a function.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is a function.
     */
    function isFunction(val) {
        return goog.typeOf(val) == 'function';
    }
    goog.isFunction = isFunction;
    ;
    /**
     * Returns true if the specified value is an object.  This includes arrays and
     * functions.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is an object.
     */
    function isObject(val) {
        var type = typeof val;
        return type == 'object' && val != null || type == 'function';
        // return Object(val) === val also works, but is slower, especially if val is
        // not an object.
    }
    goog.isObject = isObject;
    ;
    /**
     * Gets a unique ID for an object. This mutates the object so that further calls
     * with the same object as a parameter returns the same value. The unique ID is
     * guaranteed to be unique across the current session amongst objects that are
     * passed into {@code getUid}. There is no guarantee that the ID is unique or
     * consistent across sessions. It is unsafe to generate unique ID for function
     * prototypes.
     *
     * @param {Object} obj The object to get the unique ID for.
     * @return {number} The unique ID for the object.
     */
    function getUid(obj) {
        // TODO(arv): Make the type stricter, do not accept null.
        // In Opera window.hasOwnProperty exists but always returns false so we avoid
        // using it. As a consequence the unique ID generated for BaseClass.prototype
        // and SubClass.prototype will be the same.
        return obj[goog.UID_PROPERTY_] ||
            (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
    }
    goog.getUid = getUid;
    ;
    /**
     * Whether the given object is already assigned a unique ID.
     *
     * This does not modify the object.
     *
     * @param {!Object} obj The object to check.
     * @return {boolean} Whether there is an assigned unique id for the object.
     */
    function hasUid(obj) {
        return !!obj[goog.UID_PROPERTY_];
    }
    goog.hasUid = hasUid;
    ;
    /**
     * Removes the unique ID from an object. This is useful if the object was
     * previously mutated using {@code goog.getUid} in which case the mutation is
     * undone.
     * @param {Object} obj The object to remove the unique ID field from.
     */
    function removeUid(obj) {
        // TODO(arv): Make the type stricter, do not accept null.
        // In IE, DOM nodes are not instances of Object and throw an exception if we
        // try to delete.  Instead we try to use removeAttribute.
        if (obj !== null && 'removeAttribute' in obj) {
            obj.removeAttribute(goog.UID_PROPERTY_);
        }
        try {
            delete obj[goog.UID_PROPERTY_];
        }
        catch (ex) {
        }
    }
    goog.removeUid = removeUid;
    ;
    /**
     * Name for unique ID property. Initialized in a way to help avoid collisions
     * with other closure JavaScript on the same page.
     * @type {string}
     * @private
     */
    goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);
    /**
     * Counter for UID.
     * @type {number}
     * @private
     */
    goog.uidCounter_ = 0;
    /**
     * Adds a hash code field to an object. The hash code is unique for the
     * given object.
     * @param {Object} obj The object to get the hash code for.
     * @return {number} The hash code for the object.
     * @deprecated Use goog.getUid instead.
     */
    goog.getHashCode = goog.getUid;
    /**
     * Removes the hash code field from an object.
     * @param {Object} obj The object to remove the field from.
     * @deprecated Use goog.removeUid instead.
     */
    goog.removeHashCode = goog.removeUid;
    /**
     * Clones a value. The input may be an Object, Array, or basic type. Objects and
     * arrays will be cloned recursively.
     *
     * WARNINGS:
     * <code>goog.cloneObject</code> does not detect reference loops. Objects that
     * refer to themselves will cause infinite recursion.
     *
     * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
     * UIDs created by <code>getUid</code> into cloned results.
     *
     * @param {*} obj The value to clone.
     * @return {*} A clone of the input value.
     * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
     */
    function cloneObject(obj) {
        var type = goog.typeOf(obj);
        if (type == 'object' || type == 'array') {
            if (obj.clone) {
                return obj.clone();
            }
            var clone = type == 'array' ? [] : {};
            for (var key in obj) {
                clone[key] = goog.cloneObject(obj[key]);
            }
            return clone;
        }
        return obj;
    }
    goog.cloneObject = cloneObject;
    ;
    /**
     * A native implementation of goog.bind.
     * @param {?function(this:T, ...)} fn A function to partially apply.
     * @param {T} selfObj Specifies the object which this should point to when the
     *     function is run.
     * @param {...*} var_args Additional arguments that are partially applied to the
     *     function.
     * @return {!Function} A partially-applied form of the function goog.bind() was
     *     invoked as a method of.
     * @template T
     * @private
     */
    function bindNative_(fn, selfObj, var_args) {
        return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
    }
    goog.bindNative_ = bindNative_;
    ;
    /**
     * A pure-JS implementation of goog.bind.
     * @param {?function(this:T, ...)} fn A function to partially apply.
     * @param {T} selfObj Specifies the object which this should point to when the
     *     function is run.
     * @param {...*} var_args Additional arguments that are partially applied to the
     *     function.
     * @return {!Function} A partially-applied form of the function goog.bind() was
     *     invoked as a method of.
     * @template T
     * @private
     */
    function bindJs_(fn, selfObj, var_args) {
        if (!fn) {
            throw new Error();
        }
        if (arguments.length > 2) {
            var boundArgs = Array.prototype.slice.call(arguments, 2);
            return function () {
                // Prepend the bound arguments to the current arguments.
                var newArgs = Array.prototype.slice.call(arguments);
                Array.prototype.unshift.apply(newArgs, boundArgs);
                return fn.apply(selfObj, newArgs);
            };
        }
        else {
            return function () {
                return fn.apply(selfObj, arguments);
            };
        }
    }
    goog.bindJs_ = bindJs_;
    ;
    /**
     * Partially applies this function to a particular 'this object' and zero or
     * more arguments. The result is a new function with some arguments of the first
     * function pre-filled and the value of this 'pre-specified'.
     *
     * Remaining arguments specified at call-time are appended to the pre-specified
     * ones.
     *
     * Also see: {@link #partial}.
     *
     * Usage:
     * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');
     * barMethBound('arg3', 'arg4');</pre>
     *
     * @param {?function(this:T, ...)} fn A function to partially apply.
     * @param {T} selfObj Specifies the object which this should point to when the
     *     function is run.
     * @param {...*} var_args Additional arguments that are partially applied to the
     *     function.
     * @return {!Function} A partially-applied form of the function goog.bind() was
     *     invoked as a method of.
     * @template T
     * @suppress {deprecated} See above.
     */
    function bind(fn, selfObj) {
        var var_args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            var_args[_i - 2] = arguments[_i];
        }
        // TODO(nicksantos): narrow the type signature.
        if (Function.prototype.bind &&
            // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
            // extension environment. This means that for Chrome extensions, they get
            // the implementation of Function.prototype.bind that calls goog.bind
            // instead of the native one. Even worse, we don't want to introduce a
            // circular dependency between goog.bind and Function.prototype.bind, so
            // we have to hack this to make sure it works correctly.
            Function.prototype.bind.toString().indexOf('native code') != -1) {
            goog.bind = goog.bindNative_;
        }
        else {
            goog.bind = goog.bindJs_;
        }
        return goog.bind.apply(null, arguments);
    }
    goog.bind = bind;
    ;
    /**
     * Like goog.bind(), except that a 'this object' is not required. Useful when
     * the target function is already bound.
     *
     * Usage:
     * var g = goog.partial(f, arg1, arg2);
     * g(arg3, arg4);
     *
     * @param {Function} fn A function to partially apply.
     * @param {...*} var_args Additional arguments that are partially applied to fn.
     * @return {!Function} A partially-applied form of the function goog.partial()
     *     was invoked as a method of.
     */
    function partial(fn) {
        var var_args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            var_args[_i - 1] = arguments[_i];
        }
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            // Clone the array (with slice()) and append additional arguments
            // to the existing arguments.
            var newArgs = args.slice();
            newArgs.push.apply(newArgs, arguments);
            return fn.apply(this, newArgs);
        };
    }
    goog.partial = partial;
    ;
    /**
     * Copies all the members of a source object to a target object. This method
     * does not work on all browsers for all objects that contain keys such as
     * toString or hasOwnProperty. Use goog.object.extend for this purpose.
     * @param {Object} target Target.
     * @param {Object} source Source.
     */
    function mixin(target, source) {
        for (var x in source) {
            target[x] = source[x];
        }
        // For IE7 or lower, the for-in-loop does not contain any properties that are
        // not enumerable on the prototype object (for example, isPrototypeOf from
        // Object.prototype) but also it will not include 'replace' on objects that
        // extend String and change 'replace' (not that it is common for anyone to
        // extend anything except Object).
    }
    goog.mixin = mixin;
    ;
    /**
     * @return {number} An integer value representing the number of milliseconds
     *     between midnight, January 1, 1970 and the current time.
     */
    function now() {
        // Unary plus operator converts its operand to a number which in
        // the case of
        // a date is done by calling getTime().
        return (goog.TRUSTED_SITE && Date.now || +new Date());
    }
    goog.now = now;
    /**
     * Evals JavaScript in the global scope.  In IE this uses execScript, other
     * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
     * global scope (for example, in Safari), appends a script tag instead.
     * Throws an exception if neither execScript or eval is defined.
     * @param {string} script JavaScript string.
     */
    function globalEval(script) {
        if (goog.global.execScript) {
            goog.global.execScript(script, 'JavaScript');
        }
        else if (goog.global.eval) {
            // Test to see if eval works
            if (goog.evalWorksForGlobals_ == null) {
                try {
                    goog.global.eval('var _evalTest_ = 1;');
                }
                catch (ignore) {
                }
                if (typeof goog.global['_evalTest_'] != 'undefined') {
                    try {
                        delete goog.global['_evalTest_'];
                    }
                    catch (ignore) {
                        // Microsoft edge fails the deletion above in strict mode.
                    }
                    goog.evalWorksForGlobals_ = true;
                }
                else {
                    goog.evalWorksForGlobals_ = false;
                }
            }
            if (goog.evalWorksForGlobals_) {
                goog.global.eval(script);
            }
            else {
                /** @type {!Document} */
                var doc = goog.global.document;
                var scriptElt = 
                /** @type {!HTMLScriptElement} */ (doc.createElement('SCRIPT'));
                scriptElt.type = 'text/javascript';
                scriptElt.defer = false;
                // Note(user): can't use .innerHTML since "t('<test>')" will fail and
                // .text doesn't work in Safari 2.  Therefore we append a text node.
                scriptElt.appendChild(doc.createTextNode(script));
                doc.head.appendChild(scriptElt);
                doc.head.removeChild(scriptElt);
            }
        }
        else {
            throw new Error('goog.globalEval not available');
        }
    }
    goog.globalEval = globalEval;
    ;
    /**
     * Indicates whether or not we can call 'eval' directly to eval code in the
     * global scope. Set to a Boolean by the first call to goog.globalEval (which
     * empirically tests whether eval works for globals). @see goog.globalEval
     * @type {?boolean}
     * @private
     */
    goog.evalWorksForGlobals_ = null;
    /**
     * Handles strings that are intended to be used as CSS class names.
     *
     * This function works in tandem with @see goog.setCssNameMapping.
     *
     * Without any mapping set, the arguments are simple joined with a hyphen and
     * passed through unaltered.
     *
     * When there is a mapping, there are two possible styles in which these
     * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
     * of the passed in css name is rewritten according to the map. In the BY_WHOLE
     * style, the full css name is looked up in the map directly. If a rewrite is
     * not specified by the map, the compiler will output a warning.
     *
     * When the mapping is passed to the compiler, it will replace calls to
     * goog.getCssName with the strings from the mapping, e.g.
     *     var x = goog.getCssName('foo');
     *     var y = goog.getCssName(this.baseClass, 'active');
     *  becomes:
     *     var x = 'foo';
     *     var y = this.baseClass + '-active';
     *
     * If one argument is passed it will be processed, if two are passed only the
     * modifier will be processed, as it is assumed the first argument was generated
     * as a result of calling goog.getCssName.
     *
     * @param {string} className The class name.
     * @param {string=} opt_modifier A modifier to be appended to the class name.
     * @return {string} The class name or the concatenation of the class name and
     *     the modifier.
     */
    function getCssName(className, opt_modifier) {
        // String() is used for compatibility with compiled soy where the passed
        // className can be non-string objects.
        if (String(className).charAt(0) == '.') {
            throw new Error('className passed in goog.getCssName must not start with ".".' +
                ' You passed: ' + className);
        }
        var getMapping = function (cssName) {
            return goog.cssNameMapping_[cssName] || cssName;
        };
        var renameByParts = function (cssName) {
            // Remap all the parts individually.
            var parts = cssName.split('-');
            var mapped = [];
            for (var i = 0; i < parts.length; i++) {
                mapped.push(getMapping(parts[i]));
            }
            return mapped.join('-');
        };
        var rename;
        if (goog.cssNameMapping_) {
            rename =
                goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;
        }
        else {
            rename = function (a) {
                return a;
            };
        }
        var result = opt_modifier ? className + '-' + rename(opt_modifier) : rename(className);
        // The special CLOSURE_CSS_NAME_MAP_FN allows users to specify further
        // processing of the class name.
        if (goog.global.CLOSURE_CSS_NAME_MAP_FN) {
            return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);
        }
        return result;
    }
    goog.getCssName = getCssName;
    ;
    /**
     * Sets the map to check when returning a value from goog.getCssName(). Example:
     * <pre>
     * goog.setCssNameMapping({
     *   "goog": "a",
     *   "disabled": "b",
     * });
     *
     * var x = goog.getCssName('goog');
     * // The following evaluates to: "a a-b".
     * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
     * </pre>
     * When declared as a map of string literals to string literals, the JSCompiler
     * will replace all calls to goog.getCssName() using the supplied map if the
     * --process_closure_primitives flag is set.
     *
     * @param {!Object} mapping A map of strings to strings where keys are possible
     *     arguments to goog.getCssName() and values are the corresponding values
     *     that should be returned.
     * @param {string=} opt_style The style of css name mapping. There are two valid
     *     options: 'BY_PART', and 'BY_WHOLE'.
     * @see goog.getCssName for a description.
     */
    function setCssNameMapping(mapping, opt_style) {
        goog.cssNameMapping_ = mapping;
        goog.cssNameMappingStyle_ = opt_style;
    }
    goog.setCssNameMapping = setCssNameMapping;
    ;
    /**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * This function produces a string which should be treated as plain text. Use
 * {@link goog.html.SafeHtmlFormatter} in conjunction with goog.getMsg to
 * produce SafeHtml.
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object<string, string>=} opt_values Maps place holder name to value.
 * @return {string} message with placeholders filled.
 */
    function getMsg(str, opt_values) {
        if (opt_values) {
            str = str.replace(/\{\$([^}]+)}/g, function (match, key) {
                return (opt_values != null && key in opt_values) ? opt_values[key] :
                    match;
            });
        }
        return str;
    }
    goog.getMsg = getMsg;
    ;
    /**
     * Gets a localized message. If the message does not have a translation, gives a
     * fallback message.
     *
     * This is useful when introducing a new message that has not yet been
     * translated into all languages.
     *
     * This function is a compiler primitive. Must be used in the form:
     * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
     * where MSG_A and MSG_B were initialized with goog.getMsg.
     *
     * @param {string} a The preferred message.
     * @param {string} b The fallback message.
     * @return {string} The best translated message.
     */
    function getMsgWithFallback(a, b) {
        return a;
    }
    goog.getMsgWithFallback = getMsgWithFallback;
    ;
    /**
     * Exposes an unobfuscated global namespace path for the given object.
     * Note that fields of the exported object *will* be obfuscated, unless they are
     * exported in turn via this function or goog.exportProperty.
     *
     * Also handy for making public items that are defined in anonymous closures.
     *
     * ex. goog.exportSymbol('public.path.Foo', Foo);
     *
     * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
     *     public.path.Foo.staticFunction();
     *
     * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
     *                       Foo.prototype.myMethod);
     *     new public.path.Foo().myMethod();
     *
     * @param {string} publicPath Unobfuscated name to export.
     * @param {*} object Object the name should point to.
     * @param {Object=} opt_objectToExportTo The object to add the path to; default
     *     is goog.global.
     */
    function exportSymbol(publicPath, object, opt_objectToExportTo) {
        goog.exportPath_(publicPath, object, opt_objectToExportTo);
    }
    goog.exportSymbol = exportSymbol;
    ;
    /**
     * Exports a property unobfuscated into the object's namespace.
     * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
     * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
     * @param {Object} object Object whose static property is being exported.
     * @param {string} publicName Unobfuscated name to export.
     * @param {*} symbol Object the name should point to.
     */
    function exportProperty(object, publicName, symbol) {
        object[publicName] = symbol;
    }
    goog.exportProperty = exportProperty;
    ;
    /**
     * Inherit the prototype methods from one constructor into another.
     *
     * Usage:
     * <pre>
     * function ParentClass(a, b) { }
     * ParentClass.prototype.foo(a) { };
     *
     * function ChildClass(a, b, c) {
     *   ChildClass.base(this, 'constructor', a, b);
     * }
     * goog.inherits(ChildClass, ParentClass);
     *
     * var child = new ChildClass('a', 'b', 'see');
     * child.foo(); // This works.
     * </pre>
     *
     * @param {!Function} childCtor Child class.
     * @param {!Function} parentCtor Parent class.
     */
    function inherits(childCtor, parentCtor) {
        /** @constructor */
        function tempCtor() { }
        tempCtor.prototype = parentCtor.prototype;
        childCtor.superClass_ = parentCtor.prototype;
        childCtor.prototype = new tempCtor();
        /** @override */
        childCtor.prototype.constructor = childCtor;
        /**
         * Calls superclass constructor/method.
         *
         * This function is only available if you use goog.inherits to
         * express inheritance relationships between classes.
         *
         * NOTE: This is a replacement for goog.base and for superClass_
         * property defined in childCtor.
         *
         * @param {!Object} me Should always be "this".
         * @param {string} methodName The method name to call. Calling
         *     superclass constructor can be done with the special string
         *     'constructor'.
         * @param {...*} var_args The arguments to pass to superclass
         *     method/constructor.
         * @return {*} The return value of the superclass method/constructor.
         */
        childCtor.base = function (me, methodName, var_args) {
            // Copying using loop to avoid deop due to passing arguments object to
            // function. This is faster in many JS engines as of late 2014.
            var args = new Array(arguments.length - 2);
            for (var i = 2; i < arguments.length; i++) {
                args[i - 2] = arguments[i];
            }
            return parentCtor.prototype[methodName].apply(me, args);
        };
    }
    goog.inherits = inherits;
    ;
    /**
     * Call up to the superclass.
     *
     * If this is called from a constructor, then this calls the superclass
     * constructor with arguments 1-N.
     *
     * If this is called from a prototype method, then you must pass the name of the
     * method as the second argument to this function. If you do not, you will get a
     * runtime error. This calls the superclass' method with arguments 2-N.
     *
     * This function only works if you use goog.inherits to express inheritance
     * relationships between your classes.
     *
     * This function is a compiler primitive. At compile-time, the compiler will do
     * macro expansion to remove a lot of the extra overhead that this function
     * introduces. The compiler will also enforce a lot of the assumptions that this
     * function makes, and treat it as a compiler error if you break them.
     *
     * @param {!Object} me Should always be "this".
     * @param {*=} opt_methodName The method name if calling a super method.
     * @param {...*} var_args The rest of the arguments.
     * @return {*} The return value of the superclass method.
     * @suppress {es5Strict} This method can not be used in strict mode, but
     *     all Closure Library consumers must depend on this file.
     * @deprecated goog.base is not strict mode compatible.  Prefer the static
     *     "base" method added to the constructor by goog.inherits
     *     or ES6 classes and the "super" keyword.
     */
    function base(me, opt_methodName, var_args) {
        var caller = arguments.callee.caller;
        if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG && !caller)) {
            throw new Error('arguments.caller not defined.  goog.base() cannot be used ' +
                'with strict mode code. See ' +
                'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
        }
        if (caller.superClass_) {
            // Copying using loop to avoid deop due to passing arguments object to
            // function. This is faster in many JS engines as of late 2014.
            var ctorArgs = new Array(arguments.length - 1);
            for (var i = 1; i < arguments.length; i++) {
                ctorArgs[i - 1] = arguments[i];
            }
            // This is a constructor. Call the superclass constructor.
            return caller.superClass_.constructor.apply(me, ctorArgs);
        }
        // Copying using loop to avoid deop due to passing arguments object to
        // function. This is faster in many JS engines as of late 2014.
        var args = new Array(arguments.length - 2);
        for (var i = 2; i < arguments.length; i++) {
            args[i - 2] = arguments[i];
        }
        var foundCaller = false;
        for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
            if (ctor.prototype[opt_methodName] === caller) {
                foundCaller = true;
            }
            else if (foundCaller) {
                return ctor.prototype[opt_methodName].apply(me, args);
            }
        }
        // If we did not find the caller in the prototype chain, then one of two
        // things happened:
        // 1) The caller is an instance method.
        // 2) This method was not called by the right caller.
        if (me[opt_methodName] === caller) {
            return me.constructor.prototype[opt_methodName].apply(me, args);
        }
        else {
            throw new Error('goog.base called from a method of one name ' +
                'to a method of a different name');
        }
    }
    goog.base = base;
    ;
    /**
     * Allow for aliasing within scope functions.  This function exists for
     * uncompiled code - in compiled code the calls will be inlined and the aliases
     * applied.  In uncompiled code the function is simply run since the aliases as
     * written are valid JavaScript.
     *
     *
     * @param {function()} fn Function to call.  This function can contain aliases
     *     to namespaces (e.g. "var dom = goog.dom") or classes
     *     (e.g. "var Timer = goog.Timer").
     */
    function scope(fn) {
        if (goog.isInModuleLoader_()) {
            throw new Error('goog.scope is not supported within a goog.module.');
        }
        fn.call(goog.global);
    }
    goog.scope = scope;
    ;
    //==============================================================================
    // goog.defineClass implementation
    //==============================================================================
    /**
     * Creates a restricted form of a Closure "class":
     *   - from the compiler's perspective, the instance returned from the
     *     constructor is sealed (no new properties may be added).  This enables
     *     better checks.
     *   - the compiler will rewrite this definition to a form that is optimal
     *     for type checking and optimization (initially this will be a more
     *     traditional form).
     *
     * @param {Function} superClass The superclass, Object or null.
     * @param {goog.defineClass.ClassDescriptor} def
     *     An object literal describing
     *     the class.  It may have the following properties:
     *     "constructor": the constructor function
     *     "statics": an object literal containing methods to add to the constructor
     *        as "static" methods or a function that will receive the constructor
     *        function as its only parameter to which static properties can
     *        be added.
     *     all other properties are added to the prototype.
     * @return {!Function} The class constructor.
     */
    function defineClass(superClass, def) {
        // TODO(johnlenz): consider making the superClass an optional parameter.
        var constructor = def.constructor;
        var statics = def.statics;
        // Wrap the constructor prior to setting up the prototype and static methods.
        if (!constructor || constructor == Object.prototype.constructor) {
            constructor = function () {
                throw new Error('cannot instantiate an interface (no constructor defined).');
            };
        }
        var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);
        if (superClass) {
            goog.inherits(cls, superClass);
        }
        // Remove all the properties that should not be copied to the prototype.
        delete def.constructor;
        delete def.statics;
        goog.defineClass.applyProperties_(cls.prototype, def);
        if (statics != null) {
            if (statics instanceof Function) {
                statics(cls);
            }
            else {
                goog.defineClass.applyProperties_(cls, statics);
            }
        }
        return cls;
    }
    goog.defineClass = defineClass;
    ;
    (function (defineClass) {
        /**
         * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is
         * defined, this function will wrap the constructor in a function that seals the
         * results of the provided constructor function.
         *
         * @param {!Function} ctr The constructor whose results maybe be sealed.
         * @param {Function} superClass The superclass constructor.
         * @return {!Function} The replacement constructor.
         * @private
         */
        function createSealingConstructor_(ctr, superClass) {
            if (!goog.defineClass.SEAL_CLASS_INSTANCES) {
                // Do now wrap the constructor when sealing is disabled. Angular code
                // depends on this for injection to work properly.
                return ctr;
            }
            // Compute whether the constructor is sealable at definition time, rather
            // than when the instance is being constructed.
            var superclassSealable = !goog.defineClass.isUnsealable_(superClass);
            /**
             * @this {Object}
             * @return {?}
             */
            var wrappedCtr = function () {
                // Don't seal an instance of a subclass when it calls the constructor of
                // its super class as there is most likely still setup to do.
                var instance = ctr.apply(this, arguments) || this;
                instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];
                if (this.constructor === wrappedCtr && superclassSealable &&
                    Object.seal instanceof Function) {
                    Object.seal(instance);
                }
                return instance;
            };
            return wrappedCtr;
        }
        defineClass.createSealingConstructor_ = createSealingConstructor_;
        ;
        /**
         * @param {Function} ctr The constructor to test.
         * @return {boolean} Whether the constructor has been tagged as unsealable
         *     using goog.tagUnsealableClass.
         * @private
         */
        function isUnsealable_(ctr) {
            return ctr && ctr.prototype &&
                ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];
        }
        defineClass.isUnsealable_ = isUnsealable_;
        ;
        // TODO(johnlenz): share these values with the goog.object
        /**
         * The names of the fields that are defined on Object.prototype.
         * @type {!Array<string>}
         * @private
         * @const
         */
        defineClass.OBJECT_PROTOTYPE_FIELDS_ = [
            'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
            'toLocaleString', 'toString', 'valueOf'
        ];
        // TODO(johnlenz): share this function with the goog.object
        /**
         * @param {!Object} target The object to add properties to.
         * @param {!Object} source The object to copy properties from.
         * @private
         */
        function applyProperties_(target, source) {
            // TODO(johnlenz): update this to support ES5 getters/setters
            var key;
            for (key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
            // For IE the for-in-loop does not contain any properties that are not
            // enumerable on the prototype object (for example isPrototypeOf from
            // Object.prototype) and it will also not include 'replace' on objects that
            // extend String and change 'replace' (not that it is common for anyone to
            // extend anything except Object).
            for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {
                key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        defineClass.applyProperties_ = applyProperties_;
        ;
    })(defineClass = goog.defineClass || (goog.defineClass = {}));
    /**
     * Sealing classes breaks the older idiom of assigning properties on the
     * prototype rather than in the constructor. As such, goog.defineClass
     * must not seal subclasses of these old-style classes until they are fixed.
     * Until then, this marks a class as "broken", instructing defineClass
     * not to seal subclasses.
     * @param {!Function} ctr The legacy constructor to tag as unsealable.
     */
    function tagUnsealableClass(ctr) {
        if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) {
            ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;
        }
    }
    goog.tagUnsealableClass = tagUnsealableClass;
    ;
    /**
     * Name for unsealable tag property.
     * @const @private {string}
     */
    goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = 'goog_defineClass_legacy_unsealable';
})(goog || (goog = {}));
/**
 * Forward declare type information. Used to assign types to goog.global
 * referenced object that would otherwise result in unknown type references
 * and thus block property disambiguation.
 */
goog.forwardDeclare('Document');
goog.forwardDeclare('HTMLScriptElement');
goog.forwardDeclare('XMLHttpRequest');
// if (!COMPILED) {
(function (goog) {
    /**
     * Check if the given name has been goog.provided. This will return false for
     * names that are available only as implicit namespaces.
     * @param {string} name name of the object to look for.
     * @return {boolean} Whether the name has been provided.
     * @private
     */
    function isProvided_(name) {
        return (name in goog.loadedModules_) ||
            (!goog.implicitNamespaces_[name] &&
                goog.isDefAndNotNull(goog.getObjectByName(name)));
    }
    goog.isProvided_ = isProvided_;
    /**
     * Namespaces implicitly defined by goog.provide. For example,
     * goog.provide('goog.events.Event') implicitly declares that 'goog' and
     * 'goog.events' must be namespaces.
     *
     * @type {!Object<string, (boolean|undefined)>}
     * @private
     */
    goog.implicitNamespaces_ = { 'goog.module': true };
})(goog || (goog = {}));
// NOTE: We add goog.module as an implicit namespace as goog.module is defined
// here and because the existing module package has not been moved yet out of
// the goog.module namespace. This satisifies both the debug loader and
// ahead-of-time dependency management.
// }
// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
//
// User-defined namespaces may need their own deps file. For a reference on
// creating a deps file, see:
// Externally: https://developers.google.com/closure/library/docs/depswriter
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work was done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.
/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.define('goog.ENABLE_DEBUG_LOADER', true);
/**
 * @define {boolean} Whether to load goog.modules using {@code eval} when using
 * the debug loader.  This provides a better debugging experience as the
 * source is unmodified and can be edited using Chrome Workspaces or similar.
 * However in some environments the use of {@code eval} is banned
 * so we provide an alternative.
 */
goog.define('goog.LOAD_MODULE_USING_EVAL', true);
/**
 * @define {boolean} Whether the exports of goog.modules should be sealed when
 * possible.
 */
goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);
/**
 * @define {string} How to decide whether to transpile.  Valid values
 * are 'always', 'never', and 'detect'.  The default ('detect') is to
 * use feature detection to determine which language levels need
 * transpilation.
 */
// NOTE(user): we could expand this to accept a language level to bypass
// detection: e.g. goog.TRANSPILE == 'es5' would transpile ES6 files but
// would leave ES3 and ES5 files alone.
goog.define('goog.TRANSPILE', 'detect');
/**
 * @define {string} Path to the transpiler.  Executing the script at this
 * path (relative to base.js) should define a function $jscomp.transpile.
 */
goog.define('goog.TRANSPILER', 'transpile.js');
/**
 * @define {string} Debug loader file to load. This file should define an
 * implementation of a `goog.DebugLoader` and register it via
 * `goog.registerDebugLoader`.
 */
goog.define('goog.DEBUG_LOADER', '');
(function (goog) {
    goog.ENABLE_DEBUG_LOADER = true;
    goog.LOAD_MODULE_USING_EVAL = true;
    goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
    goog.TRANSPILE = 'detect';
    goog.TRANSPILER = 'transpile.js';
    goog.DEBUG_LOADER = '';
})(goog || (goog = {}));
if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
    // This does not call goog.setCssNameMapping() because the JSCompiler
    // requires that goog.setCssNameMapping() be called with an object literal.
    goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}
/*
 * To support uncompiled, strict mode bundles that use eval to divide source
 * like so:
 *    eval('someSource;//# sourceUrl sourcefile.js');
 * We need to export the globally defined symbols "goog" and "COMPILED".
 * Exporting "goog" breaks the compiler optimizations, so we required that
 * be defined externally.
 * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
 * extern generation when that compiler option is enabled.
 */
if (!COMPILED) {
    goog.global['COMPILED'] = COMPILED;
}
/**
 * @typedef {{
 *   constructor: (!Function|undefined),
 *   statics: (Object|undefined|function(Function):void)
 * }}
 */
goog.defineClass.ClassDescriptor;
/**
 * @define {boolean} Whether the instances returned by goog.defineClass should
 *     be sealed when possible.
 *
 * When sealing is disabled the constructor function will not be wrapped by
 * goog.defineClass, making it incompatible with ES6 class methods.
 */
goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);
// if(goog.DEPENDENCIES_ENABLED){
(function (goog) {
    /**
     * Tries to detect whether is in the context of an HTML document.
     * @return {boolean} True if it looks like HTML document.
     * @private
     */
    function inHtmlDocument_() {
        /** @type {!Document} */
        var doc = goog.global.document;
        return doc != null && 'write' in doc; // XULDocument misses write.
    }
    goog.inHtmlDocument_ = inHtmlDocument_;
    ;
    /**
 * Tries to detect the base path of base.js script that bootstraps Closure.
 * @private
 */
    function findBasePath_() {
        if (goog.isDef(goog.global.CLOSURE_BASE_PATH) &&
            // Anti DOM-clobbering runtime check (b/37736576).
            goog.isString(goog.global.CLOSURE_BASE_PATH)) {
            goog.basePath = goog.global.CLOSURE_BASE_PATH;
            return;
        }
        else if (!goog.inHtmlDocument_()) {
            return;
        }
        /** @type {!Document} */
        var doc = goog.global.document;
        // If we have a currentScript available, use it exclusively.
        var currentScript = doc.currentScript;
        if (currentScript) {
            var scripts = [currentScript];
        }
        else {
            var scripts = doc.getElementsByTagName('SCRIPT');
        }
        // Search backwards since the current script is in almost all cases the one
        // that has base.js.
        for (var i = scripts.length - 1; i >= 0; --i) {
            var script = (scripts[i]);
            var src = script.src;
            var qmark = src.lastIndexOf('?');
            var l = qmark == -1 ? src.length : qmark;
            if (src.substr(l - 7, 7) == 'base.js') {
                goog.basePath = src.substr(0, l - 7);
                return;
            }
        }
    }
    goog.findBasePath_ = findBasePath_;
    ;
    goog.findBasePath_();
    var Transpiler = /** @class */ (function () {
        /** @struct @constructor @final */
        function Transpiler() {
            /** @private {?Object<string, boolean>} */
            this.requiresTranspilation_ = null;
        }
        /**
       * Returns a newly created map from language mode string to a boolean
       * indicating whether transpilation should be done for that mode.
       *
       * Guaranteed invariant:
       * For any two modes, l1 and l2 where l2 is a newer mode than l1,
       * `map[l1] == true` implies that `map[l2] == true`.
       *
       * Note this method is extracted and used elsewhere, so it cannot rely on
       * anything external (it should easily be able to be transformed into a
       * standalone, top level function).
       *
       * @private
       * @return {!Object<string, boolean>}
       */
        Transpiler.prototype.createRequiresTranspilation_ = function () {
            var /** !Object<string, boolean> */ requiresTranspilation = { 'es3': false };
            var transpilationRequiredForAllLaterModes = false;
            /**
             * Adds an entry to requiresTranspliation for the given language mode.
             *
             * IMPORTANT: Calls must be made in order from oldest to newest language
             * mode.
             * @param {string} modeName
             * @param {function(): boolean} isSupported Returns true if the JS engine
             *     supports the given mode.
             */
            function addNewerLanguageTranspilationCheck(modeName, isSupported) {
                if (transpilationRequiredForAllLaterModes) {
                    requiresTranspilation[modeName] = true;
                }
                else if (isSupported()) {
                    requiresTranspilation[modeName] = false;
                }
                else {
                    requiresTranspilation[modeName] = true;
                    transpilationRequiredForAllLaterModes = true;
                }
            }
            /**
             * Does the given code evaluate without syntax errors and return a truthy
             * result?
             */
            function evalCheck(/** string */ code) {
                try {
                    return !!eval(code);
                }
                catch (ignored) {
                    return false;
                }
            }
            var userAgent = goog.global.navigator && goog.global.navigator.userAgent ?
                goog.global.navigator.userAgent :
                '';
            // Identify ES3-only browsers by their incorrect treatment of commas.
            addNewerLanguageTranspilationCheck('es5', function () {
                return evalCheck('[1,].length==1');
            });
            addNewerLanguageTranspilationCheck('es6', function () {
                // Edge has a non-deterministic (i.e., not reproducible) bug with ES6:
                // https://github.com/Microsoft/ChakraCore/issues/1496.
                var re = /Edge\/(\d+)(\.\d)*/i;
                var edgeUserAgent = userAgent.match(re);
                if (edgeUserAgent && Number(edgeUserAgent[1]) < 15) {
                    return false;
                }
                // Test es6: [FF50 (?), Edge 14 (?), Chrome 50]
                //   (a) default params (specifically shadowing locals),
                //   (b) destructuring, (c) block-scoped functions,
                //   (d) for-of (const), (e) new.target/Reflect.construct
                var es6fullTest = 'class X{constructor(){if(new.target!=String)throw 1;this.x=42}}' +
                    'let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof ' +
                    'String))throw 1;for(const a of[2,3]){if(a==2)continue;function ' +
                    'f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()' +
                    '==3}';
                return evalCheck('(()=>{"use strict";' + es6fullTest + '})()');
            });
            // TODO(joeltine): Remove es6-impl references for b/31340605.
            // Consider es6-impl (widely-implemented es6 features) to be supported
            // whenever es6 is supported. Technically es6-impl is a lower level of
            // support than es6, but we don't have tests specifically for it.
            addNewerLanguageTranspilationCheck('es6-impl', function () {
                return true;
            });
            // ** and **= are the only new features in 'es7'
            addNewerLanguageTranspilationCheck('es7', function () {
                return evalCheck('2 ** 2 == 4');
            });
            // async functions are the only new features in 'es8'
            addNewerLanguageTranspilationCheck('es8', function () {
                return evalCheck('async () => 1, true');
            });
            return requiresTranspilation;
        };
        /**
           * Determines whether the given language needs to be transpiled.
           * @param {string} lang
           * @return {boolean}
           */
        Transpiler.prototype.needsTranspile = function (lang) {
            if (goog.TRANSPILE == 'always') {
                return true;
            }
            else if (goog.TRANSPILE == 'never') {
                return false;
            }
            else if (!this.requiresTranspilation_) {
                this.requiresTranspilation_ = this.createRequiresTranspilation_();
            }
            if (lang in this.requiresTranspilation_) {
                return this.requiresTranspilation_[lang];
            }
            else {
                throw new Error('Unknown language mode: ' + lang);
            }
        };
        ;
        /**
         * Lazily retrieves the transpiler and applies it to the source.
         * @param {string} code JS code.
         * @param {string} path Path to the code.
         * @return {string} The transpiled code.
         */
        Transpiler.prototype.transpile = function (code, path) {
            // TODO(user): We should delete goog.transpile_ and just have this
            // function. But there's some compile error atm where goog.global is being
            // stripped incorrectly without this.
            return goog.transpile_(code, path);
        };
        ;
        return Transpiler;
    }());
    goog.Transpiler = Transpiler;
    var DebugLoader = /** @class */ (function () {
        /**
           * A debug loader is responsible for downloading and executing javascript
           * files in an unbundled, uncompiled environment.
           *
           * @struct @constructor
           */
        function DebugLoader() {
            /**
             * This object is used to keep track of dependencies and other data that is
             * used for loading scripts.
             * @private
             * @type {{
             *   loadFlags: !Object<string, !Object<string, string>>,
             *   nameToPath: !Object<string, string>,
             *   requires: !Object<string, !Object<string, boolean>>,
             *   visited: !Object<string, boolean>,
             *   written: !Object<string, boolean>,
             *   deferred: !Object<string, string>
             * }}
             */
            this.dependencies_ = {
                loadFlags: {},
                nameToPath: {},
                requires: {},
                // Used when resolving dependencies to prevent us from visiting file
                // twice.
                visited: {},
                written: {},
                deferred: {} // Used to track deferred module evaluations in old IEs
            };
            /**
             * Whether IE9 or earlier is waiting on a dependency.  This ensures that
             * deferred modules that have no non-deferred dependencies actually get
             * loaded, since if we defer them and then never pull in a non-deferred
             * script, then `this.loadQueuedModules_` will never be called.  Instead,
             * if not waiting on anything we simply don't defer in the first place.
             * @private {boolean}
             */
            this.oldIeWaiting_ = false;
            /** @private {!Array<string>} */
            this.queuedModules_ = [];
            /** @private {number} */
            this.lastNonModuleScriptIndex_ = 0;
        }
        /**
           * Performs any needed preprocessing of a goog.require call.
           *
           * @param {string} name
           */
        DebugLoader.prototype.earlyProcessLoad = function (name) {
            if (goog.DebugLoader.IS_OLD_IE_) {
                this.maybeProcessDeferredDep_(name);
            }
        };
        ;
        /**
         * Loads the given symbol along with any dependencies.
         *
         * @param {string} name
         */
        DebugLoader.prototype.load = function (name) {
            var pathToLoad = this.getPathFromDeps_(name);
            if (!pathToLoad) {
                var errorMessage = 'goog.require could not find: ' + name;
                this.logToConsole(errorMessage);
                throw Error(errorMessage);
            }
            else {
                /** @type {!Array<string>} The scripts we need to write this time. */
                var scripts = [];
                var seenScript = {};
                var deps = this.dependencies_;
                var loader = this;
                /** @param {string} path */
                var visitNode = function (path) {
                    if (path in deps.written) {
                        return;
                    }
                    // We have already visited this one. We can get here if we have cyclic
                    // dependencies.
                    if (path in deps.visited) {
                        return;
                    }
                    deps.visited[path] = true;
                    if (path in deps.requires) {
                        for (var requireName in deps.requires[path]) {
                            // If the required name is defined, we assume that it was already
                            // bootstrapped by other means.
                            if (!loader.isProvided(requireName)) {
                                if (requireName in deps.nameToPath) {
                                    visitNode(deps.nameToPath[requireName]);
                                }
                                else {
                                    throw Error('Undefined nameToPath for ' + requireName);
                                }
                            }
                        }
                    }
                    if (!(path in seenScript)) {
                        seenScript[path] = true;
                        scripts.push(path);
                    }
                };
                visitNode(pathToLoad);
                // record that we are going to load all these scripts.
                for (var i = 0; i < scripts.length; i++) {
                    var path = scripts[i];
                    this.dependencies_.written[path] = true;
                }
                for (var i = 0; i < scripts.length; i++) {
                    var path = scripts[i];
                    if (path) {
                        var loadFlags = deps.loadFlags[path] || {};
                        var languageLevel = loadFlags['lang'] || 'es3';
                        var needsTranspile = this.getTranspiler().needsTranspile(languageLevel);
                        if (loadFlags['module'] == 'goog' || needsTranspile) {
                            this.importProcessedScript_(goog.basePath + path, loadFlags['module'] == 'goog', needsTranspile);
                        }
                        else {
                            this.importScript_(goog.basePath + path);
                        }
                    }
                    else {
                        throw Error('Undefined script input');
                    }
                }
            }
        };
        ;
        /**
         * @param {string} relPath
         * @param {!Array<string>} provides
         * @param {!Array<string>} requires
         * @param {boolean|!Object<string>=} opt_loadFlags
         * @see goog.addDependency
         */
        DebugLoader.prototype.addDependency = function (relPath, provides, requires, opt_loadFlags) {
            var provide, require;
            var path = relPath.replace(/\\/g, '/');
            var deps = this.dependencies_;
            if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {
                opt_loadFlags = opt_loadFlags ? { 'module': 'goog' } : {};
            }
            for (var i = 0; provide = provides[i]; i++) {
                deps.nameToPath[provide] = path;
                deps.loadFlags[path] = opt_loadFlags;
            }
            for (var j = 0; require = requires[j]; j++) {
                if (!(path in deps.requires)) {
                    deps.requires[path] = {};
                }
                deps.requires[path][require] = true;
            }
        };
        ;
        /**
         * Imports a script if, and only if, that script hasn't already been imported.
         * (Must be called at execution time)
         * @param {string} src Script source.
         * @param {string=} opt_sourceText The optionally source text to evaluate
         * @private
         */
        DebugLoader.prototype.importScript_ = function (src, opt_sourceText) {
            var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
                goog.bind(this.writeScriptTag_, this);
            if (importScript(src, opt_sourceText)) {
                this.dependencies_.written[src] = true;
            }
        };
        ;
        /**
         * Given a URL initiate retrieval and execution of a script that needs
         * pre-processing.
         * @param {string} src Script source URL.
         * @param {boolean} isModule Whether this is a goog.module.
         * @param {boolean} needsTranspile Whether this source needs transpilation.
         * @private
         */
        DebugLoader.prototype.importProcessedScript_ = function (src, isModule, needsTranspile) {
            // In an attempt to keep browsers from timing out loading scripts using
            // synchronous XHRs, put each load in its own script block.
            var bootstrap = 'goog.debugLoader_.retrieveAndExec_("' + src + '", ' +
                isModule + ', ' + needsTranspile + ');';
            this.importScript_('', bootstrap);
        };
        ;
        /**
         * Retrieve and execute a script that needs some sort of wrapping.
         * @param {string} src Script source URL.
         * @param {boolean} isModule Whether to load as a module.
         * @param {boolean} needsTranspile Whether to transpile down to ES3.
         * @private
         * @suppress {unusedPrivateMembers}
         */
        DebugLoader.prototype.retrieveAndExec_ = function (src, isModule, needsTranspile) {
            if (!COMPILED) {
                // The full but non-canonicalized URL for later use.
                var originalPath = src;
                // Canonicalize the path, removing any /./ or /../ since Chrome's
                // debugging console doesn't auto-canonicalize XHR loads as it does
                // <script> srcs.
                src = this.normalizePath(src);
                var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
                    goog.bind(this.writeScriptTag_, this);
                var scriptText = this.loadFileSync(src);
                if (scriptText == null) {
                    throw new Error('Load of "' + src + '" failed');
                }
                if (needsTranspile) {
                    scriptText = this.getTranspiler().transpile(scriptText, src);
                }
                if (isModule) {
                    scriptText = this.wrapModule_(src, scriptText);
                }
                else {
                    scriptText += '\n//# sourceURL=' + src;
                }
                var isOldIE = goog.DebugLoader.IS_OLD_IE_;
                if (isOldIE && this.oldIeWaiting_) {
                    this.dependencies_.deferred[originalPath] = scriptText;
                    this.queuedModules_.push(originalPath);
                }
                else {
                    importScript(src, scriptText);
                }
            }
        };
        ;
        /**
         * Return an appropriate module text. Suitable to insert into
         * a script tag (that is unescaped).
         * @param {string} srcUrl
         * @param {string} scriptText
         * @return {string}
         * @private
         */
        DebugLoader.prototype.wrapModule_ = function (srcUrl, scriptText) {
            if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {
                return '' +
                    'goog.loadModule(function(exports) {' +
                    '"use strict";' + scriptText +
                    '\n' + // terminate any trailing single line comment.
                    ';return exports' +
                    '});' +
                    '\n//# sourceURL=' + srcUrl + '\n';
            }
            else {
                return '' +
                    'goog.loadModule(' +
                    goog.global.JSON.stringify(scriptText + '\n//# sourceURL=' + srcUrl + '\n') +
                    ');';
            }
        };
        ;
        // On IE9 and earlier, it is necessary to handle
        // deferred module loads. In later browsers, the
        // code to be evaluated is simply inserted as a script
        // block in the correct order. To eval deferred
        // code at the right time, we piggy back on goog.require to call
        // this.maybeProcessDeferredDep_.
        //
        // The goog.requires are used both to bootstrap
        // the loading process (when no deps are available) and
        // declare that they should be available.
        //
        // Here we eval the sources, if all the deps are available
        // either already eval'd or goog.require'd.  This will
        // be the case when all the dependencies have already
        // been loaded, and the dependent module is loaded.
        //
        // But this alone isn't sufficient because it is also
        // necessary to handle the case where there is no root
        // that is not deferred.  For that there we register for an event
        // and trigger this.loadQueuedModules_ handle any remaining deferred
        // evaluations.
        /**
         * Handle any remaining deferred goog.module evals.
         * @private
         */
        DebugLoader.prototype.loadQueuedModules_ = function () {
            var count = this.queuedModules_.length;
            if (count > 0) {
                var queue = this.queuedModules_;
                this.queuedModules_ = [];
                for (var i = 0; i < count; i++) {
                    var path = queue[i];
                    this.maybeProcessDeferredPath_(path);
                }
            }
            this.oldIeWaiting_ = false;
        };
        ;
        /**
         * Eval the named module if its dependencies are
         * available.
         * @param {string} name The module to load.
         * @private
         */
        DebugLoader.prototype.maybeProcessDeferredDep_ = function (name) {
            if (this.isDeferredModule_(name) && this.allDepsAreAvailable_(name)) {
                var path = this.getPathFromDeps_(name);
                this.maybeProcessDeferredPath_(goog.basePath + path);
            }
        };
        ;
        /**
         * @param {string} name The module to check.
         * @return {boolean} Whether the name represents a
         *     module whose evaluation has been deferred.
         * @private
         */
        DebugLoader.prototype.isDeferredModule_ = function (name) {
            var path = this.getPathFromDeps_(name);
            var loadFlags = path && this.dependencies_.loadFlags[path] || {};
            var languageLevel = loadFlags['lang'] || 'es3';
            if (path &&
                (loadFlags['module'] == 'goog' ||
                    this.getTranspiler().needsTranspile(languageLevel))) {
                var abspath = goog.basePath + path;
                return (abspath) in this.dependencies_.deferred;
            }
            return false;
        };
        ;
        /**
         * @param {string} name The module to check.
         * @return {boolean} Whether the name represents a
         *     module whose declared dependencies have all been loaded
         *     (eval'd or a deferred module load)
         * @private
         */
        DebugLoader.prototype.allDepsAreAvailable_ = function (name) {
            var path = this.getPathFromDeps_(name);
            if (path && (path in this.dependencies_.requires)) {
                for (var requireName in this.dependencies_.requires[path]) {
                    if (!this.isProvided(requireName) &&
                        !this.isDeferredModule_(requireName)) {
                        return false;
                    }
                }
            }
            return true;
        };
        ;
        /**
         * @param {string} abspath
         * @private
         */
        DebugLoader.prototype.maybeProcessDeferredPath_ = function (abspath) {
            if (abspath in this.dependencies_.deferred) {
                var src = this.dependencies_.deferred[abspath];
                delete this.dependencies_.deferred[abspath];
                goog.globalEval(src);
            }
        };
        ;
        /**
         * Writes a new script pointing to {@code src} directly into the DOM.
         *
         * NOTE: This method is not CSP-compliant. @see this.appendScriptSrcNode_ for
         * the fallback mechanism.
         *
         * @param {string} src The script URL.
         * @private
         */
        DebugLoader.prototype.writeScriptSrcNode_ = function (src) {
            goog.global.document.write('<script type="text/javascript" src="' + src + '"></' +
                'script>');
        };
        ;
        /**
         * Appends a new script node to the DOM using a CSP-compliant mechanism. This
         * method exists as a fallback for document.write (which is not allowed in a
         * strict CSP context, e.g., Chrome apps).
         *
         * NOTE: This method is not analogous to using document.write to insert a
         * <script> tag; specifically, the user agent will execute a script added by
         * document.write immediately after the current script block finishes
         * executing, whereas the DOM-appended script node will not be executed until
         * the entire document is parsed and executed. That is to say, this script is
         * added to the end of the script execution queue.
         *
         * The page must not attempt to call goog.required entities until after the
         * document has loaded, e.g., in or after the window.onload callback.
         *
         * @param {string} src The script URL.
         * @private
         */
        DebugLoader.prototype.appendScriptSrcNode_ = function (src) {
            /** @type {!Document} */
            var doc = goog.global.document;
            var scriptEl = 
            /** @type {!HTMLScriptElement} */ (doc.createElement('script'));
            scriptEl.type = 'text/javascript';
            scriptEl.src = src;
            scriptEl.defer = false;
            scriptEl.async = false;
            doc.head.appendChild(scriptEl);
        };
        ;
        /**
         * The default implementation of the import function. Writes a script tag to
         * import the script.
         *
         * @param {string} src The script url.
         * @param {string=} opt_sourceText The optionally source text to evaluate
         * @return {boolean} True if the script was imported, false otherwise.
         * @private
         */
        DebugLoader.prototype.writeScriptTag_ = function (src, opt_sourceText) {
            if (this.inHtmlDocument()) {
                /** @type {!HTMLDocument} */
                var doc = goog.global.document;
                // If the user tries to require a new symbol after document load,
                // something has gone terribly wrong. Doing a document.write would
                // wipe out the page. This does not apply to the CSP-compliant method
                // of writing script tags.
                if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&
                    doc.readyState == 'complete') {
                    // Certain test frameworks load base.js multiple times, which tries
                    // to write deps.js each time. If that happens, just fail silently.
                    // These frameworks wipe the page between each load of base.js, so this
                    // is OK.
                    var isDeps = /\bdeps.js$/.test(src);
                    if (isDeps) {
                        return false;
                    }
                    else {
                        throw Error('Cannot write "' + src + '" after document load');
                    }
                }
                if (opt_sourceText === undefined) {
                    if (!goog.DebugLoader.IS_OLD_IE_) {
                        if (goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
                            this.appendScriptSrcNode_(src);
                        }
                        else {
                            this.writeScriptSrcNode_(src);
                        }
                    }
                    else {
                        this.oldIeWaiting_ = true;
                        var state = ' onreadystatechange=\'goog.debugLoader_' +
                            '.onScriptLoad_(this, ' + ++this.lastNonModuleScriptIndex_ +
                            ')\' ';
                        doc.write('<script type="text/javascript" src="' + src + '"' + state +
                            '></' +
                            'script>');
                    }
                }
                else {
                    doc.write('<script type="text/javascript">' +
                        this.protectScriptTag_(opt_sourceText) + '</' +
                        'script>');
                }
                return true;
            }
            else {
                return false;
            }
        };
        ;
        /**
         * Rewrites closing script tags in input to avoid ending an enclosing script
         * tag.
         *
         * @param {string} str
         * @return {string}
         * @private
         */
        DebugLoader.prototype.protectScriptTag_ = function (str) {
            return str.replace(/<\/(SCRIPT)/ig, '\\x3c/$1');
        };
        ;
        /**
         * A readystatechange handler for legacy IE
         * @param {?} script
         * @param {number} scriptIndex
         * @return {boolean}
         * @private
         * @suppress {unusedPrivateMembers}
         */
        DebugLoader.prototype.onScriptLoad_ = function (script, scriptIndex) {
            // for now load the modules when we reach the last script,
            // later allow more inter-mingling.
            if (script.readyState == 'complete' &&
                this.lastNonModuleScriptIndex_ == scriptIndex) {
                this.loadQueuedModules_();
            }
            return true;
        };
        ;
        /**
         * Looks at the dependency rules and tries to determine the script file that
         * fulfills a particular rule.
         * @param {string} rule In the form goog.namespace.Class or project.script.
         * @return {?string} Url corresponding to the rule, or null.
         * @private
         */
        DebugLoader.prototype.getPathFromDeps_ = function (rule) {
            if (rule in this.dependencies_.nameToPath) {
                return this.dependencies_.nameToPath[rule];
            }
            else {
                return null;
            }
        };
        ;
        /**
         * @return {!goog.Transpiler}
         * @protected @final
         */
        DebugLoader.prototype.getTranspiler = function () {
            return goog.transpiler_;
        };
        ;
        /**
         * @param {string} namespaceOrPath
         * @return {boolean}
         * @protected @final
         */
        DebugLoader.prototype.isProvided = function (namespaceOrPath) {
            return goog.isProvided_(namespaceOrPath);
        };
        ;
        /**
         * @return {boolean}
         * @protected @final
         */
        DebugLoader.prototype.inHtmlDocument = function () {
            return goog.inHtmlDocument_();
        };
        ;
        /**
         * @param {string} message
         * @protected @final
         */
        DebugLoader.prototype.logToConsole = function (message) {
            goog.logToConsole_(message);
        };
        ;
        /**
         * @param {string} srcUrl
         * @return {?string}
         * @protected @final
         */
        DebugLoader.prototype.loadFileSync = function (srcUrl) {
            return goog.loadFileSync_(srcUrl);
        };
        ;
        /**
         * @param {string} path
         * @return {string}
         * @protected @final
         */
        DebugLoader.prototype.normalizePath = function (path) {
            return goog.normalizePath_(path);
        };
        ;
        DebugLoader.IS_OLD_IE_ = !!(!goog.global.atob && goog.global.document && goog.global.document.all);
        return DebugLoader;
    }());
    goog.DebugLoader = DebugLoader;
    /** @private {?goog.DebugLoader} */
    goog.debugLoader_ = null;
    /** @param {!goog.DebugLoader} loader */
    function registerDebugLoader(loader) {
        if (goog.debugLoader_) {
            throw new Error('Debug loader already registered!');
        }
        if (!(loader instanceof goog.DebugLoader)) {
            throw new Error('Not a goog.DebugLoader.');
        }
        goog.debugLoader_ = loader;
    }
    goog.registerDebugLoader = registerDebugLoader;
    function getLoader_() {
        if (!goog.debugLoader_ && goog.DEBUG_LOADER) {
            // Tried to load earlier but failed.
            throw new Error('Loaded debug loader file but no loader was registered!');
        }
        else if (!goog.debugLoader_) {
            // No custom loader and no closure deps. Was not made earlier; make it
            // now.
            goog.debugLoader_ = new goog.DebugLoader();
        }
        return goog.debugLoader_;
    }
    goog.getLoader_ = getLoader_;
})(goog || (goog = {}));
/** @private @final {!goog.Transpiler} */
goog.transpiler_ = new goog.Transpiler();
(function () {
    var tempLoader;
    if (goog.DEBUG_LOADER) {
        tempLoader = new goog.DebugLoader();
        tempLoader.importScript_(goog.basePath + goog.DEBUG_LOADER);
    }
    // Allow projects to manage the deps files themselves.
    if (!goog.global.CLOSURE_NO_DEPS) {
        tempLoader = tempLoader || new goog.DebugLoader();
        if (!goog.DEBUG_LOADER) {
            // Can reuse the same debug loader in the rest of the application.
            goog.registerDebugLoader(tempLoader);
        }
        tempLoader.importScript_(goog.basePath + 'deps.js');
    }
})();
// }
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Provides a base class for custom Error objects such that the
 * stack is correctly maintained.
 *
 * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
 * sufficient.
 *
 */
goog.provide('goog.debug.Error');
var goog;
(function (goog) {
    var debug;
    (function (debug) {
        var Error = /** @class */ (function () {
            /**
           * Base class for custom error objects.
           * @param {*=} opt_msg The message associated with the error.
           * @constructor
           * @extends {Error}
           */
            function Error(opt_msg) {
                // Attempt to ensure there is a stack trace.
                if (goog.global.Error.captureStackTrace) {
                    goog.global.Error.captureStackTrace(this, goog.debug.Error);
                }
                else {
                    var stack = new goog.global.Error().stack;
                    if (stack) {
                        /** @override */
                        this.stack = stack;
                    }
                }
                if (opt_msg) {
                    /** @override */
                    this.message = String(opt_msg);
                }
                /**
                 * Whether to report this error to the server. Setting this to false will
                 * cause the error reporter to not report the error back to the server,
                 * which can be useful if the client knows that the error has already been
                 * logged on the server.
                 * @type {boolean}
                 */
                this.reportErrorToServer = true;
                this.name = 'CustomError';
            }
            return Error;
        }());
        debug.Error = Error;
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Definition of goog.dom.NodeType.
 */
goog.provide('goog.dom.NodeType');
var goog;
(function (goog) {
    var dom;
    (function (dom) {
        /**
         * Constants for the nodeType attribute in the Node interface.
         *
         * These constants match those specified in the Node interface. These are
         * usually present on the Node object in recent browsers, but not in older
         * browsers (specifically, early IEs) and thus are given here.
         *
         * In some browsers (early IEs), these are not defined on the Node object,
         * so they are provided here.
         *
         * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
         * @enum {number}
         */
        var NodeType;
        (function (NodeType) {
            NodeType[NodeType["ELEMENT"] = 1] = "ELEMENT";
            NodeType[NodeType["ATTRIBUTE"] = 2] = "ATTRIBUTE";
            NodeType[NodeType["TEXT"] = 3] = "TEXT";
            NodeType[NodeType["CDATA_SECTION"] = 4] = "CDATA_SECTION";
            NodeType[NodeType["ENTITY_REFERENCE"] = 5] = "ENTITY_REFERENCE";
            NodeType[NodeType["ENTITY"] = 6] = "ENTITY";
            NodeType[NodeType["PROCESSING_INSTRUCTION"] = 7] = "PROCESSING_INSTRUCTION";
            NodeType[NodeType["COMMENT"] = 8] = "COMMENT";
            NodeType[NodeType["DOCUMENT"] = 9] = "DOCUMENT";
            NodeType[NodeType["DOCUMENT_TYPE"] = 10] = "DOCUMENT_TYPE";
            NodeType[NodeType["DOCUMENT_FRAGMENT"] = 11] = "DOCUMENT_FRAGMENT";
            NodeType[NodeType["NOTATION"] = 12] = "NOTATION";
        })(NodeType = dom.NodeType || (dom.NodeType = {}));
    })(dom = goog.dom || (goog.dom = {}));
})(goog || (goog = {}));
/// <reference path="../base.ts" />
/// <reference path="../debug/error.ts" />
/// <reference path="../dom/nodetype.ts" />
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utilities to check the preconditions, postconditions and
 * invariants runtime.
 *
 * Methods in this package should be given special treatment by the compiler
 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
 * will restrict <code>foo</code> to a truthy value.
 *
 * The compiler has an option to disable asserts. So code like:
 * <code>
 * var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
 * </code>
 * will be transformed into:
 * <code>
 * var x = foo();
 * </code>
 * The compiler will leave in foo() (because its return value is used),
 * but it will remove bar() because it assumes it does not have side-effects.
 *
 * @author agrieve@google.com (Andrew Grieve)
 */
goog.provide('goog.asserts');
goog.provide('goog.asserts.AssertionError');
goog.require('goog.debug.Error');
goog.require('goog.dom.NodeType');
/**
 * @define {boolean} Whether to strip out asserts or to leave them in.
 */
goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);
var goog;
(function (goog) {
    var asserts;
    (function (asserts) {
    })(asserts = goog.asserts || (goog.asserts = {}));
})(goog || (goog = {}));
(function (goog) {
    var asserts;
    (function (asserts) {
        var AssertionError = /** @class */ (function (_super) {
            __extends(AssertionError, _super);
            /**
             * Error object for failed assertions.
             * @param {string} messagePattern The pattern that was used to form message.
             * @param {!Array<*>} messageArgs The items to substitute into the pattern.
             * @constructor
             * @extends {goog.debug.Error}
             * @final
             */
            function AssertionError(messagePattern, messageArgs) {
                var _this = _super.call(this) || this;
                goog.debug.Error.call(_this, goog.asserts.subs_(messagePattern, messageArgs));
                /**
                 * The message pattern used to format the error message. Error handlers can
                 * use this to uniquely identify the assertion.
                 * @type {string}
                 */
                _this.messagePattern = messagePattern;
                /**
                 * @override
                 */
                _this.name = 'AssertionError';
                return _this;
            }
            /**
             * The default error handler.
             * @param {!goog.asserts.AssertionError} e The exception to be handled.
             */
            AssertionError.DEFAULT_ERROR_HANDLER = function (e) {
                throw e;
            };
            return AssertionError;
        }(goog.debug.Error));
        asserts.AssertionError = AssertionError;
        /**
         * The default error handler.
         * @param {!goog.asserts.AssertionError} e The exception to be handled.
         */
        function DEFAULT_ERROR_HANDLER(e) {
            throw e;
        }
        asserts.DEFAULT_ERROR_HANDLER = DEFAULT_ERROR_HANDLER;
        /**
         * The handler responsible for throwing or logging assertion errors.
         * @private {function(!goog.asserts.AssertionError)}
         */
        function errorHandler_(e) {
            return goog.asserts.DEFAULT_ERROR_HANDLER(e);
        }
        asserts.errorHandler_ = errorHandler_;
        /**
         * Does simple python-style string substitution.
         * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
         * @param {string} pattern The string containing the pattern.
         * @param {!Array<*>} subs The items to substitute into the pattern.
         * @return {string} A copy of {@code str} in which each occurrence of
         *     {@code %s} has been replaced an argument from {@code var_args}.
         * @private
         */
        function subs_(pattern, subs) {
            var splitParts = pattern.split('%s');
            var returnString = '';
            // Replace up to the last split part. We are inserting in the
            // positions between split parts.
            var subLast = splitParts.length - 1;
            for (var i = 0; i < subLast; i++) {
                // keep unsupplied as '%s'
                var sub = (i < subs.length) ? subs[i] : '%s';
                returnString += splitParts[i] + sub;
            }
            return returnString + splitParts[subLast];
        }
        asserts.subs_ = subs_;
        ;
        /**
         * Throws an exception with the given message and "Assertion failed" prefixed
         * onto it.
         * @param {string} defaultMessage The message to use if givenMessage is empty.
         * @param {Array<*>} defaultArgs The substitution arguments for defaultMessage.
         * @param {string|undefined} givenMessage Message supplied by the caller.
         * @param {Array<*>} givenArgs The substitution arguments for givenMessage.
         * @throws {goog.asserts.AssertionError} When the value is not a number.
         * @private
         */
        function doAssertFailure_(defaultMessage, defaultArgs, givenMessage, givenArgs) {
            var message = 'Assertion failed';
            if (givenMessage) {
                message += ': ' + givenMessage;
                var args = givenArgs;
            }
            else if (defaultMessage) {
                message += ': ' + defaultMessage;
                args = defaultArgs;
            }
            // The '' + works around an Opera 10 bug in the unit tests. Without it,
            // a stack trace is added to var message above. With this, a stack trace is
            // not added until this line (it causes the extra garbage to be added after
            // the assertion message instead of in the middle of it).
            var e = new goog.asserts.AssertionError('' + message, args || []);
            goog.asserts.errorHandler_(e);
        }
        asserts.doAssertFailure_ = doAssertFailure_;
        ;
        /**
         * Sets a custom error handler that can be used to customize the behavior of
         * assertion failures, for example by turning all assertion failures into log
         * messages.
         * @param {function(!goog.asserts.AssertionError)} errorHandler
         */
        function setErrorHandler(errorHandler) {
            if (goog.asserts.ENABLE_ASSERTS) {
                goog.asserts.errorHandler_ = errorHandler;
            }
        }
        asserts.setErrorHandler = setErrorHandler;
        ;
        /**
         * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
         * true.
         * @template T
         * @param {T} condition The condition to check.
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @return {T} The value of the condition.
         * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
         */
        function assert(condition, opt_message) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS && !condition) {
                goog.asserts.doAssertFailure_('', null, opt_message, Array.prototype.slice.call(arguments, 2));
            }
            return condition;
        }
        asserts.assert = assert;
        ;
        /**
         * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
         * when we want to add a check in the unreachable area like switch-case
         * statement:
         *
         * <pre>
         *  switch(type) {
         *    case FOO: doSomething(); break;
         *    case BAR: doSomethingElse(); break;
         *    default: goog.asserts.fail('Unrecognized type: ' + type);
         *      // We have only 2 types - "default:" section is unreachable code.
         *  }
         * </pre>
         *
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @throws {goog.asserts.AssertionError} Failure.
         */
        function fail(opt_message) {
            var var_args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                var_args[_i - 1] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS) {
                goog.asserts.errorHandler_(new goog.asserts.AssertionError('Failure' + (opt_message ? ': ' + opt_message : ''), Array.prototype.slice.call(arguments, 1)));
            }
        }
        asserts.fail = fail;
        ;
        /**
         * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
         * @param {*} value The value to check.
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @return {number} The value, guaranteed to be a number when asserts enabled.
         * @throws {goog.asserts.AssertionError} When the value is not a number.
         */
        function assertNumber(value, opt_message) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
                goog.asserts.doAssertFailure_('Expected number but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
            }
            return /** @type {number} */ (value);
        }
        asserts.assertNumber = assertNumber;
        ;
        /**
         * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
         * @param {*} value The value to check.
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @return {string} The value, guaranteed to be a string when asserts enabled.
         * @throws {goog.asserts.AssertionError} When the value is not a string.
         */
        function assertString(value, opt_message) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
                goog.asserts.doAssertFailure_('Expected string but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
            }
            return /** @type {string} */ (value);
        }
        asserts.assertString = assertString;
        ;
        /**
         * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
         * @param {*} value The value to check.
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @return {!Function} The value, guaranteed to be a function when asserts
         *     enabled.
         * @throws {goog.asserts.AssertionError} When the value is not a function.
         */
        function assertFunction(value, opt_message) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
                goog.asserts.doAssertFailure_('Expected function but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
            }
            return /** @type {!Function} */ (value);
        }
        asserts.assertFunction = assertFunction;
        ;
        /**
         * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
         * @param {*} value The value to check.
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @return {!Object} The value, guaranteed to be a non-null object.
         * @throws {goog.asserts.AssertionError} When the value is not an object.
         */
        function assertObject(value, opt_message) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
                goog.asserts.doAssertFailure_('Expected object but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
            }
            return /** @type {!Object} */ (value);
        }
        asserts.assertObject = assertObject;
        ;
        /**
         * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
         * @param {*} value The value to check.
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @return {!Array<?>} The value, guaranteed to be a non-null array.
         * @throws {goog.asserts.AssertionError} When the value is not an array.
         */
        function assertArray(value, opt_message) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
                goog.asserts.doAssertFailure_('Expected array but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
            }
            return /** @type {!Array<?>} */ (value);
        }
        asserts.assertArray = assertArray;
        ;
        /**
         * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
         * @param {*} value The value to check.
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @return {boolean} The value, guaranteed to be a boolean when asserts are
         *     enabled.
         * @throws {goog.asserts.AssertionError} When the value is not a boolean.
         */
        function assertBoolean(value, opt_message) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
                goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
            }
            return /** @type {boolean} */ (value);
        }
        asserts.assertBoolean = assertBoolean;
        ;
        /**
         * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
         * @param {*} value The value to check.
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @return {!Element} The value, likely to be a DOM Element when asserts are
         *     enabled.
         * @throws {goog.asserts.AssertionError} When the value is not an Element.
         */
        function assertElement(value, opt_message) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS &&
                (!goog.isObject(value) || value.nodeType != goog.dom.NodeType.ELEMENT)) {
                goog.asserts.doAssertFailure_('Expected Element but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
            }
            return /** @type {!Element} */ (value);
        }
        asserts.assertElement = assertElement;
        ;
        /**
         * Checks if the value is an instance of the user-defined type if
         * goog.asserts.ENABLE_ASSERTS is true.
         *
         * The compiler may tighten the type returned by this function.
         *
         * @param {?} value The value to check.
         * @param {function(new: T, ...)} type A user-defined constructor.
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @throws {goog.asserts.AssertionError} When the value is not an instance of
         *     type.
         * @return {T}
         * @template T
         */
        function assertInstanceof(value, type, opt_message) {
            var var_args = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                var_args[_i - 3] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
                goog.asserts.doAssertFailure_('Expected instanceof %s but got %s.', [goog.asserts.getType_(type), goog.asserts.getType_(value)], opt_message, Array.prototype.slice.call(arguments, 3));
            }
            return value;
        }
        asserts.assertInstanceof = assertInstanceof;
        ;
        /**
         * Checks whether the value is a finite number, if goog.asserts.ENABLE_ASSERTS
         * is true.
         *
         * @param {*} value The value to check.
         * @param {string=} opt_message Error message in case of failure.
         * @param {...*} var_args The items to substitute into the failure message.
         * @throws {goog.asserts.AssertionError} When the value is not a number, or is
         *     a non-finite number such as NaN, Infinity or -Infinity.
         * @return {number} The value initially passed in.
         */
        function assertFinite(value, opt_message) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            if (goog.asserts.ENABLE_ASSERTS &&
                (typeof value != 'number' || !isFinite(value))) {
                goog.asserts.doAssertFailure_('Expected %s to be a finite number but it is not.', [value], opt_message, Array.prototype.slice.call(arguments, 2));
            }
            return /** @type {number} */ (value);
        }
        asserts.assertFinite = assertFinite;
        ;
        /**
         * Checks that no enumerable keys are present in Object.prototype. Such keys
         * would break most code that use {@code for (var ... in ...)} loops.
         */
        function assertObjectPrototypeIsIntact() {
            for (var key in Object.prototype) {
                goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
            }
        }
        asserts.assertObjectPrototypeIsIntact = assertObjectPrototypeIsIntact;
        ;
        /**
         * Returns the type of a value. If a constructor is passed, and a suitable
         * string cannot be found, 'unknown type name' will be returned.
         * @param {*} value A constructor, object, or primitive.
         * @return {string} The best display name for the value, or 'unknown type name'.
         * @private
         */
        function getType_(value) {
            if (value instanceof Function) {
                return value.displayName || value.name || 'unknown type name';
            }
            else if (value instanceof Object) {
                return value.constructor.displayName || value.constructor.name ||
                    Object.prototype.toString.call(value);
            }
            else {
                return value === null ? 'null' : typeof value;
            }
        }
        asserts.getType_ = getType_;
        ;
    })(asserts = goog.asserts || (goog.asserts = {}));
})(goog || (goog = {}));
/// <reference path="../specialtype.ts" />
/// <reference path="../base.ts" />
/// <reference path="../asserts/asserts.ts" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utilities for manipulating arrays.
 *
 * @author arv@google.com (Erik Arvidsson)
 */
goog.provide('goog.array');
goog.require('goog.asserts');
/**
 * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
 * rely on Array.prototype functions, if available.
 *
 * The Array.prototype functions can be defined by external libraries like
 * Prototype and setting this flag to false forces closure to use its own
 * goog.array implementation.
 *
 * If your javascript can be loaded by a third party site and you are wary about
 * relying on the prototype functions, specify
 * "--define goog.NATIVE_ARRAY_PROTOTYPES=false" to the JSCompiler.
 *
 * Setting goog.TRUSTED_SITE to false will automatically set
 * NATIVE_ARRAY_PROTOTYPES to false.
 */
goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);
/**
 * @define {boolean} If true, JSCompiler will use the native implementation of
 * array functions where appropriate (e.g., {@code Array#filter}) and remove the
 * unused pure JS implementation.
 */
goog.define('goog.array.ASSUME_NATIVE_FUNCTIONS', false);
var goog;
(function (goog) {
})(goog || (goog = {}));
(function (goog) {
    var array;
    (function (array_1) {
        /**
         * Returns the last element in an array without removing it.
         * Same as goog.array.last.
         * @param {IArrayLike<T>|string} array The array.
         * @return {T} Last item in array.
         * @template T
         */
        function peek(array) {
            return array[array.length - 1];
        }
        array_1.peek = peek;
        ;
        /**
         * Returns the last element in an array without removing it.
         * Same as goog.array.peek.
         * @param {IArrayLike<T>|string} array The array.
         * @return {T} Last item in array.
         * @template T
         */
        function last(array) {
            return goog.array.peek(array);
        }
        array_1.last = last;
        // NOTE(arv): Since most of the array functions are generic it allows you to
        // pass an array-like object. Strings have a length and are considered array-
        // like. However, the 'in' operator does not work on strings so we cannot just
        // use the array path even if the browser supports indexing into strings. We
        // therefore end up splitting the string.
        /**
         * Returns the index of the first element of an array with a specified value,
         * or -1 if the element is not present in the array.
         *
         * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
         *
         * @param {IArrayLike<T>|string} arr The array to be searched.
         * @param {T} obj The object for which we are searching.
         * @param {number=} opt_fromIndex The index at which to start the search. If
         *     omitted the search starts at index 0.
         * @return {number} The index of the first matching array element.
         * @template T
         */
        function indexOf(arr, obj, opt_fromIndex) {
            var bo = goog.NATIVE_ARRAY_PROTOTYPES &&
                (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf);
            if (bo) {
                goog.asserts.assert(arr.length != null);
                return Array.prototype.indexOf.call(arr, obj, opt_fromIndex);
            }
            else {
                var fromIndex = opt_fromIndex == null ?
                    0 :
                    (opt_fromIndex < 0 ? Math.max(0, arr.length + opt_fromIndex) :
                        opt_fromIndex);
                if (goog.isString(arr)) {
                    // Array.prototype.indexOf uses === so only strings should be found.
                    if (!goog.isString(obj) || obj.length != 1) {
                        return -1;
                    }
                    else if (typeof obj == 'string') {
                        return arr.indexOf(obj, fromIndex);
                    }
                }
                for (var i = fromIndex; i < arr.length; i++) {
                    if (i in arr && arr[i] === obj)
                        return i;
                }
                return -1;
            }
        }
        array_1.indexOf = indexOf;
        /**
         * Returns the index of the last element of an array with a specified value,
         * or -1 if the element is not present in the array.
         *
         * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}
         *
         * @param {!IArrayLike<T>|string} arr The array to be searched.
         * @param {T} obj The object for which we are searching.
         * @param {?number=} opt_fromIndex The index at which to start the search. If
         *     omitted the search starts at the end of the array.
         * @return {number} The index of the last matching array element.
         * @template T
         */
        function lastIndexOf(arr, obj, opt_fromIndex) {
            var bo = goog.NATIVE_ARRAY_PROTOTYPES &&
                (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf);
            if (bo) {
                goog.asserts.assert(arr.length != null);
                // Firefox treats undefined and null as 0 in the fromIndex argument which
                // leads it to always return -1
                var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
                return Array.prototype.lastIndexOf.call(arr, obj, fromIndex);
            }
            else {
                var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
                if (fromIndex < 0) {
                    fromIndex = Math.max(0, arr.length + fromIndex);
                }
                if (goog.isString(arr)) {
                    // Array.prototype.lastIndexOf uses === so only strings should be found.
                    if (!goog.isString(obj) || obj.length != 1) {
                        return -1;
                    }
                    else if (typeof obj == 'string') {
                        return arr.lastIndexOf(obj, fromIndex);
                    }
                }
                for (var i = fromIndex; i >= 0; i--) {
                    if (i in arr && arr[i] === obj)
                        return i;
                }
                return -1;
            }
        }
        array_1.lastIndexOf = lastIndexOf;
        /**
         * Calls a function for each element in an array. Skips holes in the array.
         * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
         *
         * @param {IArrayLike<T>|string} arr Array or array like object over
         *     which to iterate.
         * @param {?function(this: S, T, number, ?): ?} f The function to call for every
         *     element. This function takes 3 arguments (the element, the index and
         * the array). The return value is ignored.
         * @param {S=} opt_obj The object to be used as the value of 'this' within f.
         * @template T,S
         */
        function forEach(arr, f, opt_obj) {
            var bo = goog.NATIVE_ARRAY_PROTOTYPES &&
                (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach);
            if (bo) {
                goog.asserts.assert(arr.length != null);
                Array.prototype.forEach.call(arr, f, opt_obj);
            }
            else {
                var l = arr.length; // must be fixed during loop... see docs
                var arr2 = goog.isString(arr) ? arr.split('') : arr;
                for (var i = 0; i < l; i++) {
                    if (i in arr2) {
                        f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);
                    }
                }
            }
        }
        array_1.forEach = forEach;
        /**
         * Calls a function for each element in an array, starting from the last
         * element rather than the first.
         *
         * @param {IArrayLike<T>|string} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this: S, T, number, ?): ?} f The function to call for every
         *     element. This function
         *     takes 3 arguments (the element, the index and the array). The return
         *     value is ignored.
         * @param {S=} opt_obj The object to be used as the value of 'this'
         *     within f.
         * @template T,S
         */
        function forEachRight(arr, f, opt_obj) {
            var l = arr.length; // must be fixed during loop... see docs
            var arr2 = goog.isString(arr) ? arr.split('') : arr;
            for (var i = l - 1; i >= 0; --i) {
                if (i in arr2) {
                    f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);
                }
            }
        }
        array_1.forEachRight = forEachRight;
        ;
        /**
         * Calls a function for each element in an array, and if the function returns
         * true adds the element to a new array.
         *
         * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
         *
         * @param {IArrayLike<T>|string} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this:S, T, number, ?):boolean} f The function to call for
         *     every element. This function
         *     takes 3 arguments (the element, the index and the array) and must
         *     return a Boolean. If the return value is true the element is added to
         * the result array. If it is false the element is not included.
         * @param {S=} opt_obj The object to be used as the value of 'this'
         *     within f.
         * @return {!Array<T>} a new array in which only elements that passed the test
         *     are present.
         * @template T,S
         */
        function filter(arr, f, opt_obj) {
            var bo = goog.NATIVE_ARRAY_PROTOTYPES &&
                (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter);
            if (bo) {
                goog.asserts.assert(arr.length != null);
                return Array.prototype.filter.call(arr, f, opt_obj);
            }
            else {
                var l = arr.length; // must be fixed during loop... see docs
                var res = [];
                var resLength = 0;
                var arr2 = goog.isString(arr) ? arr.split('') : arr;
                for (var i = 0; i < l; i++) {
                    if (i in arr2) {
                        var val = arr2[i]; // in case f mutates arr2
                        if (f.call(/** @type {?} */ (opt_obj), val, i, arr)) {
                            res[resLength++] = val;
                        }
                    }
                }
                return res;
            }
        }
        array_1.filter = filter;
        ;
        /**
         * Calls a function for each element in an array and inserts the result into a
         * new array.
         *
         * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
         *
         * @param {IArrayLike<VALUE>|string} arr Array or array like object
         *     over which to iterate.
         * @param {function(this:THIS, VALUE, number, ?): RESULT} f The function to call
         *     for every element. This function takes 3 arguments (the element,
         *     the index and the array) and should return something. The result will
         * be inserted into a new array.
         * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.
         * @return {!Array<RESULT>} a new array with the results from f.
         * @template THIS, VALUE, RESULT
         */
        function map(arr, f, opt_obj) {
            var bo = goog.NATIVE_ARRAY_PROTOTYPES &&
                (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map);
            if (bo) {
                goog.asserts.assert(arr.length != null);
                return Array.prototype.map.call(arr, f, opt_obj);
            }
            else {
                var l = arr.length; // must be fixed during loop... see docs
                var res = new Array(l);
                var arr2 = goog.isString(arr) ? arr.split('') : arr;
                for (var i = 0; i < l; i++) {
                    if (i in arr2) {
                        res[i] = f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);
                    }
                }
                return res;
            }
        }
        array_1.map = map;
        ;
        /**
         * Passes every element of an array into a function and accumulates the
         * result.
         *
         * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}
         *
         * For example:
         * var a = [1, 2, 3, 4];
         * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);
         * returns 10
         *
         * @param {IArrayLike<T>|string} arr Array or array
         *     like object over which to iterate.
         * @param {function(this:S, R, T, number, ?) : R} f The function to call for
         *     every element. This function
         *     takes 4 arguments (the function's previous result or the initial value,
         *     the value of the current array element, the current array index, and
         * the array itself) function(previousValue, currentValue, index, array).
         * @param {?} val The initial value to pass into the function on the first call.
         * @param {S=} opt_obj  The object to be used as the value of 'this'
         *     within f.
         * @return {R} Result of evaluating f repeatedly across the values of the array.
         * @template T,S,R
         */
        function reduce(arr, f, val, opt_obj) {
            var bo = goog.NATIVE_ARRAY_PROTOTYPES &&
                (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce);
            if (bo) {
                goog.asserts.assert(arr.length != null);
                if (opt_obj) {
                    f = goog.bind(f, opt_obj);
                }
                return Array.prototype.reduce.call(arr, f, val);
            }
            else {
                var rval = val;
                goog.array.forEach(arr, function (val, index) {
                    rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);
                });
                return rval;
            }
        }
        array_1.reduce = reduce;
        ;
        /**
         * Passes every element of an array into a function and accumulates the
         * result, starting from the last element and working towards the first.
         *
         * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}
         *
         * For example:
         * var a = ['a', 'b', 'c'];
         * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, '');
         * returns 'cba'
         *
         * @param {IArrayLike<T>|string} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
         *     every element. This function
         *     takes 4 arguments (the function's previous result or the initial value,
         *     the value of the current array element, the current array index, and
         * the array itself) function(previousValue, currentValue, index, array).
         * @param {?} val The initial value to pass into the function on the first call.
         * @param {S=} opt_obj The object to be used as the value of 'this'
         *     within f.
         * @return {R} Object returned as a result of evaluating f repeatedly across the
         *     values of the array.
         * @template T,S,R
         */
        function reduceRight(arr, f, val, opt_obj) {
            var bo = goog.NATIVE_ARRAY_PROTOTYPES &&
                (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight);
            if (bo) {
                goog.asserts.assert(arr.length != null);
                goog.asserts.assert(f != null);
                if (opt_obj) {
                    f = goog.bind(f, opt_obj);
                }
                return Array.prototype.reduceRight.call(arr, f, val);
            }
            else {
                var rval = val;
                goog.array.forEachRight(arr, function (val, index) {
                    rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);
                });
                return rval;
            }
        }
        array_1.reduceRight = reduceRight;
        ;
        /**
         * Calls f for each element of an array. If any call returns true, some()
         * returns true (without checking the remaining elements). If all calls
         * return false, some() returns false.
         *
         * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
         *
         * @param {IArrayLike<T>|string} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
         *     for every element. This function takes 3 arguments (the element, the
         *     index and the array) and should return a boolean.
         * @param {S=} opt_obj  The object to be used as the value of 'this'
         *     within f.
         * @return {boolean} true if any element passes the test.
         * @template T,S
         */
        function some(arr, f, opt_obj) {
            var bo = goog.NATIVE_ARRAY_PROTOTYPES &&
                (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some);
            if (bo) {
                goog.asserts.assert(arr.length != null);
                return Array.prototype.some.call(arr, f, opt_obj);
            }
            else {
                var l = arr.length; // must be fixed during loop... see docs
                var arr2 = goog.isString(arr) ? arr.split('') : arr;
                for (var i = 0; i < l; i++) {
                    if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
                        return true;
                    }
                }
                return false;
            }
        }
        array_1.some = some;
        /**
         * Call f for each element of an array. If all calls return true, every()
         * returns true. If any call returns false, every() returns false and
         * does not continue to check the remaining elements.
         *
         * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
         *
         * @param {IArrayLike<T>|string} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
         *     for every element. This function takes 3 arguments (the element, the
         *     index and the array) and should return a boolean.
         * @param {S=} opt_obj The object to be used as the value of 'this'
         *     within f.
         * @return {boolean} false if any element fails the test.
         * @template T,S
         */
        function every(arr, f, opt_obj) {
            var bo = goog.NATIVE_ARRAY_PROTOTYPES &&
                (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every);
            if (bo) {
                goog.asserts.assert(arr.length != null);
                return Array.prototype.every.call(arr, f, opt_obj);
            }
            else {
                var l = arr.length; // must be fixed during loop... see docs
                var arr2 = goog.isString(arr) ? arr.split('') : arr;
                for (var i = 0; i < l; i++) {
                    if (i in arr2 && !f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
                        return false;
                    }
                }
                return true;
            }
        }
        array_1.every = every;
        /**
         * Counts the array elements that fulfill the predicate, i.e. for which the
         * callback function returns true. Skips holes in the array.
         *
         * @param {!IArrayLike<T>|string} arr Array or array like object
         *     over which to iterate.
         * @param {function(this: S, T, number, ?): boolean} f The function to call for
         *     every element. Takes 3 arguments (the element, the index and the
         * array).
         * @param {S=} opt_obj The object to be used as the value of 'this' within f.
         * @return {number} The number of the matching elements.
         * @template T,S
         */
        function count(arr, f, opt_obj) {
            var count = 0;
            goog.array.forEach(arr, function (element, index, arr) {
                if (f.call(/** @type {?} */ (opt_obj), element, index, arr)) {
                    ++count;
                }
            }, opt_obj);
            return count;
        }
        array_1.count = count;
        ;
        /**
         * Search an array for the first element that satisfies a given condition and
         * return that element.
         * @param {IArrayLike<T>|string} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this:S, T, number, ?) : boolean} f The function to call
         *     for every element. This function takes 3 arguments (the element, the
         *     index and the array) and should return a boolean.
         * @param {S=} opt_obj An optional "this" context for the function.
         * @return {T|null} The first array element that passes the test, or null if no
         *     element is found.
         * @template T,S
         */
        function find(arr, f, opt_obj) {
            var i = goog.array.findIndex(arr, f, opt_obj);
            return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
        }
        array_1.find = find;
        ;
        /**
         * Search an array for the first element that satisfies a given condition and
         * return its index.
         * @param {IArrayLike<T>|string} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
         *     every element. This function
         *     takes 3 arguments (the element, the index and the array) and should
         *     return a boolean.
         * @param {S=} opt_obj An optional "this" context for the function.
         * @return {number} The index of the first array element that passes the test,
         *     or -1 if no element is found.
         * @template T,S
         */
        function findIndex(arr, f, opt_obj) {
            var l = arr.length; // must be fixed during loop... see docs
            var arr2 = goog.isString(arr) ? arr.split('') : arr;
            for (var i = 0; i < l; i++) {
                if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
                    return i;
                }
            }
            return -1;
        }
        array_1.findIndex = findIndex;
        ;
        /**
         * Search an array (in reverse order) for the last element that satisfies a
         * given condition and return that element.
         * @param {IArrayLike<T>|string} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this:S, T, number, ?) : boolean} f The function to call
         *     for every element. This function
         *     takes 3 arguments (the element, the index and the array) and should
         *     return a boolean.
         * @param {S=} opt_obj An optional "this" context for the function.
         * @return {T|null} The last array element that passes the test, or null if no
         *     element is found.
         * @template T,S
         */
        function findRight(arr, f, opt_obj) {
            var i = goog.array.findIndexRight(arr, f, opt_obj);
            return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
        }
        array_1.findRight = findRight;
        ;
        /**
         * Search an array (in reverse order) for the last element that satisfies a
         * given condition and return its index.
         * @param {IArrayLike<T>|string} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this:S, T, number, ?) : boolean} f The function to call
         *     for every element. This function
         *     takes 3 arguments (the element, the index and the array) and should
         *     return a boolean.
         * @param {S=} opt_obj An optional "this" context for the function.
         * @return {number} The index of the last array element that passes the test,
         *     or -1 if no element is found.
         * @template T,S
         */
        function findIndexRight(arr, f, opt_obj) {
            var l = arr.length; // must be fixed during loop... see docs
            var arr2 = goog.isString(arr) ? arr.split('') : arr;
            for (var i = l - 1; i >= 0; i--) {
                if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
                    return i;
                }
            }
            return -1;
        }
        array_1.findIndexRight = findIndexRight;
        ;
        /**
         * Whether the array contains the given object.
         * @param {IArrayLike<?>|string} arr The array to test for the presence of the
         *     element.
         * @param {*} obj The object for which to test.
         * @return {boolean} true if obj is present.
         */
        function contains(arr, obj) {
            return goog.array.indexOf(arr, obj) >= 0;
        }
        array_1.contains = contains;
        ;
        /**
         * Whether the array is empty.
         * @param {IArrayLike<?>|string} arr The array to test.
         * @return {boolean} true if empty.
         */
        function isEmpty(arr) {
            return arr.length == 0;
        }
        array_1.isEmpty = isEmpty;
        ;
        /**
         * Clears the array.
         * @param {IArrayLike<?>} arr Array or array like object to clear.
         */
        function clear(arr) {
            // For non real arrays we don't have the magic length so we delete the
            // indices.
            if (!goog.isArray(arr)) {
                for (var i = arr.length - 1; i >= 0; i--) {
                    delete arr[i];
                }
            }
            arr.length = 0;
        }
        array_1.clear = clear;
        ;
        /**
         * Pushes an item into an array, if it's not already in the array.
         * @param {Array<T>} arr Array into which to insert the item.
         * @param {T} obj Value to add.
         * @template T
         */
        function insert(arr, obj) {
            if (!goog.array.contains(arr, obj)) {
                arr.push(obj);
            }
        }
        array_1.insert = insert;
        ;
        /**
         * Inserts an object at the given index of the array.
         * @param {IArrayLike<?>} arr The array to modify.
         * @param {*} obj The object to insert.
         * @param {number=} opt_i The index at which to insert the object. If omitted,
         *      treated as 0. A negative index is counted from the end of the array.
         */
        function insertAt(arr, obj, opt_i) {
            goog.array.splice(arr, opt_i, 0, obj);
        }
        array_1.insertAt = insertAt;
        ;
        /**
         * Inserts at the given index of the array, all elements of another array.
         * @param {IArrayLike<?>} arr The array to modify.
         * @param {IArrayLike<?>} elementsToAdd The array of elements to add.
         * @param {number=} opt_i The index at which to insert the object. If omitted,
         *      treated as 0. A negative index is counted from the end of the array.
         */
        function insertArrayAt(arr, elementsToAdd, opt_i) {
            goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);
        }
        array_1.insertArrayAt = insertArrayAt;
        ;
        /**
         * Inserts an object into an array before a specified object.
         * @param {Array<T>} arr The array to modify.
         * @param {T} obj The object to insert.
         * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2
         *     is omitted or not found, obj is inserted at the end of the array.
         * @template T
         */
        function insertBefore(arr, obj, opt_obj2) {
            var i;
            if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) {
                arr.push(obj);
            }
            else {
                goog.array.insertAt(arr, obj, i);
            }
        }
        array_1.insertBefore = insertBefore;
        ;
        /**
         * Removes the first occurrence of a particular value from an array.
         * @param {IArrayLike<T>} arr Array from which to remove
         *     value.
         * @param {T} obj Object to remove.
         * @return {boolean} True if an element was removed.
         * @template T
         */
        function remove(arr, obj) {
            var i = goog.array.indexOf(arr, obj);
            var rv;
            if ((rv = i >= 0)) {
                goog.array.removeAt(arr, i);
            }
            return rv;
        }
        array_1.remove = remove;
        ;
        /**
         * Removes the last occurrence of a particular value from an array.
         * @param {!IArrayLike<T>} arr Array from which to remove value.
         * @param {T} obj Object to remove.
         * @return {boolean} True if an element was removed.
         * @template T
         */
        function removeLast(arr, obj) {
            var i = goog.array.lastIndexOf(arr, obj);
            if (i >= 0) {
                goog.array.removeAt(arr, i);
                return true;
            }
            return false;
        }
        array_1.removeLast = removeLast;
        ;
        /**
         * Removes from an array the element at index i
         * @param {IArrayLike<?>} arr Array or array like object from which to
         *     remove value.
         * @param {number} i The index to remove.
         * @return {boolean} True if an element was removed.
         */
        function removeAt(arr, i) {
            goog.asserts.assert(arr.length != null);
            // use generic form of splice
            // splice returns the removed items and if successful the length of that
            // will be 1
            return Array.prototype.splice.call(arr, i, 1).length == 1;
        }
        array_1.removeAt = removeAt;
        ;
        /**
         * Removes the first value that satisfies the given condition.
         * @param {IArrayLike<T>} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this:S, T, number, ?) : boolean} f The function to call
         *     for every element. This function
         *     takes 3 arguments (the element, the index and the array) and should
         *     return a boolean.
         * @param {S=} opt_obj An optional "this" context for the function.
         * @return {boolean} True if an element was removed.
         * @template T,S
         */
        function removeIf(arr, f, opt_obj) {
            var i = goog.array.findIndex(arr, f, opt_obj);
            if (i >= 0) {
                goog.array.removeAt(arr, i);
                return true;
            }
            return false;
        }
        array_1.removeIf = removeIf;
        ;
        /**
         * Removes all values that satisfy the given condition.
         * @param {IArrayLike<T>} arr Array or array
         *     like object over which to iterate.
         * @param {?function(this:S, T, number, ?) : boolean} f The function to call
         *     for every element. This function
         *     takes 3 arguments (the element, the index and the array) and should
         *     return a boolean.
         * @param {S=} opt_obj An optional "this" context for the function.
         * @return {number} The number of items removed
         * @template T,S
         */
        function removeAllIf(arr, f, opt_obj) {
            var removedCount = 0;
            goog.array.forEachRight(arr, function (val, index) {
                if (f.call(/** @type {?} */ (opt_obj), val, index, arr)) {
                    if (goog.array.removeAt(arr, index)) {
                        removedCount++;
                    }
                }
            });
            return removedCount;
        }
        array_1.removeAllIf = removeAllIf;
        ;
        /**
         * Returns a new array that is the result of joining the arguments.  If arrays
         * are passed then their items are added, however, if non-arrays are passed
         * they will be added to the return array as is.
         *
         * Note that ArrayLike objects will be added as is, rather than having their
         * items added.
         *
         * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
         * goog.array.concat(0, [1, 2]) -> [0, 1, 2]
         * goog.array.concat([1, 2], null) -> [1, 2, null]
         *
         * There is bug in all current versions of IE (6, 7 and 8) where arrays
         * created in an iframe become corrupted soon (not immediately) after the
         * iframe is destroyed. This is common if loading data via goog.net.IframeIo,
         * for example. This corruption only affects the concat method which will
         * start throwing Catastrophic Errors (#-2147418113).
         *
         * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.
         *
         * Internally goog.array should use this, so that all methods will continue to
         * work on these broken array objects.
         *
         * @param {...*} var_args Items to concatenate.  Arrays will have each item
         *     added, while primitives and objects will be added as is.
         * @return {!Array<?>} The new resultant array.
         */
        function concat() {
            var var_args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                var_args[_i] = arguments[_i];
            }
            return Array.prototype.concat.apply([], arguments);
        }
        array_1.concat = concat;
        ;
        /**
         * Returns a new array that contains the contents of all the arrays passed.
         * @param {...!Array<T>} var_args
         * @return {!Array<T>}
         * @template T
         */
        function join() {
            var var_args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                var_args[_i] = arguments[_i];
            }
            return Array.prototype.concat.apply([], arguments);
        }
        array_1.join = join;
        ;
        /**
         * Converts an object to an array.
         * @param {IArrayLike<T>|string} object  The object to convert to an
         *     array.
         * @return {!Array<T>} The object converted into an array. If object has a
         *     length property, every property indexed with a non-negative number
         *     less than length will be included in the result. If object does not
         *     have a length property, an empty array will be returned.
         * @template T
         */
        function toArray(object) {
            var length = object.length;
            // If length is not a number the following it false. This case is kept for
            // backwards compatibility since there are callers that pass objects that
            // are not array like.
            if (length > 0) {
                var rv = new Array(length);
                for (var i = 0; i < length; i++) {
                    rv[i] = object[i];
                }
                return rv;
            }
            return [];
        }
        array_1.toArray = toArray;
        ;
        /**
         * Does a shallow copy of an array.
         * @param {IArrayLike<T>|string} arr  Array or array-like object to
         *     clone.
         * @return {!Array<T>} Clone of the input array.
         * @template T
         */
        function clone(arr) {
            return goog.array.toArray(arr);
        }
        array_1.clone = clone;
        /**
         * Extends an array with another array, element, or "array like" object.
         * This function operates 'in-place', it does not create a new Array.
         *
         * Example:
         * var a = [];
         * goog.array.extend(a, [0, 1]);
         * a; // [0, 1]
         * goog.array.extend(a, 2);
         * a; // [0, 1, 2]
         *
         * @param {Array<VALUE>} arr1  The array to modify.
         * @param {...(IArrayLike<VALUE>|VALUE)} var_args The elements or arrays of
         *     elements to add to arr1.
         * @template VALUE
         */
        function extend(arr1) {
            var var_args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                var_args[_i - 1] = arguments[_i];
            }
            for (var i = 1; i < arguments.length; i++) {
                var arr2 = arguments[i];
                if (goog.isArrayLike(arr2)) {
                    var len1 = arr1.length || 0;
                    var len2 = arr2.length || 0;
                    arr1.length = len1 + len2;
                    for (var j = 0; j < len2; j++) {
                        arr1[len1 + j] = arr2[j];
                    }
                }
                else {
                    arr1.push(arr2);
                }
            }
        }
        array_1.extend = extend;
        ;
        /**
         * Adds or removes elements from an array. This is a generic version of Array
         * splice. This means that it might work on other objects similar to arrays,
         * such as the arguments object.
         *
         * @param {IArrayLike<T>} arr The array to modify.
         * @param {number|undefined} index The index at which to start changing the
         *     array. If not defined, treated as 0.
         * @param {number} howMany How many elements to remove (0 means no removal. A
         *     value below 0 is treated as zero and so is any other non number.
         * Numbers are floored).
         * @param {...T} var_args Optional, additional elements to insert into the
         *     array.
         * @return {!Array<T>} the removed elements.
         * @template T
         */
        function splice(arr, index, howMany) {
            var var_args = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                var_args[_i - 3] = arguments[_i];
            }
            goog.asserts.assert(arr.length != null);
            return Array.prototype.splice.apply(arr, goog.array.slice(arguments, 1));
        }
        array_1.splice = splice;
        ;
        /**
         * Returns a new array from a segment of an array. This is a generic version
         * of Array slice. This means that it might work on other objects similar to
         * arrays, such as the arguments object.
         *
         * @param {IArrayLike<T>|string} arr The array from
         * which to copy a segment.
         * @param {number} start The index of the first element to copy.
         * @param {number=} opt_end The index after the last element to copy.
         * @return {!Array<T>} A new array containing the specified segment of the
         *     original array.
         * @template T
         */
        function slice(arr, start, opt_end) {
            goog.asserts.assert(arr.length != null);
            // passing 1 arg to slice is not the same as passing 2 where the second is
            // null or undefined (in that case the second argument is treated as 0).
            // we could use slice on the arguments object and then use apply instead of
            // testing the length
            if (arguments.length <= 2) {
                return Array.prototype.slice.call(arr, start);
            }
            else {
                return Array.prototype.slice.call(arr, start, opt_end);
            }
        }
        array_1.slice = slice;
        ;
        /**
         * Removes all duplicates from an array (retaining only the first
         * occurrence of each array element).  This function modifies the
         * array in place and doesn't change the order of the non-duplicate items.
         *
         * For objects, duplicates are identified as having the same unique ID as
         * defined by {@link goog.getUid}.
         *
         * Alternatively you can specify a custom hash function that returns a unique
         * value for each item in the array it should consider unique.
         *
         * Runtime: N,
         * Worstcase space: 2N (no dupes)
         *
         * @param {IArrayLike<T>} arr The array from which to remove
         *     duplicates.
         * @param {Array=} opt_rv An optional array in which to return the results,
         *     instead of performing the removal inplace.  If specified, the original
         *     array will remain unchanged.
         * @param {function(T):string=} opt_hashFn An optional function to use to
         *     apply to every item in the array. This function should return a unique
         *     value for each item in the array it should consider unique.
         * @template T
         */
        function removeDuplicates(arr, opt_rv, opt_hashFn) {
            var returnArray = opt_rv || arr;
            var defaultHashFn = function (item) {
                // Prefix each type with a single character representing the type to
                // prevent conflicting keys (e.g. true and 'true').
                return goog.isObject(item) ? 'o' + goog.getUid(item) :
                    (typeof item).charAt(0) + item;
            };
            var hashFn = opt_hashFn || defaultHashFn;
            var seen = {}, cursorInsert = 0, cursorRead = 0;
            while (cursorRead < arr.length) {
                var current = arr[cursorRead++];
                var key = hashFn(current);
                if (!Object.prototype.hasOwnProperty.call(seen, key)) {
                    seen[key] = true;
                    returnArray[cursorInsert++] = current;
                }
            }
            returnArray.length = cursorInsert;
        }
        array_1.removeDuplicates = removeDuplicates;
        ;
        /**
         * Searches the specified array for the specified target using the binary
         * search algorithm.  If no opt_compareFn is specified, elements are compared
         * using <code>goog.array.defaultCompare</code>, which compares the elements
         * using the built in < and > operators.  This will produce the expected
         * behavior for homogeneous arrays of String(s) and Number(s). The array
         * specified <b>must</b> be sorted in ascending order (as defined by the
         * comparison function).  If the array is not sorted, results are undefined.
         * If the array contains multiple instances of the specified target value, any
         * of these instances may be found.
         *
         * Runtime: O(log n)
         *
         * @param {IArrayLike<VALUE>} arr The array to be searched.
         * @param {TARGET} target The sought value.
         * @param {function(TARGET, VALUE): number=} opt_compareFn Optional comparison
         *     function by which the array is ordered. Should take 2 arguments to
         *     compare, and return a negative number, zero, or a positive number
         *     depending on whether the first argument is less than, equal to, or
         *     greater than the second.
         * @return {number} Lowest index of the target value if found, otherwise
         *     (-(insertion point) - 1). The insertion point is where the value should
         *     be inserted into arr to preserve the sorted property.  Return value >=
         * 0 iff target is found.
         * @template TARGET, VALUE
         */
        function binarySearch(arr, target, opt_compareFn) {
            return goog.array.binarySearch_(arr, opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */, target);
        }
        array_1.binarySearch = binarySearch;
        ;
        /**
         * Selects an index in the specified array using the binary search algorithm.
         * The evaluator receives an element and determines whether the desired index
         * is before, at, or after it.  The evaluator must be consistent (formally,
         * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)
         * must be monotonically non-increasing).
         *
         * Runtime: O(log n)
         *
         * @param {IArrayLike<VALUE>} arr The array to be searched.
         * @param {function(this:THIS, VALUE, number, ?): number} evaluator
         *     Evaluator function that receives 3 arguments (the element, the index
         * and the array). Should return a negative number, zero, or a positive number
         *     depending on whether the desired index is before, at, or after the
         *     element passed to it.
         * @param {THIS=} opt_obj The object to be used as the value of 'this'
         *     within evaluator.
         * @return {number} Index of the leftmost element matched by the evaluator, if
         *     such exists; otherwise (-(insertion point) - 1). The insertion point is
         *     the index of the first element for which the evaluator returns
         * negative, or arr.length if no such element exists. The return value is
         * non-negative iff a match is found.
         * @template THIS, VALUE
         */
        function binarySelect(arr, evaluator, opt_obj) {
            var adapter = opt_obj;
            return goog.array.binarySearch_(arr, evaluator, true /* isEvaluator */, undefined /* opt_target */, adapter);
        }
        array_1.binarySelect = binarySelect;
        ;
        /**
         * Implementation of a binary search algorithm which knows how to use both
         * comparison functions and evaluators. If an evaluator is provided, will call
         * the evaluator with the given optional data object, conforming to the
         * interface defined in binarySelect. Otherwise, if a comparison function is
         * provided, will call the comparison function against the given data object.
         *
         * This implementation purposefully does not use goog.bind or goog.partial for
         * performance reasons.
         *
         * Runtime: O(log n)
         *
         * @param {IArrayLike<?>} arr The array to be searched.
         * @param {function(?, ?, ?): number | function(?, ?): number} compareFn
         *     Either an evaluator or a comparison function, as defined by
         * binarySearch and binarySelect above.
         * @param {boolean} isEvaluator Whether the function is an evaluator or a
         *     comparison function.
         * @param {?=} opt_target If the function is a comparison function, then
         *     this is the target to binary search for.
         * @param {Object=} opt_selfObj If the function is an evaluator, this is an
         *     optional this object for the evaluator.
         * @return {number} Lowest index of the target value if found, otherwise
         *     (-(insertion point) - 1). The insertion point is where the value should
         *     be inserted into arr to preserve the sorted property.  Return value >=
         * 0 iff target is found.
         * @private
         */
        function binarySearch_(arr, compareFn, isEvaluator, opt_target, opt_selfObj) {
            var left = 0; // inclusive
            var right = arr.length; // exclusive
            var found;
            while (left < right) {
                var middle = (left + right) >> 1;
                var compareResult;
                if (isEvaluator) {
                    compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
                }
                else {
                    // NOTE(dimvar): To avoid this cast, we'd have to use function
                    // overloading for the type of binarySearch_, which the type system
                    // can't express yet.
                    compareFn(1, 2);
                    compareResult = compareFn(opt_target, arr[middle]);
                }
                if (compareResult > 0) {
                    left = middle + 1;
                }
                else {
                    right = middle;
                    // We are looking for the lowest index so we can't return immediately.
                    found = !compareResult;
                }
            }
            // left is the index if found, or the insertion point otherwise.
            // ~left is a shorthand for -left - 1.
            return found ? left : ~left;
        }
        array_1.binarySearch_ = binarySearch_;
        ;
        /**
         * Sorts the specified array into ascending order.  If no opt_compareFn is
         * specified, elements are compared using
         * <code>goog.array.defaultCompare</code>, which compares the elements using
         * the built in < and > operators.  This will produce the expected behavior
         * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
         * but will give unpredictable results for heterogeneous lists of strings and
         * numbers with different numbers of digits.
         *
         * This sort is not guaranteed to be stable.
         *
         * Runtime: Same as <code>Array.prototype.sort</code>
         *
         * @param {Array<T>} arr The array to be sorted.
         * @param {?function(T,T):number=} opt_compareFn Optional comparison
         *     function by which the
         *     array is to be ordered. Should take 2 arguments to compare, and return
         * a negative number, zero, or a positive number depending on whether the
         *     first argument is less than, equal to, or greater than the second.
         * @template T
         */
        function sort(arr, opt_compareFn) {
            // TODO(arv): Update type annotation since null is not accepted.
            arr.sort(opt_compareFn || goog.array.defaultCompare);
        }
        array_1.sort = sort;
        ;
        /**
         * Sorts the specified array into ascending order in a stable way.  If no
         * opt_compareFn is specified, elements are compared using
         * <code>goog.array.defaultCompare</code>, which compares the elements using
         * the built in < and > operators.  This will produce the expected behavior
         * for homogeneous arrays of String(s) and Number(s).
         *
         * Runtime: Same as <code>Array.prototype.sort</code>, plus an additional
         * O(n) overhead of copying the array twice.
         *
         * @param {Array<T>} arr The array to be sorted.
         * @param {?function(T, T): number=} opt_compareFn Optional comparison function
         *     by which the array is to be ordered. Should take 2 arguments to
         * compare, and return a negative number, zero, or a positive number depending
         * on whether the first argument is less than, equal to, or greater than the
         *     second.
         * @template T
         */
        function stableSort(arr, opt_compareFn) {
            var compArr = new Array(arr.length);
            for (var i = 0; i < arr.length; i++) {
                compArr[i] = { index: i, value: arr[i] };
            }
            var valueCompareFn = opt_compareFn || goog.array.defaultCompare;
            function stableCompareFn(obj1, obj2) {
                return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;
            }
            goog.array.sort(compArr, stableCompareFn);
            for (var i = 0; i < arr.length; i++) {
                arr[i] = compArr[i].value;
            }
        }
        array_1.stableSort = stableSort;
        ;
        /**
         * Sort the specified array into ascending order based on item keys
         * returned by the specified key function.
         * If no opt_compareFn is specified, the keys are compared in ascending order
         * using <code>goog.array.defaultCompare</code>.
         *
         * Runtime: O(S(f(n)), where S is runtime of <code>goog.array.sort</code>
         * and f(n) is runtime of the key function.
         *
         * @param {Array<T>} arr The array to be sorted.
         * @param {function(T): K} keyFn Function taking array element and returning
         *     a key used for sorting this element.
         * @param {?function(K, K): number=} opt_compareFn Optional comparison function
         *     by which the keys are to be ordered. Should take 2 arguments to
         * compare, and return a negative number, zero, or a positive number depending
         * on whether the first argument is less than, equal to, or greater than the
         *     second.
         * @template T,K
         */
        function sortByKey(arr, keyFn, opt_compareFn) {
            var keyCompareFn = opt_compareFn || goog.array.defaultCompare;
            goog.array.sort(arr, function (a, b) {
                return keyCompareFn(keyFn(a), keyFn(b));
            });
        }
        array_1.sortByKey = sortByKey;
        ;
        /**
         * Sorts an array of objects by the specified object key and compare
         * function. If no compare function is provided, the key values are
         * compared in ascending order using <code>goog.array.defaultCompare</code>.
         * This won't work for keys that get renamed by the compiler. So use
         * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.
         * @param {Array<Object>} arr An array of objects to sort.
         * @param {string} key The object key to sort by.
         * @param {Function=} opt_compareFn The function to use to compare key
         *     values.
         */
        function sortObjectsByKey(arr, key, opt_compareFn) {
            var adapter = opt_compareFn;
            goog.array.sortByKey(arr, function (obj) {
                return obj[key];
            }, adapter);
        }
        array_1.sortObjectsByKey = sortObjectsByKey;
        ;
        /**
         * Tells if the array is sorted.
         * @param {!IArrayLike<T>} arr The array.
         * @param {?function(T,T):number=} opt_compareFn Function to compare the
         *     array elements.
         *     Should take 2 arguments to compare, and return a negative number, zero,
         *     or a positive number depending on whether the first argument is less
         *     than, equal to, or greater than the second.
         * @param {boolean=} opt_strict If true no equal elements are allowed.
         * @return {boolean} Whether the array is sorted.
         * @template T
         */
        function isSorted(arr, opt_compareFn, opt_strict) {
            var compare = opt_compareFn || goog.array.defaultCompare;
            for (var i = 1; i < arr.length; i++) {
                var compareResult = compare(arr[i - 1], arr[i]);
                if (compareResult > 0 || compareResult == 0 && opt_strict) {
                    return false;
                }
            }
            return true;
        }
        array_1.isSorted = isSorted;
        ;
        /**
         * Compares two arrays for equality. Two arrays are considered equal if they
         * have the same length and their corresponding elements are equal according
         * to the comparison function.
         *
         * @param {IArrayLike<?>} arr1 The first array to compare.
         * @param {IArrayLike<?>} arr2 The second array to compare.
         * @param {Function=} opt_equalsFn Optional comparison function.
         *     Should take 2 arguments to compare, and return true if the arguments
         *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
         *     compares the elements using the built-in '===' operator.
         * @return {boolean} Whether the two arrays are equal.
         */
        function equals(arr1, arr2, opt_equalsFn) {
            if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
                arr1.length != arr2.length) {
                return false;
            }
            var l = arr1.length;
            var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
            for (var i = 0; i < l; i++) {
                if (!equalsFn(arr1[i], arr2[i])) {
                    return false;
                }
            }
            return true;
        }
        array_1.equals = equals;
        ;
        /**
         * 3-way array compare function.
         * @param {!IArrayLike<VALUE>} arr1 The first array to
         *     compare.
         * @param {!IArrayLike<VALUE>} arr2 The second array to
         *     compare.
         * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
         *     function by which the array is to be ordered. Should take 2 arguments
         * to compare, and return a negative number, zero, or a positive number
         *     depending on whether the first argument is less than, equal to, or
         *     greater than the second.
         * @return {number} Negative number, zero, or a positive number depending on
         *     whether the first argument is less than, equal to, or greater than the
         *     second.
         * @template VALUE
         */
        function compare3(arr1, arr2, opt_compareFn) {
            var compare = opt_compareFn || goog.array.defaultCompare;
            var l = Math.min(arr1.length, arr2.length);
            for (var i = 0; i < l; i++) {
                var result = compare(arr1[i], arr2[i]);
                if (result != 0) {
                    return result;
                }
            }
            return goog.array.defaultCompare(arr1.length, arr2.length);
        }
        array_1.compare3 = compare3;
        ;
        /**
         * Compares its two arguments for order, using the built in < and >
         * operators.
         * @param {VALUE} a The first object to be compared.
         * @param {VALUE} b The second object to be compared.
         * @return {number} A negative number, zero, or a positive number as the first
         *     argument is less than, equal to, or greater than the second,
         *     respectively.
         * @template VALUE
         */
        function defaultCompare(a, b) {
            return a > b ? 1 : a < b ? -1 : 0;
        }
        array_1.defaultCompare = defaultCompare;
        ;
        /**
         * Compares its two arguments for inverse order, using the built in < and >
         * operators.
         * @param {VALUE} a The first object to be compared.
         * @param {VALUE} b The second object to be compared.
         * @return {number} A negative number, zero, or a positive number as the first
         *     argument is greater than, equal to, or less than the second,
         *     respectively.
         * @template VALUE
         */
        function inverseDefaultCompare(a, b) {
            return -goog.array.defaultCompare(a, b);
        }
        array_1.inverseDefaultCompare = inverseDefaultCompare;
        ;
        /**
         * Compares its two arguments for equality, using the built in === operator.
         * @param {*} a The first object to compare.
         * @param {*} b The second object to compare.
         * @return {boolean} True if the two arguments are equal, false otherwise.
         */
        function defaultCompareEquality(a, b) {
            return a === b;
        }
        array_1.defaultCompareEquality = defaultCompareEquality;
        ;
        /**
         * Inserts a value into a sorted array. The array is not modified if the
         * value is already present.
         * @param {IArrayLike<VALUE>} array The array to modify.
         * @param {VALUE} value The object to insert.
         * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
         *     function by which the array is ordered. Should take 2 arguments to
         *     compare, and return a negative number, zero, or a positive number
         *     depending on whether the first argument is less than, equal to, or
         *     greater than the second.
         * @return {boolean} True if an element was inserted.
         * @template VALUE
         */
        function binaryInsert(array, value, opt_compareFn) {
            var index = goog.array.binarySearch(array, value, opt_compareFn);
            if (index < 0) {
                goog.array.insertAt(array, value, -(index + 1));
                return true;
            }
            return false;
        }
        array_1.binaryInsert = binaryInsert;
        ;
        /**
         * Removes a value from a sorted array.
         * @param {!IArrayLike<VALUE>} array The array to modify.
         * @param {VALUE} value The object to remove.
         * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
         *     function by which the array is ordered. Should take 2 arguments to
         *     compare, and return a negative number, zero, or a positive number
         *     depending on whether the first argument is less than, equal to, or
         *     greater than the second.
         * @return {boolean} True if an element was removed.
         * @template VALUE
         */
        function binaryRemove(array, value, opt_compareFn) {
            var index = goog.array.binarySearch(array, value, opt_compareFn);
            return (index >= 0) ? goog.array.removeAt(array, index) : false;
        }
        array_1.binaryRemove = binaryRemove;
        ;
        /**
         * Splits an array into disjoint buckets according to a splitting function.
         * @param {IArrayLike<T>} array The array.
         * @param {function(this:S, T, number, !IArrayLike<T>):?} sorter Function to
         *     call for every element.  This takes 3 arguments (the element, the index
         *     and the array) and must return a valid object key (a string, number,
         *     etc), or undefined, if that object should not be placed in a bucket.
         * @param {S=} opt_obj The object to be used as the value of 'this' within
         *     sorter.
         * @return {!Object<!Array<T>>} An object, with keys being all of the unique
         *     return values of sorter, and values being arrays containing the items
         * for which the splitter returned that key.
         * @template T,S
         */
        function bucket(array, sorter, opt_obj) {
            var buckets = {};
            for (var i = 0; i < array.length; i++) {
                var value = array[i];
                var key = sorter.call(/** @type {?} */ (opt_obj), value, i, array);
                if (goog.isDef(key)) {
                    // Push the value to the right bucket, creating it if necessary.
                    var bucket = buckets[key] || (buckets[key] = []);
                    bucket.push(value);
                }
            }
            return buckets;
        }
        array_1.bucket = bucket;
        ;
        /**
         * Creates a new object built from the provided array and the key-generation
         * function.
         * @param {IArrayLike<T>} arr Array or array like object over
         *     which to iterate whose elements will be the values in the new object.
         * @param {?function(this:S, T, number, ?) : string} keyFunc The function to
         *     call for every element. This function takes 3 arguments (the element,
         * the index and the array) and should return a string that will be used as
         * the key for the element in the new object. If the function returns the same
         *     key for more than one element, the value for that key is
         *     implementation-defined.
         * @param {S=} opt_obj The object to be used as the value of 'this'
         *     within keyFunc.
         * @return {!Object<T>} The new object.
         * @template T,S
         */
        function toObject(arr, keyFunc, opt_obj) {
            var ret = {};
            goog.array.forEach(arr, function (element, index) {
                ret[keyFunc.call(/** @type {?} */ (opt_obj), element, index, arr)] =
                    element;
            });
            return ret;
        }
        array_1.toObject = toObject;
        ;
        /**
         * Creates a range of numbers in an arithmetic progression.
         *
         * Range takes 1, 2, or 3 arguments:
         * <pre>
         * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]
         * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]
         * range(-2, -5, -1) produces [-2, -3, -4]
         * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.
         * </pre>
         *
         * @param {number} startOrEnd The starting value of the range if an end argument
         *     is provided. Otherwise, the start value is 0, and this is the end
         * value.
         * @param {number=} opt_end The optional end value of the range.
         * @param {number=} opt_step The step size between range values. Defaults to 1
         *     if opt_step is undefined or 0.
         * @return {!Array<number>} An array of numbers for the requested range. May be
         *     an empty array if adding the step would not converge toward the end
         *     value.
         */
        function range(startOrEnd, opt_end, opt_step) {
            var array = [];
            var start = 0;
            var end = startOrEnd;
            var step = opt_step || 1;
            if (opt_end !== undefined) {
                start = startOrEnd;
                end = opt_end;
            }
            if (step * (end - start) < 0) {
                // Sign mismatch: start + step will never reach the end value.
                return [];
            }
            if (step > 0) {
                for (var i = start; i < end; i += step) {
                    array.push(i);
                }
            }
            else {
                for (var i = start; i > end; i += step) {
                    array.push(i);
                }
            }
            return array;
        }
        array_1.range = range;
        ;
        /**
         * Returns an array consisting of the given value repeated N times.
         *
         * @param {VALUE} value The value to repeat.
         * @param {number} n The repeat count.
         * @return {!Array<VALUE>} An array with the repeated value.
         * @template VALUE
         */
        function repeat(value, n) {
            var array = [];
            for (var i = 0; i < n; i++) {
                array[i] = value;
            }
            return array;
        }
        array_1.repeat = repeat;
        ;
        /**
         * Returns an array consisting of every argument with all arrays
         * expanded in-place recursively.
         *
         * @param {...*} var_args The values to flatten.
         * @return {!Array<?>} An array containing the flattened values.
         */
        function flatten() {
            var var_args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                var_args[_i] = arguments[_i];
            }
            var CHUNK_SIZE = 8192;
            var result = [];
            for (var i = 0; i < arguments.length; i++) {
                var element = arguments[i];
                if (goog.isArray(element)) {
                    for (var c = 0; c < element.length; c += CHUNK_SIZE) {
                        var chunk = goog.array.slice(element, c, c + CHUNK_SIZE);
                        var recurseResult = goog.array.flatten.apply(null, chunk);
                        for (var r = 0; r < recurseResult.length; r++) {
                            result.push(recurseResult[r]);
                        }
                    }
                }
                else {
                    result.push(element);
                }
            }
            return result;
        }
        array_1.flatten = flatten;
        ;
        /**
         * Rotates an array in-place. After calling this method, the element at
         * index i will be the element previously at index (i - n) %
         * array.length, for all values of i between 0 and array.length - 1,
         * inclusive.
         *
         * For example, suppose list comprises [t, a, n, k, s]. After invoking
         * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n,
         * k].
         *
         * @param {!Array<T>} array The array to rotate.
         * @param {number} n The amount to rotate.
         * @return {!Array<T>} The array.
         * @template T
         */
        function rotate(array, n) {
            goog.asserts.assert(array.length != null);
            if (array.length) {
                n %= array.length;
                if (n > 0) {
                    Array.prototype.unshift.apply(array, array.splice(-n, n));
                }
                else if (n < 0) {
                    Array.prototype.push.apply(array, array.splice(0, -n));
                }
            }
            return array;
        }
        array_1.rotate = rotate;
        ;
        /**
         * Moves one item of an array to a new position keeping the order of the rest
         * of the items. Example use case: keeping a list of JavaScript objects
         * synchronized with the corresponding list of DOM elements after one of the
         * elements has been dragged to a new position.
         * @param {!IArrayLike<?>} arr The array to modify.
         * @param {number} fromIndex Index of the item to move between 0 and
         *     {@code arr.length - 1}.
         * @param {number} toIndex Target index between 0 and {@code arr.length - 1}.
         */
        function moveItem(arr, fromIndex, toIndex) {
            goog.asserts.assert(fromIndex >= 0 && fromIndex < arr.length);
            goog.asserts.assert(toIndex >= 0 && toIndex < arr.length);
            // Remove 1 item at fromIndex.
            var removedItems = Array.prototype.splice.call(arr, fromIndex, 1);
            // Insert the removed item at toIndex.
            Array.prototype.splice.call(arr, toIndex, 0, removedItems[0]);
        }
        array_1.moveItem = moveItem;
        ;
        /**
         * Creates a new array for which the element at position i is an array of the
         * ith element of the provided arrays.  The returned array will only be as
         * long as the shortest array provided; additional values are ignored.  For
         * example, the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].
         *
         * This is similar to the zip() function in Python.  See {@link
         * http://docs.python.org/library/functions.html#zip}
         *
         * @param {...!IArrayLike<?>} var_args Arrays to be combined.
         * @return {!Array<!Array<?>>} A new array of arrays created from
         *     provided arrays.
         */
        function zip() {
            var var_args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                var_args[_i] = arguments[_i];
            }
            if (!arguments.length) {
                return [];
            }
            var result = [];
            var minLen = arguments[0].length;
            for (var i = 1; i < arguments.length; i++) {
                if (arguments[i].length < minLen) {
                    minLen = arguments[i].length;
                }
            }
            for (var i = 0; i < minLen; i++) {
                var value = [];
                for (var j = 0; j < arguments.length; j++) {
                    value.push(arguments[j][i]);
                }
                result.push(value);
            }
            return result;
        }
        array_1.zip = zip;
        ;
        /**
         * Shuffles the values in the specified array using the Fisher-Yates in-place
         * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()
         * and so resets the state of that random number generator. Similarly, may
         * reset the state of the any other specified random number generator.
         *
         * Runtime: O(n)
         *
         * @param {!Array<?>} arr The array to be shuffled.
         * @param {function():number=} opt_randFn Optional random function to use for
         *     shuffling.
         *     Takes no arguments, and returns a random number on the interval [0, 1).
         *     Defaults to Math.random() using JavaScript's built-in Math library.
         */
        function shuffle(arr, opt_randFn) {
            var randFn = opt_randFn || Math.random;
            for (var i = arr.length - 1; i > 0; i--) {
                // Choose a random array index in [0, i] (inclusive with i).
                var j = Math.floor(randFn() * (i + 1));
                var tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
        array_1.shuffle = shuffle;
        ;
        /**
         * Returns a new array of elements from arr, based on the indexes of elements
         * provided by index_arr. For example, the result of index copying
         * ['a', 'b', 'c'] with index_arr [1,0,0,2] is ['b', 'a', 'a', 'c'].
         *
         * @param {!IArrayLike<T>} arr The array to get a indexed copy from.
         * @param {!IArrayLike<number>} index_arr An array of indexes to get from arr.
         * @return {!Array<T>} A new array of elements from arr in index_arr order.
         * @template T
         */
        function copyByIndex(arr, index_arr) {
            var result = [];
            goog.array.forEach(index_arr, function (index) {
                result.push(arr[index]);
            });
            return result;
        }
        array_1.copyByIndex = copyByIndex;
        ;
        /**
         * Maps each element of the input array into zero or more elements of the
         * output array.
         *
         * @param {!IArrayLike<VALUE>|string} arr Array or array like object
         *     over which to iterate.
         * @param {function(this:THIS, VALUE, number, ?): !Array<RESULT>} f The function
         *     to call for every element. This function takes 3 arguments (the
         * element, the index and the array) and should return an array. The result
         * will be used to extend a new array.
         * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.
         * @return {!Array<RESULT>} a new array with the concatenation of all arrays
         *     returned from f.
         * @template THIS, VALUE, RESULT
         */
        function concatMap(arr, f, opt_obj) {
            return goog.array.concat.apply([], goog.array.map(arr, f, opt_obj));
        }
        array_1.concatMap = concatMap;
        ;
    })(array = goog.array || (goog.array = {}));
})(goog || (goog = {}));
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Defines the goog.dom.TagName class. Its constants enumerate
 * all HTML tag names specified in either the the W3C HTML 4.01 index of
 * elements or the HTML5.1 specification.
 *
 * References:
 * https://www.w3.org/TR/html401/index/elements.html
 * https://www.w3.org/TR/html51/dom.html#elements
 */
goog.provide('goog.dom.TagName');
goog.require('goog.dom.HtmlElement');
var goog;
(function (goog) {
    var dom;
    (function (dom) {
        var TagName = /** @class */ (function () {
            /**
             * A tag name with the type of the element stored in the generic.
             * @param {string} tagName
             * @constructor
             * @template T
             */
            function TagName(tagName) {
                /** @private {string} */
                this.tagName_ = tagName;
            }
            /**
             * Returns the tag name.
             * @return {string}
             * @override
             */
            TagName.prototype.toString = function () {
                return this.tagName_;
            };
            return TagName;
        }());
        dom.TagName = TagName;
    })(dom = goog.dom || (goog.dom = {}));
})(goog || (goog = {}));
(function (goog) {
    var dom;
    (function (dom) {
        var TagName;
        (function (TagName) {
            /** @type {!goog.dom.TagName<!HTMLAnchorElement>} */
            TagName.A = new goog.dom.TagName('A');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.ABBR = new goog.dom.TagName('ABBR');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.ACRONYM = new goog.dom.TagName('ACRONYM');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.ADDRESS = new goog.dom.TagName('ADDRESS');
            /** @type {!goog.dom.TagName<!HTMLAppletElement>} */
            TagName.APPLET = new goog.dom.TagName('APPLET');
            /** @type {!goog.dom.TagName<!HTMLAreaElement>} */
            TagName.AREA = new goog.dom.TagName('AREA');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.ARTICLE = new goog.dom.TagName('ARTICLE');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.ASIDE = new goog.dom.TagName('ASIDE');
            /** @type {!goog.dom.TagName<!HTMLAudioElement>} */
            TagName.AUDIO = new goog.dom.TagName('AUDIO');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.B = new goog.dom.TagName('B');
            /** @type {!goog.dom.TagName<!HTMLBaseElement>} */
            TagName.BASE = new goog.dom.TagName('BASE');
            /** @type {!goog.dom.TagName<!HTMLBaseFontElement>} */
            TagName.BASEFONT = new goog.dom.TagName('BASEFONT');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.BDI = new goog.dom.TagName('BDI');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.BDO = new goog.dom.TagName('BDO');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.BIG = new goog.dom.TagName('BIG');
            /** @type {!goog.dom.TagName<!HTMLQuoteElement>} */
            TagName.BLOCKQUOTE = new goog.dom.TagName('BLOCKQUOTE');
            /** @type {!goog.dom.TagName<!HTMLBodyElement>} */
            TagName.BODY = new goog.dom.TagName('BODY');
            /** @type {!goog.dom.TagName<!HTMLBRElement>} */
            TagName.BR = new goog.dom.TagName('BR');
            /** @type {!goog.dom.TagName<!HTMLButtonElement>} */
            TagName.BUTTON = new goog.dom.TagName('BUTTON');
            /** @type {!goog.dom.TagName<!HTMLCanvasElement>} */
            TagName.CANVAS = new goog.dom.TagName('CANVAS');
            /** @type {!goog.dom.TagName<!HTMLTableCaptionElement>} */
            TagName.CAPTION = new goog.dom.TagName('CAPTION');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.CENTER = new goog.dom.TagName('CENTER');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.CITE = new goog.dom.TagName('CITE');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.CODE = new goog.dom.TagName('CODE');
            /** @type {!goog.dom.TagName<!HTMLTableColElement>} */
            TagName.COL = new goog.dom.TagName('COL');
            /** @type {!goog.dom.TagName<!HTMLTableColElement>} */
            TagName.COLGROUP = new goog.dom.TagName('COLGROUP');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.COMMAND = new goog.dom.TagName('COMMAND');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.DATA = new goog.dom.TagName('DATA');
            /** @type {!goog.dom.TagName<!HTMLDataListElement>} */
            TagName.DATALIST = new goog.dom.TagName('DATALIST');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.DD = new goog.dom.TagName('DD');
            /** @type {!goog.dom.TagName<!HTMLModElement>} */
            TagName.DEL = new goog.dom.TagName('DEL');
            /** @type {!goog.dom.TagName<!HTMLDetailsElement>} */
            TagName.DETAILS = new goog.dom.TagName('DETAILS');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.DFN = new goog.dom.TagName('DFN');
            /** @type {!goog.dom.TagName<!HTMLDialogElement>} */
            TagName.DIALOG = new goog.dom.TagName('DIALOG');
            /** @type {!goog.dom.TagName<!HTMLDirectoryElement>} */
            TagName.DIR = new goog.dom.TagName('DIR');
            /** @type {!goog.dom.TagName<!HTMLDivElement>} */
            TagName.DIV = new goog.dom.TagName('DIV');
            /** @type {!goog.dom.TagName<!HTMLDListElement>} */
            TagName.DL = new goog.dom.TagName('DL');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.DT = new goog.dom.TagName('DT');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.EM = new goog.dom.TagName('EM');
            /** @type {!goog.dom.TagName<!HTMLEmbedElement>} */
            TagName.EMBED = new goog.dom.TagName('EMBED');
            /** @type {!goog.dom.TagName<!HTMLFieldSetElement>} */
            TagName.FIELDSET = new goog.dom.TagName('FIELDSET');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.FIGCAPTION = new goog.dom.TagName('FIGCAPTION');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.FIGURE = new goog.dom.TagName('FIGURE');
            /** @type {!goog.dom.TagName<!HTMLFontElement>} */
            TagName.FONT = new goog.dom.TagName('FONT');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.FOOTER = new goog.dom.TagName('FOOTER');
            /** @type {!goog.dom.TagName<!HTMLFormElement>} */
            TagName.FORM = new goog.dom.TagName('FORM');
            /** @type {!goog.dom.TagName<!HTMLFrameElement>} */
            TagName.FRAME = new goog.dom.TagName('FRAME');
            /** @type {!goog.dom.TagName<!HTMLFrameSetElement>} */
            TagName.FRAMESET = new goog.dom.TagName('FRAMESET');
            /** @type {!goog.dom.TagName<!HTMLHeadingElement>} */
            TagName.H1 = new goog.dom.TagName('H1');
            /** @type {!goog.dom.TagName<!HTMLHeadingElement>} */
            TagName.H2 = new goog.dom.TagName('H2');
            /** @type {!goog.dom.TagName<!HTMLHeadingElement>} */
            TagName.H3 = new goog.dom.TagName('H3');
            /** @type {!goog.dom.TagName<!HTMLHeadingElement>} */
            TagName.H4 = new goog.dom.TagName('H4');
            /** @type {!goog.dom.TagName<!HTMLHeadingElement>} */
            TagName.H5 = new goog.dom.TagName('H5');
            /** @type {!goog.dom.TagName<!HTMLHeadingElement>} */
            TagName.H6 = new goog.dom.TagName('H6');
            /** @type {!goog.dom.TagName<!HTMLHeadElement>} */
            TagName.HEAD = new goog.dom.TagName('HEAD');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.HEADER = new goog.dom.TagName('HEADER');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.HGROUP = new goog.dom.TagName('HGROUP');
            /** @type {!goog.dom.TagName<!HTMLHRElement>} */
            TagName.HR = new goog.dom.TagName('HR');
            /** @type {!goog.dom.TagName<!HTMLHtmlElement>} */
            TagName.HTML = new goog.dom.TagName('HTML');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.I = new goog.dom.TagName('I');
            /** @type {!goog.dom.TagName<!HTMLIFrameElement>} */
            TagName.IFRAME = new goog.dom.TagName('IFRAME');
            /** @type {!goog.dom.TagName<!HTMLImageElement>} */
            TagName.IMG = new goog.dom.TagName('IMG');
            /** @type {!goog.dom.TagName<!HTMLInputElement>} */
            TagName.INPUT = new goog.dom.TagName('INPUT');
            /** @type {!goog.dom.TagName<!HTMLModElement>} */
            TagName.INS = new goog.dom.TagName('INS');
            /** @type {!goog.dom.TagName<!HTMLIsIndexElement>} */
            TagName.ISINDEX = new goog.dom.TagName('ISINDEX');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.KBD = new goog.dom.TagName('KBD');
            // HTMLKeygenElement is deprecated.
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.KEYGEN = new goog.dom.TagName('KEYGEN');
            /** @type {!goog.dom.TagName<!HTMLLabelElement>} */
            TagName.LABEL = new goog.dom.TagName('LABEL');
            /** @type {!goog.dom.TagName<!HTMLLegendElement>} */
            TagName.LEGEND = new goog.dom.TagName('LEGEND');
            /** @type {!goog.dom.TagName<!HTMLLIElement>} */
            TagName.LI = new goog.dom.TagName('LI');
            /** @type {!goog.dom.TagName<!HTMLLinkElement>} */
            TagName.LINK = new goog.dom.TagName('LINK');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.MAIN = new goog.dom.TagName('MAIN');
            /** @type {!goog.dom.TagName<!HTMLMapElement>} */
            TagName.MAP = new goog.dom.TagName('MAP');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.MARK = new goog.dom.TagName('MARK');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.MATH = new goog.dom.TagName('MATH');
            /** @type {!goog.dom.TagName<!HTMLMenuElement>} */
            TagName.MENU = new goog.dom.TagName('MENU');
            /** @type {!goog.dom.TagName<!HTMLMenuItemElement>} */
            TagName.MENUITEM = new goog.dom.TagName('MENUITEM');
            /** @type {!goog.dom.TagName<!HTMLMetaElement>} */
            TagName.META = new goog.dom.TagName('META');
            /** @type {!goog.dom.TagName<!HTMLMeterElement>} */
            TagName.METER = new goog.dom.TagName('METER');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.NAV = new goog.dom.TagName('NAV');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.NOFRAMES = new goog.dom.TagName('NOFRAMES');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.NOSCRIPT = new goog.dom.TagName('NOSCRIPT');
            /** @type {!goog.dom.TagName<!HTMLObjectElement>} */
            TagName.OBJECT = new goog.dom.TagName('OBJECT');
            /** @type {!goog.dom.TagName<!HTMLOListElement>} */
            TagName.OL = new goog.dom.TagName('OL');
            /** @type {!goog.dom.TagName<!HTMLOptGroupElement>} */
            TagName.OPTGROUP = new goog.dom.TagName('OPTGROUP');
            /** @type {!goog.dom.TagName<!HTMLOptionElement>} */
            TagName.OPTION = new goog.dom.TagName('OPTION');
            /** @type {!goog.dom.TagName<!HTMLOutputElement>} */
            TagName.OUTPUT = new goog.dom.TagName('OUTPUT');
            /** @type {!goog.dom.TagName<!HTMLParagraphElement>} */
            TagName.P = new goog.dom.TagName('P');
            /** @type {!goog.dom.TagName<!HTMLParamElement>} */
            TagName.PARAM = new goog.dom.TagName('PARAM');
            /** @type {!goog.dom.TagName<!HTMLPictureElement>} */
            TagName.PICTURE = new goog.dom.TagName('PICTURE');
            /** @type {!goog.dom.TagName<!HTMLPreElement>} */
            TagName.PRE = new goog.dom.TagName('PRE');
            /** @type {!goog.dom.TagName<!HTMLProgressElement>} */
            TagName.PROGRESS = new goog.dom.TagName('PROGRESS');
            /** @type {!goog.dom.TagName<!HTMLQuoteElement>} */
            TagName.Q = new goog.dom.TagName('Q');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.RP = new goog.dom.TagName('RP');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.RT = new goog.dom.TagName('RT');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.RTC = new goog.dom.TagName('RTC');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.RUBY = new goog.dom.TagName('RUBY');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.S = new goog.dom.TagName('S');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.SAMP = new goog.dom.TagName('SAMP');
            /** @type {!goog.dom.TagName<!HTMLScriptElement>} */
            TagName.SCRIPT = new goog.dom.TagName('SCRIPT');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.SECTION = new goog.dom.TagName('SECTION');
            /** @type {!goog.dom.TagName<!HTMLSelectElement>} */
            TagName.SELECT = new goog.dom.TagName('SELECT');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.SMALL = new goog.dom.TagName('SMALL');
            /** @type {!goog.dom.TagName<!HTMLSourceElement>} */
            TagName.SOURCE = new goog.dom.TagName('SOURCE');
            /** @type {!goog.dom.TagName<!HTMLSpanElement>} */
            TagName.SPAN = new goog.dom.TagName('SPAN');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.STRIKE = new goog.dom.TagName('STRIKE');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.STRONG = new goog.dom.TagName('STRONG');
            /** @type {!goog.dom.TagName<!HTMLStyleElement>} */
            TagName.STYLE = new goog.dom.TagName('STYLE');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.SUB = new goog.dom.TagName('SUB');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.SUMMARY = new goog.dom.TagName('SUMMARY');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.SUP = new goog.dom.TagName('SUP');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.SVG = new goog.dom.TagName('SVG');
            /** @type {!goog.dom.TagName<!HTMLTableElement>} */
            TagName.TABLE = new goog.dom.TagName('TABLE');
            /** @type {!goog.dom.TagName<!HTMLTableSectionElement>} */
            TagName.TBODY = new goog.dom.TagName('TBODY');
            /** @type {!goog.dom.TagName<!HTMLTableCellElement>} */
            TagName.TD = new goog.dom.TagName('TD');
            /** @type {!goog.dom.TagName<!HTMLTemplateElement>} */
            TagName.TEMPLATE = new goog.dom.TagName('TEMPLATE');
            /** @type {!goog.dom.TagName<!HTMLTextAreaElement>} */
            TagName.TEXTAREA = new goog.dom.TagName('TEXTAREA');
            /** @type {!goog.dom.TagName<!HTMLTableSectionElement>} */
            TagName.TFOOT = new goog.dom.TagName('TFOOT');
            /** @type {!goog.dom.TagName<!HTMLTableCellElement>} */
            TagName.TH = new goog.dom.TagName('TH');
            /** @type {!goog.dom.TagName<!HTMLTableSectionElement>} */
            TagName.THEAD = new goog.dom.TagName('THEAD');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.TIME = new goog.dom.TagName('TIME');
            /** @type {!goog.dom.TagName<!HTMLTitleElement>} */
            TagName.TITLE = new goog.dom.TagName('TITLE');
            /** @type {!goog.dom.TagName<!HTMLTableRowElement>} */
            TagName.TR = new goog.dom.TagName('TR');
            /** @type {!goog.dom.TagName<!HTMLTrackElement>} */
            TagName.TRACK = new goog.dom.TagName('TRACK');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.TT = new goog.dom.TagName('TT');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.U = new goog.dom.TagName('U');
            /** @type {!goog.dom.TagName<!HTMLUListElement>} */
            TagName.UL = new goog.dom.TagName('UL');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.VAR = new goog.dom.TagName('VAR');
            /** @type {!goog.dom.TagName<!HTMLVideoElement>} */
            TagName.VIDEO = new goog.dom.TagName('VIDEO');
            /** @type {!goog.dom.TagName<!goog.dom.HtmlElement>} */
            TagName.WBR = new goog.dom.TagName('WBR');
        })(TagName = dom.TagName || (dom.TagName = {}));
    })(dom = goog.dom || (goog.dom = {}));
})(goog || (goog = {}));
// Closure Compiler unconditionally converts the following constants to their
// string value (goog.dom.TagName.A -> 'A'). These are the consequences:
// 1. Don't add any members or static members to goog.dom.TagName as they
//    couldn't be accessed after this optimization.
// 2. Keep the constant name and its string value the same:
//    goog.dom.TagName.X = new goog.dom.TagName('Y');
//    is converted to 'X', not 'Y'.
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utilities for string manipulation.
 * @author arv@google.com (Erik Arvidsson)
 */
/**
 * Namespace for string utilities
 */
goog.provide('goog.string');
goog.provide('goog.string.Unicode');
/**
 * @define {boolean} Enables HTML escaping of lowercase letter "e" which helps
 * with detection of double-escaping as this letter is frequently used.
 */
goog.define('goog.string.DETECT_DOUBLE_ESCAPING', false);
/**
 * @define {boolean} Whether to force non-dom html unescaping.
 */
goog.define('goog.string.FORCE_NON_DOM_HTML_UNESCAPING', false);
var goog;
(function (goog) {
    var string;
    (function (string_1) {
        /**
         * Common Unicode string characters.
         * @const
         * @enum {string}
         */
        string_1.Unicode = {
            NBSP: '\xa0'
        };
        /**
         * Fast prefix-checker.
         */
        function startsWith(str, prefix) {
            return str.lastIndexOf(prefix, 0) == 0;
        }
        string_1.startsWith = startsWith;
        function endsWith(str, suffix) {
            var l = str.length - suffix.length;
            return l >= 0 && str.indexOf(suffix, l) == l;
        }
        string_1.endsWith = endsWith;
        /**
         * Case-insensitive prefix-checker.
         * @param {string} str The string to check.
         * @param {string} prefix  A string to look for at the end of {@code str}.
         * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring
         *     case).
         */
        function caseInsensitiveStartsWith(str, prefix) {
            return goog.string.caseInsensitiveCompare(prefix, str.substr(0, prefix.length)) == 0;
        }
        string_1.caseInsensitiveStartsWith = caseInsensitiveStartsWith;
        ;
        /**
         * Case-insensitive suffix-checker.
         * @param {string} str The string to check.
         * @param {string} suffix A string to look for at the end of {@code str}.
         * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring
         *     case).
         */
        function caseInsensitiveEndsWith(str, suffix) {
            return (goog.string.caseInsensitiveCompare(suffix, str.substr(str.length - suffix.length, suffix.length)) == 0);
        }
        string_1.caseInsensitiveEndsWith = caseInsensitiveEndsWith;
        ;
        /**
         * Case-insensitive equality checker.
         * @param {string} str1 First string to check.
         * @param {string} str2 Second string to check.
         * @return {boolean} True if {@code str1} and {@code str2} are the same string,
         *     ignoring case.
         */
        function caseInsensitiveEquals(str1, str2) {
            return str1.toLowerCase() == str2.toLowerCase();
        }
        string_1.caseInsensitiveEquals = caseInsensitiveEquals;
        ;
        /**
     * Does simple python-style string substitution.
     * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
     * @param {string} str The string containing the pattern.
     * @param {...*} var_args The items to substitute into the pattern.
     * @return {string} A copy of {@code str} in which each occurrence of
     *     {@code %s} has been replaced an argument from {@code var_args}.
     */
        function subs(str) {
            var var_args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                var_args[_i - 1] = arguments[_i];
            }
            var splitParts = str.split('%s');
            var returnString = '';
            var subsArguments = Array.prototype.slice.call(arguments, 1);
            while (subsArguments.length &&
                // Replace up to the last split part. We are inserting in the
                // positions between split parts.
                splitParts.length > 1) {
                returnString += splitParts.shift() + subsArguments.shift();
            }
            return returnString + splitParts.join('%s'); // Join unused '%s'
        }
        string_1.subs = subs;
        ;
        /**
         * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines
         * and tabs) to a single space, and strips leading and trailing whitespace.
         * @param {string} str Input string.
         * @return {string} A copy of {@code str} with collapsed whitespace.
         */
        function collapseWhitespace(str) {
            // Since IE doesn't include non-breaking-space (0xa0) in their \s character
            // class (as required by section 7.2 of the ECMAScript spec), we explicitly
            // include it in the regexp to enforce consistent cross-browser behavior.
            return str.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
        }
        string_1.collapseWhitespace = collapseWhitespace;
        ;
        /**
         * Checks if a string is empty or contains only whitespaces.
         * @param {string} str The string to check.
         * @return {boolean} Whether {@code str} is empty or whitespace only.
         */
        function isEmptyOrWhitespace(str) {
            // testing length == 0 first is actually slower in all browsers (about the
            // same in Opera).
            // Since IE doesn't include non-breaking-space (0xa0) in their \s character
            // class (as required by section 7.2 of the ECMAScript spec), we explicitly
            // include it in the regexp to enforce consistent cross-browser behavior.
            return /^[\s\xa0]*$/.test(str);
        }
        string_1.isEmptyOrWhitespace = isEmptyOrWhitespace;
        ;
        /**
         * Checks if a string is empty.
         * @param {string} str The string to check.
         * @return {boolean} Whether {@code str} is empty.
         */
        function isEmptyString(str) {
            return str.length == 0;
        }
        string_1.isEmptyString = isEmptyString;
        ;
        /**
         * Checks if a string is empty or contains only whitespaces.
         *
         * @param {string} str The string to check.
         * @return {boolean} Whether {@code str} is empty or whitespace only.
         * @deprecated Use goog.string.isEmptyOrWhitespace instead.
         */
        function isEmpty(str) {
            return this.isEmptyOrWhitespace(str);
        }
        string_1.isEmpty = isEmpty;
        /**
         * Checks if a string is null, undefined, empty or contains only whitespaces.
         * @param {*} str The string to check.
         * @return {boolean} Whether {@code str} is null, undefined, empty, or
         *     whitespace only.
         * @deprecated Use goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str))
         *     instead.
         */
        function isEmptyOrWhitespaceSafe(str) {
            return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));
        }
        string_1.isEmptyOrWhitespaceSafe = isEmptyOrWhitespaceSafe;
        ;
        /**
         * Checks if a string is null, undefined, empty or contains only whitespaces.
         *
         * @param {*} str The string to check.
         * @return {boolean} Whether {@code str} is null, undefined, empty, or
         *     whitespace only.
         * @deprecated Use goog.string.isEmptyOrWhitespace instead.
         */
        function isEmptySafe(str) {
            return this.isEmptyOrWhitespaceSafe(str);
        }
        string_1.isEmptySafe = isEmptySafe;
        /**
         * Checks if a string is all breaking whitespace.
         * @param {string} str The string to check.
         * @return {boolean} Whether the string is all breaking whitespace.
         */
        function isBreakingWhitespace(str) {
            return !/[^\t\n\r ]/.test(str);
        }
        string_1.isBreakingWhitespace = isBreakingWhitespace;
        ;
        /**
         * Checks if a string contains all letters.
         * @param {string} str string to check.
         * @return {boolean} True if {@code str} consists entirely of letters.
         */
        function isAlpha(str) {
            return !/[^a-zA-Z]/.test(str);
        }
        string_1.isAlpha = isAlpha;
        ;
        /**
         * Checks if a string contains only numbers.
         * @param {*} str string to check. If not a string, it will be
         *     casted to one.
         * @return {boolean} True if {@code str} is numeric.
         */
        function isNumeric(str) {
            return !/[^0-9]/.test(str);
        }
        string_1.isNumeric = isNumeric;
        ;
        /**
         * Checks if a string contains only numbers or letters.
         * @param {string} str string to check.
         * @return {boolean} True if {@code str} is alphanumeric.
         */
        function isAlphaNumeric(str) {
            return !/[^a-zA-Z0-9]/.test(str);
        }
        string_1.isAlphaNumeric = isAlphaNumeric;
        ;
        /**
         * Checks if a character is a space character.
         * @param {string} ch Character to check.
         * @return {boolean} True if {@code ch} is a space.
         */
        function isSpace(ch) {
            return ch == ' ';
        }
        string_1.isSpace = isSpace;
        ;
        /**
         * Checks if a character is a valid unicode character.
         * @param {string} ch Character to check.
         * @return {boolean} True if {@code ch} is a valid unicode character.
         */
        function isUnicodeChar(ch) {
            return ch.length == 1 && ch >= ' ' && ch <= '~' ||
                ch >= '\u0080' && ch <= '\uFFFD';
        }
        string_1.isUnicodeChar = isUnicodeChar;
        ;
        /**
         * Takes a string and replaces newlines with a space. Multiple lines are
         * replaced with a single space.
         * @param {string} str The string from which to strip newlines.
         * @return {string} A copy of {@code str} stripped of newlines.
         */
        function stripNewlines(str) {
            return str.replace(/(\r\n|\r|\n)+/g, ' ');
        }
        string_1.stripNewlines = stripNewlines;
        ;
        /**
         * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
         * @param {string} str The string to in which to canonicalize newlines.
         * @return {string} {@code str} A copy of {@code} with canonicalized newlines.
         */
        function canonicalizeNewlines(str) {
            return str.replace(/(\r\n|\r|\n)/g, '\n');
        }
        string_1.canonicalizeNewlines = canonicalizeNewlines;
        ;
        /**
         * Normalizes whitespace in a string, replacing all whitespace chars with
         * a space.
         * @param {string} str The string in which to normalize whitespace.
         * @return {string} A copy of {@code str} with all whitespace normalized.
         */
        function normalizeWhitespace(str) {
            return str.replace(/\xa0|\s/g, ' ');
        }
        string_1.normalizeWhitespace = normalizeWhitespace;
        ;
        /**
         * Normalizes spaces in a string, replacing all consecutive spaces and tabs
         * with a single space. Replaces non-breaking space with a space.
         * @param {string} str The string in which to normalize spaces.
         * @return {string} A copy of {@code str} with all consecutive spaces and tabs
         *    replaced with a single space.
         */
        function normalizeSpaces(str) {
            return str.replace(/\xa0|[ \t]+/g, ' ');
        }
        string_1.normalizeSpaces = normalizeSpaces;
        ;
        /**
         * Removes the breaking spaces from the left and right of the string and
         * collapses the sequences of breaking spaces in the middle into single spaces.
         * The original and the result strings render the same way in HTML.
         * @param {string} str A string in which to collapse spaces.
         * @return {string} Copy of the string with normalized breaking spaces.
         */
        function collapseBreakingSpaces(str) {
            return str.replace(/[\t\r\n ]+/g, ' ')
                .replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
        }
        string_1.collapseBreakingSpaces = collapseBreakingSpaces;
        ;
        /**
       * Trims white spaces to the left and right of a string.
       * @param {string} str The string to trim.
       * @return {string} A trimmed copy of {@code str}.
       */
        function trim(str) {
            return (goog.TRUSTED_SITE && String.prototype.trim) ? str.trim() : /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(str)[1];
        }
        string_1.trim = trim;
        /**
         * Trims whitespaces at the left end of a string.
         * @param {string} str The string to left trim.
         * @return {string} A trimmed copy of {@code str}.
         */
        function trimLeft(str) {
            // Since IE doesn't include non-breaking-space (0xa0) in their \s character
            // class (as required by section 7.2 of the ECMAScript spec), we explicitly
            // include it in the regexp to enforce consistent cross-browser behavior.
            return str.replace(/^[\s\xa0]+/, '');
        }
        string_1.trimLeft = trimLeft;
        ;
        /**
         * Trims whitespaces at the right end of a string.
         * @param {string} str The string to right trim.
         * @return {string} A trimmed copy of {@code str}.
         */
        function trimRight(str) {
            // Since IE doesn't include non-breaking-space (0xa0) in their \s character
            // class (as required by section 7.2 of the ECMAScript spec), we explicitly
            // include it in the regexp to enforce consistent cross-browser behavior.
            return str.replace(/[\s\xa0]+$/, '');
        }
        string_1.trimRight = trimRight;
        ;
        /**
         * A string comparator that ignores case.
         * -1 = str1 less than str2
         *  0 = str1 equals str2
         *  1 = str1 greater than str2
         *
         * @param {string} str1 The string to compare.
         * @param {string} str2 The string to compare {@code str1} to.
         * @return {number} The comparator result, as described above.
         */
        function caseInsensitiveCompare(str1, str2) {
            var test1 = String(str1).toLowerCase();
            var test2 = String(str2).toLowerCase();
            if (test1 < test2) {
                return -1;
            }
            else if (test1 == test2) {
                return 0;
            }
            else {
                return 1;
            }
        }
        string_1.caseInsensitiveCompare = caseInsensitiveCompare;
        ;
        /**
         * Compares two strings interpreting their numeric substrings as numbers.
         *
         * @param {string} str1 First string.
         * @param {string} str2 Second string.
         * @param {!RegExp} tokenizerRegExp Splits a string into substrings of
         *     non-negative integers, non-numeric characters and optionally fractional
         *     numbers starting with a decimal point.
         * @return {number} Negative if str1 < str2, 0 is str1 == str2, positive if
         *     str1 > str2.
         * @private
         */
        function numberAwareCompare_(str1, str2, tokenizerRegExp) {
            if (str1 == str2) {
                return 0;
            }
            if (!str1) {
                return -1;
            }
            if (!str2) {
                return 1;
            }
            // Using match to split the entire string ahead of time turns out to be faster
            // for most inputs than using RegExp.exec or iterating over each character.
            var tokens1 = str1.toLowerCase().match(tokenizerRegExp);
            var tokens2 = str2.toLowerCase().match(tokenizerRegExp);
            var count = Math.min(tokens1.length, tokens2.length);
            for (var i = 0; i < count; i++) {
                var a = tokens1[i];
                var b = tokens2[i];
                // Compare pairs of tokens, returning if one token sorts before the other.
                if (a != b) {
                    // Only if both tokens are integers is a special comparison required.
                    // Decimal numbers are sorted as strings (e.g., '.09' < '.1').
                    var num1 = parseInt(a, 10);
                    if (!isNaN(num1)) {
                        var num2 = parseInt(b, 10);
                        if (!isNaN(num2) && num1 - num2) {
                            return num1 - num2;
                        }
                    }
                    return a < b ? -1 : 1;
                }
            }
            // If one string is a substring of the other, the shorter string sorts first.
            if (tokens1.length != tokens2.length) {
                return tokens1.length - tokens2.length;
            }
            // The two strings must be equivalent except for case (perfect equality is
            // tested at the head of the function.) Revert to default ASCII string
            // comparison to stabilize the sort.
            return str1 < str2 ? -1 : 1;
        }
        string_1.numberAwareCompare_ = numberAwareCompare_;
        ;
        /**
         * String comparison function that handles non-negative integer numbers in a
         * way humans might expect. Using this function, the string 'File 2.jpg' sorts
         * before 'File 10.jpg', and 'Version 1.9' before 'Version 1.10'. The comparison
         * is mostly case-insensitive, though strings that are identical except for case
         * are sorted with the upper-case strings before lower-case.
         *
         * This comparison function is up to 50x slower than either the default or the
         * case-insensitive compare. It should not be used in time-critical code, but
         * should be fast enough to sort several hundred short strings (like filenames)
         * with a reasonable delay.
         *
         * @param {string} str1 The string to compare in a numerically sensitive way.
         * @param {string} str2 The string to compare {@code str1} to.
         * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than
         *     0 if str1 > str2.
         */
        function intAwareCompare(str1, str2) {
            return goog.string.numberAwareCompare_(str1, str2, /\d+|\D+/g);
        }
        string_1.intAwareCompare = intAwareCompare;
        ;
        /**
         * String comparison function that handles non-negative integer and fractional
         * numbers in a way humans might expect. Using this function, the string
         * 'File 2.jpg' sorts before 'File 10.jpg', and '3.14' before '3.2'. Equivalent
         * to {@link goog.string.intAwareCompare} apart from the way how it interprets
         * dots.
         *
         * @param {string} str1 The string to compare in a numerically sensitive way.
         * @param {string} str2 The string to compare {@code str1} to.
         * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than
         *     0 if str1 > str2.
         */
        function floatAwareCompare(str1, str2) {
            return goog.string.numberAwareCompare_(str1, str2, /\d+|\.\d+|\D+/g);
        }
        string_1.floatAwareCompare = floatAwareCompare;
        ;
        /**
         * Alias for {@link goog.string.floatAwareCompare}.
         *
         * @param {string} str1
         * @param {string} str2
         * @return {number}
         */
        function numerateCompare(str1, str2) {
            return this.floatAwareCompare(str1, str2);
        }
        string_1.numerateCompare = numerateCompare;
        /**
         * URL-encodes a string
         * @param {*} str The string to url-encode.
         * @return {string} An encoded copy of {@code str} that is safe for urls.
         *     Note that '#', ':', and other characters used to delimit portions
         *     of URLs *will* be encoded.
         */
        function urlEncode(str) {
            return encodeURIComponent(String(str));
        }
        string_1.urlEncode = urlEncode;
        ;
        /**
         * URL-decodes the string. We need to specially handle '+'s because
         * the javascript library doesn't convert them to spaces.
         * @param {string} str The string to url decode.
         * @return {string} The decoded {@code str}.
         */
        function urlDecode(str) {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        }
        string_1.urlDecode = urlDecode;
        ;
        /**
         * Converts \n to <br>s or <br />s.
         * @param {string} str The string in which to convert newlines.
         * @param {boolean=} opt_xml Whether to use XML compatible tags.
         * @return {string} A copy of {@code str} with converted newlines.
         */
        function newLineToBr(str, opt_xml) {
            return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
        }
        string_1.newLineToBr = newLineToBr;
        ;
        /**
         * Escapes double quote '"' and single quote '\'' characters in addition to
         * '&', '<', and '>' so that a string can be included in an HTML tag attribute
         * value within double or single quotes.
         *
         * It should be noted that > doesn't need to be escaped for the HTML or XML to
         * be valid, but it has been decided to escape it for consistency with other
         * implementations.
         *
         * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the
         * lowercase letter "e".
         *
         * NOTE(user):
         * HtmlEscape is often called during the generation of large blocks of HTML.
         * Using statics for the regular expressions and strings is an optimization
         * that can more than half the amount of time IE spends in this function for
         * large apps, since strings and regexes both contribute to GC allocations.
         *
         * Testing for the presence of a character before escaping increases the number
         * of function calls, but actually provides a speed increase for the average
         * case -- since the average case often doesn't require the escaping of all 4
         * characters and indexOf() is much cheaper than replace().
         * The worst case does suffer slightly from the additional calls, therefore the
         * opt_isLikelyToContainHtmlChars option has been included for situations
         * where all 4 HTML entities are very likely to be present and need escaping.
         *
         * Some benchmarks (times tended to fluctuate +-0.05ms):
         *                                     FireFox                     IE6
         * (no chars / average (mix of cases) / all 4 chars)
         * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
         * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
         * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
         *
         * An additional advantage of checking if replace actually needs to be called
         * is a reduction in the number of object allocations, so as the size of the
         * application grows the difference between the various methods would increase.
         *
         * @param {string} str string to be escaped.
         * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
         *     if the character needs replacing - use this option if you expect each of
         *     the characters to appear often. Leave false if you expect few html
         *     characters to occur in your strings, such as if you are escaping HTML.
         * @return {string} An escaped copy of {@code str}.
         */
        function htmlEscape(str, opt_isLikelyToContainHtmlChars) {
            if (opt_isLikelyToContainHtmlChars) {
                str = str.replace(goog.string.AMP_RE_, '&amp;')
                    .replace(goog.string.LT_RE_, '&lt;')
                    .replace(goog.string.GT_RE_, '&gt;')
                    .replace(goog.string.QUOT_RE_, '&quot;')
                    .replace(goog.string.SINGLE_QUOTE_RE_, '&#39;')
                    .replace(goog.string.NULL_RE_, '&#0;');
                if (goog.string.DETECT_DOUBLE_ESCAPING) {
                    str = str.replace(goog.string.E_RE_, '&#101;');
                }
                return str;
            }
            else {
                // quick test helps in the case when there are no chars to replace, in
                // worst case this makes barely a difference to the time taken
                if (!goog.string.ALL_RE_.test(str))
                    return str;
                // str.indexOf is faster than regex.test in this case
                if (str.indexOf('&') != -1) {
                    str = str.replace(goog.string.AMP_RE_, '&amp;');
                }
                if (str.indexOf('<') != -1) {
                    str = str.replace(goog.string.LT_RE_, '&lt;');
                }
                if (str.indexOf('>') != -1) {
                    str = str.replace(goog.string.GT_RE_, '&gt;');
                }
                if (str.indexOf('"') != -1) {
                    str = str.replace(goog.string.QUOT_RE_, '&quot;');
                }
                if (str.indexOf('\'') != -1) {
                    str = str.replace(goog.string.SINGLE_QUOTE_RE_, '&#39;');
                }
                if (str.indexOf('\x00') != -1) {
                    str = str.replace(goog.string.NULL_RE_, '&#0;');
                }
                if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf('e') != -1) {
                    str = str.replace(goog.string.E_RE_, '&#101;');
                }
                return str;
            }
        }
        string_1.htmlEscape = htmlEscape;
        ;
        /**
     * Unescapes an HTML string.
     *
     * @param {string} str The string to unescape.
     * @return {string} An unescaped copy of {@code str}.
     */
        function unescapeEntities(str) {
            if (goog.string.contains(str, '&')) {
                // We are careful not to use a DOM if we do not have one or we explicitly
                // requested non-DOM html unescaping.
                if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING &&
                    'document' in goog.global) {
                    return goog.string.unescapeEntitiesUsingDom_(str);
                }
                else {
                    // Fall back on pure XML entities
                    return goog.string.unescapePureXmlEntities_(str);
                }
            }
            return str;
        }
        string_1.unescapeEntities = unescapeEntities;
        ;
        /**
         * Unescapes a HTML string using the provided document.
         *
         * @param {string} str The string to unescape.
         * @param {!Document} document A document to use in escaping the string.
         * @return {string} An unescaped copy of {@code str}.
         */
        function unescapeEntitiesWithDocument(str, document) {
            if (goog.string.contains(str, '&')) {
                return goog.string.unescapeEntitiesUsingDom_(str, document);
            }
            return str;
        }
        string_1.unescapeEntitiesWithDocument = unescapeEntitiesWithDocument;
        ;
        /**
         * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
         * entities. This function is XSS-safe and whitespace-preserving.
         * @private
         * @param {string} str The string to unescape.
         * @param {Document=} opt_document An optional document to use for creating
         *     elements. If this is not specified then the default window.document
         *     will be used.
         * @return {string} The unescaped {@code str} string.
         */
        function unescapeEntitiesUsingDom_(str, opt_document) {
            /** @type {!Object<string, string>} */
            var seen = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"' };
            var div;
            if (opt_document) {
                div = opt_document.createElement('div');
            }
            else {
                div = goog.global.document.createElement('div');
            }
            // Match as many valid entity characters as possible. If the actual entity
            // happens to be shorter, it will still work as innerHTML will return the
            // trailing characters unchanged. Since the entity characters do not include
            // open angle bracket, there is no chance of XSS from the innerHTML use.
            // Since no whitespace is passed to innerHTML, whitespace is preserved.
            return str.replace(goog.string.HTML_ENTITY_PATTERN_, function (s, entity) {
                // Check for cached entity.
                var value = seen[s];
                if (value) {
                    return value;
                }
                // Check for numeric entity.
                if (entity.charAt(0) == '#') {
                    // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
                    var n = Number('0' + entity.substr(1));
                    if (!isNaN(n)) {
                        value = String.fromCharCode(n);
                    }
                }
                // Fall back to innerHTML otherwise.
                if (!value) {
                    // Append a non-entity character to avoid a bug in Webkit that parses
                    // an invalid entity at the end of innerHTML text as the empty string.
                    div.innerHTML = s + ' ';
                    // Then remove the trailing character from the result.
                    value = div.firstChild.nodeValue.slice(0, -1);
                }
                // Cache and return.
                return seen[s] = value;
            });
        }
        string_1.unescapeEntitiesUsingDom_ = unescapeEntitiesUsingDom_;
        ;
        /**
         * Unescapes XML entities.
         * @private
         * @param {string} str The string to unescape.
         * @return {string} An unescaped copy of {@code str}.
         */
        function unescapePureXmlEntities_(str) {
            return str.replace(/&([^;]+);/g, function (s, entity) {
                switch (entity) {
                    case 'amp':
                        return '&';
                    case 'lt':
                        return '<';
                    case 'gt':
                        return '>';
                    case 'quot':
                        return '"';
                    default:
                        if (entity.charAt(0) == '#') {
                            // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
                            var n = Number('0' + entity.substr(1));
                            if (!isNaN(n)) {
                                return String.fromCharCode(n);
                            }
                        }
                        // For invalid entities we just return the entity
                        return s;
                }
            });
        }
        string_1.unescapePureXmlEntities_ = unescapePureXmlEntities_;
        ;
        /**
     * Do escaping of whitespace to preserve spatial formatting. We use character
     * entity #160 to make it safer for xml.
     * @param {string} str The string in which to escape whitespace.
     * @param {boolean=} opt_xml Whether to use XML compatible tags.
     * @return {string} An escaped copy of {@code str}.
     */
        function whitespaceEscape(str, opt_xml) {
            // This doesn't use goog.string.preserveSpaces for backwards compatibility.
            return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);
        }
        string_1.whitespaceEscape = whitespaceEscape;
        ;
        /**
         * Preserve spaces that would be otherwise collapsed in HTML by replacing them
         * with non-breaking space Unicode characters.
         * @param {string} str The string in which to preserve whitespace.
         * @return {string} A copy of {@code str} with preserved whitespace.
         */
        function preserveSpaces(str) {
            return str.replace(/(^|[\n ]) /g, '$1' + goog.string.Unicode.NBSP);
        }
        string_1.preserveSpaces = preserveSpaces;
        ;
        /**
         * Strip quote characters around a string.  The second argument is a string of
         * characters to treat as quotes.  This can be a single character or a string of
         * multiple character and in that case each of those are treated as possible
         * quote characters. For example:
         *
         * <pre>
         * goog.string.stripQuotes('"abc"', '"`') --> 'abc'
         * goog.string.stripQuotes('`abc`', '"`') --> 'abc'
         * </pre>
         *
         * @param {string} str The string to strip.
         * @param {string} quoteChars The quote characters to strip.
         * @return {string} A copy of {@code str} without the quotes.
         */
        function stripQuotes(str, quoteChars) {
            var length = quoteChars.length;
            for (var i = 0; i < length; i++) {
                var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
                if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
                    return str.substring(1, str.length - 1);
                }
            }
            return str;
        }
        string_1.stripQuotes = stripQuotes;
        ;
        /**
         * Truncates a string to a certain length and adds '...' if necessary.  The
         * length also accounts for the ellipsis, so a maximum length of 10 and a string
         * 'Hello World!' produces 'Hello W...'.
         * @param {string} str The string to truncate.
         * @param {number} chars Max number of characters.
         * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
         *     characters from being cut off in the middle.
         * @return {string} The truncated {@code str} string.
         */
        function truncate(str, chars, opt_protectEscapedCharacters) {
            if (opt_protectEscapedCharacters) {
                str = goog.string.unescapeEntities(str);
            }
            if (str.length > chars) {
                str = str.substring(0, chars - 3) + '...';
            }
            if (opt_protectEscapedCharacters) {
                str = goog.string.htmlEscape(str);
            }
            return str;
        }
        string_1.truncate = truncate;
        ;
        /**
         * Truncate a string in the middle, adding "..." if necessary,
         * and favoring the beginning of the string.
         * @param {string} str The string to truncate the middle of.
         * @param {number} chars Max number of characters.
         * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
         *     characters from being cutoff in the middle.
         * @param {number=} opt_trailingChars Optional number of trailing characters to
         *     leave at the end of the string, instead of truncating as close to the
         *     middle as possible.
         * @return {string} A truncated copy of {@code str}.
         */
        function truncateMiddle(str, chars, opt_protectEscapedCharacters, opt_trailingChars) {
            if (opt_protectEscapedCharacters) {
                str = goog.string.unescapeEntities(str);
            }
            if (opt_trailingChars && str.length > chars) {
                if (opt_trailingChars > chars) {
                    opt_trailingChars = chars;
                }
                var endPoint = str.length - opt_trailingChars;
                var startPoint = chars - opt_trailingChars;
                str = str.substring(0, startPoint) + '...' + str.substring(endPoint);
            }
            else if (str.length > chars) {
                // Favor the beginning of the string:
                var half = Math.floor(chars / 2);
                var endPos = str.length - half;
                half += chars % 2;
                str = str.substring(0, half) + '...' + str.substring(endPos);
            }
            if (opt_protectEscapedCharacters) {
                str = goog.string.htmlEscape(str);
            }
            return str;
        }
        string_1.truncateMiddle = truncateMiddle;
        ;
        /**
     * Encloses a string in double quotes and escapes characters so that the
     * string is a valid JS string. The resulting string is safe to embed in
     * `<script>` tags as "<" is escaped.
     * @param {string} s The string to quote.
     * @return {string} A copy of {@code s} surrounded by double quotes.
     */
        function quote(s) {
            s = String(s);
            var sb = ['"'];
            for (var i = 0; i < s.length; i++) {
                var ch = s.charAt(i);
                var cc = ch.charCodeAt(0);
                sb[i + 1] = goog.string.specialEscapeChars_[ch] ||
                    ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));
            }
            sb.push('"');
            return sb.join('');
        }
        string_1.quote = quote;
        ;
        /**
         * Takes a string and returns the escaped string for that input string.
         * @param {string} str The string to escape.
         * @return {string} An escaped string representing {@code str}.
         */
        function escapeString(str) {
            var sb = [];
            for (var i = 0; i < str.length; i++) {
                sb[i] = goog.string.escapeChar(str.charAt(i));
            }
            return sb.join('');
        }
        string_1.escapeString = escapeString;
        ;
        /**
         * Takes a character and returns the escaped string for that character. For
         * example escapeChar(String.fromCharCode(15)) -> "\\x0E".
         * @param {string} c The character to escape.
         * @return {string} An escaped string representing {@code c}.
         */
        function escapeChar(c) {
            if (c in goog.string.jsEscapeCache_) {
                return goog.string.jsEscapeCache_[c];
            }
            if (c in goog.string.specialEscapeChars_) {
                return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
            }
            var rv = c;
            var cc = c.charCodeAt(0);
            if (cc > 31 && cc < 127) {
                rv = c;
            }
            else {
                // tab is 9 but handled above
                if (cc < 256) {
                    rv = '\\x';
                    if (cc < 16 || cc > 256) {
                        rv += '0';
                    }
                }
                else {
                    rv = '\\u';
                    if (cc < 4096) {
                        rv += '0';
                    }
                }
                rv += cc.toString(16).toUpperCase();
            }
            return goog.string.jsEscapeCache_[c] = rv;
        }
        string_1.escapeChar = escapeChar;
        ;
        /**
         * Determines whether a string contains a substring.
         * @param {string} str The string to search.
         * @param {string} subString The substring to search for.
         * @return {boolean} Whether {@code str} contains {@code subString}.
         */
        function contains(str, subString) {
            return str.indexOf(subString) != -1;
        }
        string_1.contains = contains;
        ;
        /**
         * Determines whether a string contains a substring, ignoring case.
         * @param {string} str The string to search.
         * @param {string} subString The substring to search for.
         * @return {boolean} Whether {@code str} contains {@code subString}.
         */
        function caseInsensitiveContains(str, subString) {
            return goog.string.contains(str.toLowerCase(), subString.toLowerCase());
        }
        string_1.caseInsensitiveContains = caseInsensitiveContains;
        ;
        /**
         * Returns the non-overlapping occurrences of ss in s.
         * If either s or ss evalutes to false, then returns zero.
         * @param {string} s The string to look in.
         * @param {string} ss The string to look for.
         * @return {number} Number of occurrences of ss in s.
         */
        function countOf(s, ss) {
            return s && ss ? s.split(ss).length - 1 : 0;
        }
        string_1.countOf = countOf;
        ;
        /**
         * Removes a substring of a specified length at a specific
         * index in a string.
         * @param {string} s The base string from which to remove.
         * @param {number} index The index at which to remove the substring.
         * @param {number} stringLength The length of the substring to remove.
         * @return {string} A copy of {@code s} with the substring removed or the full
         *     string if nothing is removed or the input is invalid.
         */
        function removeAt(s, index, stringLength) {
            var resultStr = s;
            // If the index is greater or equal to 0 then remove substring
            if (index >= 0 && index < s.length && stringLength > 0) {
                resultStr = s.substr(0, index) +
                    s.substr(index + stringLength, s.length - index - stringLength);
            }
            return resultStr;
        }
        string_1.removeAt = removeAt;
        ;
        /**
         * Removes the first occurrence of a substring from a string.
         * @param {string} str The base string from which to remove.
         * @param {string} substr The string to remove.
         * @return {string} A copy of {@code str} with {@code substr} removed or the
         *     full string if nothing is removed.
         */
        function remove(str, substr) {
            return str.replace(substr, '');
        }
        string_1.remove = remove;
        ;
        /**
         *  Removes all occurrences of a substring from a string.
         *  @param {string} s The base string from which to remove.
         *  @param {string} ss The string to remove.
         *  @return {string} A copy of {@code s} with {@code ss} removed or the full
         *      string if nothing is removed.
         */
        function removeAll(s, ss) {
            var re = new RegExp(goog.string.regExpEscape(ss), 'g');
            return s.replace(re, '');
        }
        string_1.removeAll = removeAll;
        ;
        /**
         *  Replaces all occurrences of a substring of a string with a new substring.
         *  @param {string} s The base string from which to remove.
         *  @param {string} ss The string to replace.
         *  @param {string} replacement The replacement string.
         *  @return {string} A copy of {@code s} with {@code ss} replaced by
         *      {@code replacement} or the original string if nothing is replaced.
         */
        function replaceAll(s, ss, replacement) {
            var re = new RegExp(goog.string.regExpEscape(ss), 'g');
            return s.replace(re, replacement.replace(/\$/g, '$$$$'));
        }
        string_1.replaceAll = replaceAll;
        ;
        /**
         * Escapes characters in the string that are not safe to use in a RegExp.
         * @param {*} s The string to escape. If not a string, it will be casted
         *     to one.
         * @return {string} A RegExp safe, escaped copy of {@code s}.
         */
        function regExpEscape(s) {
            return String(s)
                .replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1')
                .replace(/\x08/g, '\\x08');
        }
        string_1.regExpEscape = regExpEscape;
        ;
        /**
         * Repeats a string n times.
         * @param {string} string The string to repeat.
         * @param {number} length The number of times to repeat.
         * @return {string} A string containing {@code length} repetitions of
         *     {@code string}.
         */
        function repeat(string, length) {
            return String.prototype.repeat ? string.repeat(length) : new Array(length + 1).join(string);
        }
        string_1.repeat = repeat;
        /**
     * Pads number to given length and optionally rounds it to a given precision.
     * For example:
     * <pre>padNumber(1.25, 2, 3) -> '01.250'
     * padNumber(1.25, 2) -> '01.25'
     * padNumber(1.25, 2, 1) -> '01.3'
     * padNumber(1.25, 0) -> '1.25'</pre>
     *
     * @param {number} num The number to pad.
     * @param {number} length The desired length.
     * @param {number=} opt_precision The desired precision.
     * @return {string} {@code num} as a string with the given options.
     */
        function padNumber(num, length, opt_precision) {
            var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
            var index = s.indexOf('.');
            if (index == -1) {
                index = s.length;
            }
            return goog.string.repeat('0', Math.max(0, length - index)) + s;
        }
        string_1.padNumber = padNumber;
        ;
        /**
         * Returns a string representation of the given object, with
         * null and undefined being returned as the empty string.
         *
         * @param {*} obj The object to convert.
         * @return {string} A string representation of the {@code obj}.
         */
        function makeSafe(obj) {
            return obj == null ? '' : String(obj);
        }
        string_1.makeSafe = makeSafe;
        ;
        /**
         * Concatenates string expressions. This is useful
         * since some browsers are very inefficient when it comes to using plus to
         * concat strings. Be careful when using null and undefined here since
         * these will not be included in the result. If you need to represent these
         * be sure to cast the argument to a String first.
         * For example:
         * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'
         * buildString(null, undefined) -> ''
         * </pre>
         * @param {...*} var_args A list of strings to concatenate. If not a string,
         *     it will be casted to one.
         * @return {string} The concatenation of {@code var_args}.
         */
        function buildString(var_args) {
            return Array.prototype.join.call(arguments, '');
        }
        string_1.buildString = buildString;
        ;
        /**
         * Returns a string with at least 64-bits of randomness.
         *
         * Doesn't trust Javascript's random function entirely. Uses a combination of
         * random and current timestamp, and then encodes the string in base-36 to
         * make it shorter.
         *
         * @return {string} A random string, e.g. sn1s7vb4gcic.
         */
        function getRandomString() {
            var x = 2147483648;
            return Math.floor(Math.random() * x).toString(36) +
                Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
        }
        string_1.getRandomString = getRandomString;
        ;
        /**
         * Compares two version numbers.
         *
         * @param {string|number} version1 Version of first item.
         * @param {string|number} version2 Version of second item.
         *
         * @return {number}  1 if {@code version1} is higher.
         *                   0 if arguments are equal.
         *                  -1 if {@code version2} is higher.
         */
        function compareVersions(version1, version2) {
            var order = 0;
            // Trim leading and trailing whitespace and split the versions into
            // subversions.
            var v1Subs = goog.string.trim(String(version1)).split('.');
            var v2Subs = goog.string.trim(String(version2)).split('.');
            var subCount = Math.max(v1Subs.length, v2Subs.length);
            // Iterate over the subversions, as long as they appear to be equivalent.
            for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
                var v1Sub = v1Subs[subIdx] || '';
                var v2Sub = v2Subs[subIdx] || '';
                do {
                    // Split the subversions into pairs of numbers and qualifiers (like 'b').
                    // Two different RegExp objects are use to make it clear the code
                    // is side-effect free
                    var v1Comp = /(\d*)(\D*)(.*)/.exec(v1Sub) || ['', '', '', ''];
                    var v2Comp = /(\d*)(\D*)(.*)/.exec(v2Sub) || ['', '', '', ''];
                    // Break if there are no more matches.
                    if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
                        break;
                    }
                    // Parse the numeric part of the subversion. A missing number is
                    // equivalent to 0.
                    var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
                    var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);
                    // Compare the subversion components. The number has the highest
                    // precedence. Next, if the numbers are equal, a subversion without any
                    // qualifier is always higher than a subversion with any qualifier. Next,
                    // the qualifiers are compared as strings.
                    order = goog.string.compareElements_(v1CompNum, v2CompNum) ||
                        goog.string.compareElements_(v1Comp[2].length == 0, v2Comp[2].length == 0) ||
                        goog.string.compareElements_(v1Comp[2], v2Comp[2]);
                    // Stop as soon as an inequality is discovered.
                    v1Sub = v1Comp[3];
                    v2Sub = v2Comp[3];
                } while (order == 0);
            }
            return order;
        }
        string_1.compareVersions = compareVersions;
        ;
        /**
         * Compares elements of a version number.
         *
         * @param {string|number|boolean} left An element from a version number.
         * @param {string|number|boolean} right An element from a version number.
         *
         * @return {number}  1 if {@code left} is higher.
         *                   0 if arguments are equal.
         *                  -1 if {@code right} is higher.
         * @private
         */
        function compareElements_(left, right) {
            if (left < right) {
                return -1;
            }
            else if (left > right) {
                return 1;
            }
            return 0;
        }
        string_1.compareElements_ = compareElements_;
        ;
        /**
         * String hash function similar to java.lang.String.hashCode().
         * The hash code for a string is computed as
         * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
         * where s[i] is the ith character of the string and n is the length of
         * the string. We mod the result to make it between 0 (inclusive) and 2^32
         * (exclusive).
         * @param {string} str A string.
         * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32
         *  (exclusive). The empty string returns 0.
         */
        function hashCode(str) {
            var result = 0;
            for (var i = 0; i < str.length; ++i) {
                // Normalize to 4 byte range, 0 ... 2^32.
                result = (31 * result + str.charCodeAt(i)) >>> 0;
            }
            return result;
        }
        string_1.hashCode = hashCode;
        ;
        /**
     * Generates and returns a string which is unique in the current document.
     * This is useful, for example, to create unique IDs for DOM elements.
     * @return {string} A unique id.
     */
        function createUniqueString() {
            return 'goog_' + goog.string.uniqueStringCounter_++;
        }
        string_1.createUniqueString = createUniqueString;
        ;
        /**
         * Converts the supplied string to a number, which may be Infinity or NaN.
         * This function strips whitespace: (toNumber(' 123') === 123)
         * This function accepts scientific notation: (toNumber('1e1') === 10)
         *
         * This is better than Javascript's built-in conversions because, sadly:
         *     (Number(' ') === 0) and (parseFloat('123a') === 123)
         *
         * @param {string} str The string to convert.
         * @return {number} The number the supplied string represents, or NaN.
         */
        function toNumber(str) {
            var num = Number(str);
            if (num == 0 && goog.string.isEmptyOrWhitespace(str)) {
                return NaN;
            }
            return num;
        }
        string_1.toNumber = toNumber;
        ;
        /**
         * Returns whether the given string is lower camel case (e.g. "isFooBar").
         *
         * Note that this assumes the string is entirely letters.
         * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
         *
         * @param {string} str String to test.
         * @return {boolean} Whether the string is lower camel case.
         */
        function isLowerCamelCase(str) {
            return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
        }
        string_1.isLowerCamelCase = isLowerCamelCase;
        ;
        /**
         * Returns whether the given string is upper camel case (e.g. "FooBarBaz").
         *
         * Note that this assumes the string is entirely letters.
         * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
         *
         * @param {string} str String to test.
         * @return {boolean} Whether the string is upper camel case.
         */
        function isUpperCamelCase(str) {
            return /^([A-Z][a-z]*)+$/.test(str);
        }
        string_1.isUpperCamelCase = isUpperCamelCase;
        ;
        /**
         * Converts a string from selector-case to camelCase (e.g. from
         * "multi-part-string" to "multiPartString"), useful for converting
         * CSS selectors and HTML dataset keys to their equivalent JS properties.
         * @param {string} str The string in selector-case form.
         * @return {string} The string in camelCase form.
         */
        function toCamelCase(str) {
            return String(str).replace(/\-([a-z])/g, function (all, match) { return match.toUpperCase(); });
        }
        string_1.toCamelCase = toCamelCase;
        ;
        /**
         * Converts a string from camelCase to selector-case (e.g. from
         * "multiPartString" to "multi-part-string"), useful for converting JS
         * style and dataset properties to equivalent CSS selectors and HTML keys.
         * @param {string} str The string in camelCase form.
         * @return {string} The string in selector-case form.
         */
        function toSelectorCase(str) {
            return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();
        }
        string_1.toSelectorCase = toSelectorCase;
        ;
        /**
         * Converts a string into TitleCase. First character of the string is always
         * capitalized in addition to the first letter of every subsequent word.
         * Words are delimited by one or more whitespaces by default. Custom delimiters
         * can optionally be specified to replace the default, which doesn't preserve
         * whitespace delimiters and instead must be explicitly included if needed.
         *
         * Default delimiter => " ":
         *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'
         *    goog.string.toTitleCase('one two three')  => 'One Two Three'
         *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '
         *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'
         *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'
         *
         * Custom delimiter => "_-.":
         *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'
         *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'
         *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '
         *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'
         *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'
         *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'
         *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'
         *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'
         *
         * @param {string} str String value in camelCase form.
         * @param {string=} opt_delimiters Custom delimiter character set used to
         *      distinguish words in the string value. Each character represents a
         *      single delimiter. When provided, default whitespace delimiter is
         *      overridden and must be explicitly included if needed.
         * @return {string} String value in TitleCase form.
         */
        function toTitleCase(str, opt_delimiters) {
            var delimiters = goog.isString(opt_delimiters) ?
                goog.string.regExpEscape(opt_delimiters) :
                '\\s';
            // For IE8, we need to prevent using an empty character set. Otherwise,
            // incorrect matching will occur.
            delimiters = delimiters ? '|[' + delimiters + ']+' : '';
            var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');
            return str.replace(regexp, function (all, p1, p2) { return p1 + p2.toUpperCase(); });
        }
        string_1.toTitleCase = toTitleCase;
        ;
        /**
         * Capitalizes a string, i.e. converts the first letter to uppercase
         * and all other letters to lowercase, e.g.:
         *
         * goog.string.capitalize('one')     => 'One'
         * goog.string.capitalize('ONE')     => 'One'
         * goog.string.capitalize('one two') => 'One two'
         *
         * Note that this function does not trim initial whitespace.
         *
         * @param {string} str String value to capitalize.
         * @return {string} String value with first letter in uppercase.
         */
        function capitalize(str) {
            return String(str.charAt(0)).toUpperCase() +
                String(str.substr(1)).toLowerCase();
        }
        string_1.capitalize = capitalize;
        ;
        /**
         * Parse a string in decimal or hexidecimal ('0xFFFF') form.
         *
         * To parse a particular radix, please use parseInt(string, radix) directly. See
         * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt
         *
         * This is a wrapper for the built-in parseInt function that will only parse
         * numbers as base 10 or base 16.  Some JS implementations assume strings
         * starting with "0" are intended to be octal. ES3 allowed but discouraged
         * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.
         *
         * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj
         *
         * @param {string|number|null|undefined} value The value to be parsed.
         * @return {number} The number, parsed. If the string failed to parse, this
         *     will be NaN.
         */
        function parseInt(value, radix) {
            // Force finite numbers to strings.
            if (isFinite(value)) {
                value = String(value);
            }
            if (goog.isString(value)) {
                // If the string starts with '0x' or '-0x', parse as hex.
                return /^\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);
            }
            return NaN;
        }
        string_1.parseInt = parseInt;
        ;
        /**
         * Splits a string on a separator a limited number of times.
         *
         * This implementation is more similar to Python or Java, where the limit
         * parameter specifies the maximum number of splits rather than truncating
         * the number of results.
         *
         * See http://docs.python.org/2/library/stdtypes.html#str.split
         * See JavaDoc: http://goo.gl/F2AsY
         * See Mozilla reference: http://goo.gl/dZdZs
         *
         * @param {string} str String to split.
         * @param {string} separator The separator.
         * @param {number} limit The limit to the number of splits. The resulting array
         *     will have a maximum length of limit+1.  Negative numbers are the same
         *     as zero.
         * @return {!Array<string>} The string, split.
         */
        function splitLimit(str, separator, limit) {
            var parts = str.split(separator);
            var returnVal = [];
            // Only continue doing this while we haven't hit the limit and we have
            // parts left.
            while (limit > 0 && parts.length) {
                returnVal.push(parts.shift());
                limit--;
            }
            // If there are remaining parts, append them to the end.
            if (parts.length) {
                returnVal.push(parts.join(separator));
            }
            return returnVal;
        }
        string_1.splitLimit = splitLimit;
        ;
        /**
         * Finds the characters to the right of the last instance of any separator
         *
         * This function is similar to goog.string.path.baseName, except it can take a
         * list of characters to split the string on. It will return the rightmost
         * grouping of characters to the right of any separator as a left-to-right
         * oriented string.
         *
         * @see goog.string.path.baseName
         * @param {string} str The string
         * @param {string|!Array<string>} separators A list of separator characters
         * @return {string} The last part of the string with respect to the separators
         */
        function lastComponent(str, separators) {
            if (!separators) {
                return str;
            }
            else if (typeof separators == 'string') {
                separators = [separators];
            }
            var lastSeparatorIndex = -1;
            for (var i = 0; i < separators.length; i++) {
                if (separators[i] == '') {
                    continue;
                }
                var currentSeparatorIndex = str.lastIndexOf(separators[i]);
                if (currentSeparatorIndex > lastSeparatorIndex) {
                    lastSeparatorIndex = currentSeparatorIndex;
                }
            }
            if (lastSeparatorIndex == -1) {
                return str;
            }
            return str.slice(lastSeparatorIndex + 1);
        }
        string_1.lastComponent = lastComponent;
        ;
        /**
         * Computes the Levenshtein edit distance between two strings.
         * @param {string} a
         * @param {string} b
         * @return {number} The edit distance between the two strings.
         */
        function editDistance(a, b) {
            var v0 = [];
            var v1 = [];
            if (a == b) {
                return 0;
            }
            if (!a.length || !b.length) {
                return Math.max(a.length, b.length);
            }
            for (var i = 0; i < b.length + 1; i++) {
                v0[i] = i;
            }
            for (var i = 0; i < a.length; i++) {
                v1[0] = i + 1;
                for (var j = 0; j < b.length; j++) {
                    var cost = Number(a[i] != b[j]);
                    // Cost for the substring is the minimum of adding one character, removing
                    // one character, or a swap.
                    v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
                }
                for (var j = 0; j < v0.length; j++) {
                    v0[j] = v1[j];
                }
            }
            return v1[b.length];
        }
        string_1.editDistance = editDistance;
        ;
    })(string = goog.string || (goog.string = {}));
})(goog || (goog = {}));
(function (goog) {
    var string;
    (function (string) {
        /**
         * Common Unicode string characters.
         * @enum {string}
         */
        string.Unicode = {
            NBSP: '\xa0'
        };
        /**
         * Regular expression that matches an ampersand, for use in escaping.
         * @const {!RegExp}
         * @private
         */
        string.AMP_RE_ = /&/g;
        /**
         * Regular expression that matches a less than sign, for use in escaping.
         * @const {!RegExp}
         * @private
         */
        string.LT_RE_ = /</g;
        /**
         * Regular expression that matches a greater than sign, for use in escaping.
         * @const {!RegExp}
         * @private
         */
        string.GT_RE_ = />/g;
        /**
         * Regular expression that matches a double quote, for use in escaping.
         * @const {!RegExp}
         * @private
         */
        string.QUOT_RE_ = /"/g;
        /**
         * Regular expression that matches a single quote, for use in escaping.
         * @const {!RegExp}
         * @private
         */
        string.SINGLE_QUOTE_RE_ = /'/g;
        /**
         * Regular expression that matches null character, for use in escaping.
         * @const {!RegExp}
         * @private
         */
        string.NULL_RE_ = /\x00/g;
        /**
         * Regular expression that matches a lowercase letter "e", for use in escaping.
         * @const {!RegExp}
         * @private
         */
        string.E_RE_ = /e/g;
        /**
         * Regular expression that matches any character that needs to be escaped.
         * @const {!RegExp}
         * @private
         */
        string.ALL_RE_ = (goog.string.DETECT_DOUBLE_ESCAPING ? /[\x00&<>"'e]/ : /[\x00&<>"']/);
        /**
         * Regular expression that matches an HTML entity.
         * See also HTML5: Tokenization / Tokenizing character references.
         * @private
         * @type {!RegExp}
         */
        string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
        /**
         * Special chars that need to be escaped for goog.string.quote.
         * @private {!Object<string, string>}
         */
        string.specialEscapeChars_ = {
            '\0': '\\0',
            '\b': '\\b',
            '\f': '\\f',
            '\n': '\\n',
            '\r': '\\r',
            '\t': '\\t',
            '\x0B': '\\x0B',
            '"': '\\"',
            '\\': '\\\\',
            // To support the use case of embedding quoted strings inside of script
            // tags, we have to make sure HTML comments and opening/closing script tags do
            // not appear in the resulting string. The specific strings that must be
            // escaped are documented at:
            // http://www.w3.org/TR/html51/semantics.html#restrictions-for-contents-of-script-elements
            '<': '\x3c'
        };
        /**
         * Character mappings used internally for goog.string.escapeChar.
         * @private {!Object<string, string>}
         */
        string.jsEscapeCache_ = {
            '\'': '\\\''
        };
        /**
         * The most recent unique ID. |0 is equivalent to Math.floor in this case.
         * @type {number}
         * @private
         */
        string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;
    })(string = goog.string || (goog.string = {}));
})(goog || (goog = {}));
/// <reference path="../base.ts" />
/// <reference path="../array/array.ts" />
/// <reference path="../asserts/asserts.ts" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Additional mathematical functions.
 */
goog.provide('goog.math');
goog.require('goog.array');
goog.require('goog.asserts');
var goog;
(function (goog) {
    var math;
    (function (math) {
        /**
         * Returns a random integer greater than or equal to 0 and less than {@code a}.
         * @param {number} a  The upper bound for the random integer (exclusive).
         * @return {number} A random integer N such that 0 <= N < a.
         */
        function randomInt(a) {
            return Math.floor(Math.random() * a);
        }
        math.randomInt = randomInt;
        ;
        /**
         * Returns a random number greater than or equal to {@code a} and less than
         * {@code b}.
         * @param {number} a  The lower bound for the random number (inclusive).
         * @param {number} b  The upper bound for the random number (exclusive).
         * @return {number} A random number N such that a <= N < b.
         */
        function uniformRandom(a, b) {
            return a + Math.random() * (b - a);
        }
        math.uniformRandom = uniformRandom;
        ;
        /**
         * Takes a number and clamps it to within the provided bounds.
         * @param {number} value The input number.
         * @param {number} min The minimum value to return.
         * @param {number} max The maximum value to return.
         * @return {number} The input number if it is within bounds, or the nearest
         *     number within the bounds.
         */
        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }
        math.clamp = clamp;
        ;
        /**
         * The % operator in JavaScript returns the remainder of a / b, but differs from
         * some other languages in that the result will have the same sign as the
         * dividend. For example, -1 % 8 == -1, whereas in some other languages
         * (such as Python) the result would be 7. This function emulates the more
         * correct modulo behavior, which is useful for certain applications such as
         * calculating an offset index in a circular list.
         *
         * @param {number} a The dividend.
         * @param {number} b The divisor.
         * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
         *     or b < x <= 0, depending on the sign of b).
         */
        function modulo(a, b) {
            var r = a % b;
            // If r and b differ in sign, add b to wrap the result to the correct sign.
            return (r * b < 0) ? r + b : r;
        }
        math.modulo = modulo;
        ;
        /**
         * Performs linear interpolation between values a and b. Returns the value
         * between a and b proportional to x (when x is between 0 and 1. When x is
         * outside this range, the return value is a linear extrapolation).
         * @param {number} a A number.
         * @param {number} b A number.
         * @param {number} x The proportion between a and b.
         * @return {number} The interpolated value between a and b.
         */
        function lerp(a, b, x) {
            return a + x * (b - a);
        }
        math.lerp = lerp;
        ;
        /**
         * Tests whether the two values are equal to each other, within a certain
         * tolerance to adjust for floating point errors.
         * @param {number} a A number.
         * @param {number} b A number.
         * @param {number=} opt_tolerance Optional tolerance range. Defaults
         *     to 0.000001. If specified, should be greater than 0.
         * @return {boolean} Whether {@code a} and {@code b} are nearly equal.
         */
        function nearlyEquals(a, b, opt_tolerance) {
            return Math.abs(a - b) <= (opt_tolerance || 0.000001);
        }
        math.nearlyEquals = nearlyEquals;
        ;
        // TODO(user): Rename to normalizeAngle, retaining old name as deprecated
        // alias.
        /**
         * Normalizes an angle to be in range [0-360). Angles outside this range will
         * be normalized to be the equivalent angle with that range.
         * @param {number} angle Angle in degrees.
         * @return {number} Standardized angle.
         */
        function standardAngle(angle) {
            return goog.math.modulo(angle, 360);
        }
        math.standardAngle = standardAngle;
        ;
        /**
         * Normalizes an angle to be in range [0-2*PI). Angles outside this range will
         * be normalized to be the equivalent angle with that range.
         * @param {number} angle Angle in radians.
         * @return {number} Standardized angle.
         */
        function standardAngleInRadians(angle) {
            return goog.math.modulo(angle, 2 * Math.PI);
        }
        math.standardAngleInRadians = standardAngleInRadians;
        ;
        /**
         * Converts degrees to radians.
         * @param {number} angleDegrees Angle in degrees.
         * @return {number} Angle in radians.
         */
        function toRadians(angleDegrees) {
            return angleDegrees * Math.PI / 180;
        }
        math.toRadians = toRadians;
        ;
        /**
         * Converts radians to degrees.
         * @param {number} angleRadians Angle in radians.
         * @return {number} Angle in degrees.
         */
        function toDegrees(angleRadians) {
            return angleRadians * 180 / Math.PI;
        }
        math.toDegrees = toDegrees;
        ;
        /**
         * For a given angle and radius, finds the X portion of the offset.
         * @param {number} degrees Angle in degrees (zero points in +X direction).
         * @param {number} radius Radius.
         * @return {number} The x-distance for the angle and radius.
         */
        function angleDx(degrees, radius) {
            return radius * Math.cos(goog.math.toRadians(degrees));
        }
        math.angleDx = angleDx;
        ;
        /**
         * For a given angle and radius, finds the Y portion of the offset.
         * @param {number} degrees Angle in degrees (zero points in +X direction).
         * @param {number} radius Radius.
         * @return {number} The y-distance for the angle and radius.
         */
        function angleDy(degrees, radius) {
            return radius * Math.sin(goog.math.toRadians(degrees));
        }
        math.angleDy = angleDy;
        ;
        /**
         * Computes the angle between two points (x1,y1) and (x2,y2).
         * Angle zero points in the +X direction, 90 degrees points in the +Y
         * direction (down) and from there we grow clockwise towards 360 degrees.
         * @param {number} x1 x of first point.
         * @param {number} y1 y of first point.
         * @param {number} x2 x of second point.
         * @param {number} y2 y of second point.
         * @return {number} Standardized angle in degrees of the vector from
         *     x1,y1 to x2,y2.
         */
        function angle(x1, y1, x2, y2) {
            return goog.math.standardAngle(goog.math.toDegrees(Math.atan2(y2 - y1, x2 - x1)));
        }
        math.angle = angle;
        ;
        /**
         * Computes the difference between startAngle and endAngle (angles in degrees).
         * @param {number} startAngle  Start angle in degrees.
         * @param {number} endAngle  End angle in degrees.
         * @return {number} The number of degrees that when added to
         *     startAngle will result in endAngle. Positive numbers mean that the
         *     direction is clockwise. Negative numbers indicate a counter-clockwise
         *     direction.
         *     The shortest route (clockwise vs counter-clockwise) between the angles
         *     is used.
         *     When the difference is 180 degrees, the function returns 180 (not -180)
         *     angleDifference(30, 40) is 10, and angleDifference(40, 30) is -10.
         *     angleDifference(350, 10) is 20, and angleDifference(10, 350) is -20.
         */
        function angleDifference(startAngle, endAngle) {
            var d = goog.math.standardAngle(endAngle) - goog.math.standardAngle(startAngle);
            if (d > 180) {
                d = d - 360;
            }
            else if (d <= -180) {
                d = 360 + d;
            }
            return d;
        }
        math.angleDifference = angleDifference;
        ;
        /**
         * Returns the sign of a number as per the "sign" or "signum" function.
         * @param {number} x The number to take the sign of.
         * @return {number} -1 when negative, 1 when positive, 0 when 0. Preserves
         *     signed zeros and NaN.
         */
        function sign(x) {
            if (x > 0) {
                return 1;
            }
            if (x < 0) {
                return -1;
            }
            return x;
        }
        math.sign = sign;
        ;
        /**
         * JavaScript implementation of Longest Common Subsequence problem.
         * http://en.wikipedia.org/wiki/Longest_common_subsequence
         *
         * Returns the longest possible array that is subarray of both of given arrays.
         *
         * @param {IArrayLike<S>} array1 First array of objects.
         * @param {IArrayLike<T>} array2 Second array of objects.
         * @param {Function=} opt_compareFn Function that acts as a custom comparator
         *     for the array ojects. Function should return true if objects are equal,
         *     otherwise false.
         * @param {Function=} opt_collectorFn Function used to decide what to return
         *     as a result subsequence. It accepts 2 arguments: index of common element
         *     in the first array and index in the second. The default function returns
         *     element from the first array.
         * @return {!Array<S|T>} A list of objects that are common to both arrays
         *     such that there is no common subsequence with size greater than the
         *     length of the list.
         * @template S,T
         */
        function longestCommonSubsequence(array1, array2, opt_compareFn, opt_collectorFn) {
            var compare = opt_compareFn || function (a, b) { return a == b; };
            var collect = opt_collectorFn || function (i1, i2) { return array1[i1]; };
            var length1 = array1.length;
            var length2 = array2.length;
            var arr = [];
            for (var i = 0; i < length1 + 1; i++) {
                arr[i] = [];
                arr[i][0] = 0;
            }
            for (var j = 0; j < length2 + 1; j++) {
                arr[0][j] = 0;
            }
            for (i = 1; i <= length1; i++) {
                for (j = 1; j <= length2; j++) {
                    if (compare(array1[i - 1], array2[j - 1])) {
                        arr[i][j] = arr[i - 1][j - 1] + 1;
                    }
                    else {
                        arr[i][j] = Math.max(arr[i - 1][j], arr[i][j - 1]);
                    }
                }
            }
            // Backtracking
            var result = [];
            var i = length1, j = length2;
            while (i > 0 && j > 0) {
                if (compare(array1[i - 1], array2[j - 1])) {
                    result.unshift(collect(i - 1, j - 1));
                    i--;
                    j--;
                }
                else {
                    if (arr[i - 1][j] > arr[i][j - 1]) {
                        i--;
                    }
                    else {
                        j--;
                    }
                }
            }
            return result;
        }
        math.longestCommonSubsequence = longestCommonSubsequence;
        ;
        /**
         * Returns the sum of the arguments.
         * @param {...number} var_args Numbers to add.
         * @return {number} The sum of the arguments (0 if no arguments were provided,
         *     {@code NaN} if any of the arguments is not a valid number).
         */
        function sum(var_args) {
            return /** @type {number} */ (goog.array.reduce(arguments, function (sum, value) { return sum + value; }, 0));
        }
        math.sum = sum;
        ;
        /**
         * Returns the arithmetic mean of the arguments.
         * @param {...number} var_args Numbers to average.
         * @return {number} The average of the arguments ({@code NaN} if no arguments
         *     were provided or any of the arguments is not a valid number).
         */
        function average(var_args) {
            return goog.math.sum.apply(null, arguments) / arguments.length;
        }
        math.average = average;
        ;
        /**
         * Returns the unbiased sample variance of the arguments. For a definition,
         * see e.g. http://en.wikipedia.org/wiki/Variance
         * @param {...number} var_args Number samples to analyze.
         * @return {number} The unbiased sample variance of the arguments (0 if fewer
         *     than two samples were provided, or {@code NaN} if any of the samples is
         *     not a valid number).
         */
        function sampleVariance(var_args) {
            var sampleSize = arguments.length;
            if (sampleSize < 2) {
                return 0;
            }
            var mean = goog.math.average.apply(null, arguments);
            var variance = goog.math.sum.apply(null, goog.array.map(arguments, function (val) {
                return Math.pow(val - mean, 2);
            })) / (sampleSize - 1);
            return variance;
        }
        math.sampleVariance = sampleVariance;
        ;
        /**
         * Returns the sample standard deviation of the arguments.  For a definition of
         * sample standard deviation, see e.g.
         * http://en.wikipedia.org/wiki/Standard_deviation
         * @param {...number} var_args Number samples to analyze.
         * @return {number} The sample standard deviation of the arguments (0 if fewer
         *     than two samples were provided, or {@code NaN} if any of the samples is
         *     not a valid number).
         */
        function standardDeviation(var_args) {
            return Math.sqrt(goog.math.sampleVariance.apply(null, arguments));
        }
        math.standardDeviation = standardDeviation;
        ;
        /**
         * Returns whether the supplied number represents an integer, i.e. that is has
         * no fractional component.  No range-checking is performed on the number.
         * @param {number} num The number to test.
         * @return {boolean} Whether {@code num} is an integer.
         */
        function isInt(num) {
            return isFinite(num) && num % 1 == 0;
        }
        math.isInt = isInt;
        ;
        /**
         * Returns whether the supplied number is finite and not NaN.
         * @param {number} num The number to test.
         * @return {boolean} Whether {@code num} is a finite number.
         * @deprecated Use {@link isFinite} instead.
         */
        function isFiniteNumber(num) {
            return isFinite(num);
        }
        math.isFiniteNumber = isFiniteNumber;
        ;
        /**
         * @param {number} num The number to test.
         * @return {boolean} Whether it is negative zero.
         */
        function isNegativeZero(num) {
            return num == 0 && 1 / num < 0;
        }
        math.isNegativeZero = isNegativeZero;
        ;
        /**
         * Returns the precise value of floor(log10(num)).
         * Simpler implementations didn't work because of floating point rounding
         * errors. For example
         * <ul>
         * <li>Math.floor(Math.log(num) / Math.LN10) is off by one for num == 1e+3.
         * <li>Math.floor(Math.log(num) * Math.LOG10E) is off by one for num == 1e+15.
         * <li>Math.floor(Math.log10(num)) is off by one for num == 1e+15 - 1.
         * </ul>
         * @param {number} num A floating point number.
         * @return {number} Its logarithm to base 10 rounded down to the nearest
         *     integer if num > 0. -Infinity if num == 0. NaN if num < 0.
         */
        function log10Floor(num) {
            if (num > 0) {
                var x = Math.round(Math.log(num) * Math.LOG10E);
                return x - (parseFloat('1e' + x) > num ? 1 : 0);
            }
            return num == 0 ? -Infinity : NaN;
        }
        math.log10Floor = log10Floor;
        ;
        /**
         * A tweaked variant of {@code Math.floor} which tolerates if the passed number
         * is infinitesimally smaller than the closest integer. It often happens with
         * the results of floating point calculations because of the finite precision
         * of the intermediate results. For example {@code Math.floor(Math.log(1000) /
         * Math.LN10) == 2}, not 3 as one would expect.
         * @param {number} num A number.
         * @param {number=} opt_epsilon An infinitesimally small positive number, the
         *     rounding error to tolerate.
         * @return {number} The largest integer less than or equal to {@code num}.
         */
        function safeFloor(num, opt_epsilon) {
            goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
            return Math.floor(num + (opt_epsilon || 2e-15));
        }
        math.safeFloor = safeFloor;
        ;
        /**
         * A tweaked variant of {@code Math.ceil}. See {@code goog.math.safeFloor} for
         * details.
         * @param {number} num A number.
         * @param {number=} opt_epsilon An infinitesimally small positive number, the
         *     rounding error to tolerate.
         * @return {number} The smallest integer greater than or equal to {@code num}.
         */
        function safeCeil(num, opt_epsilon) {
            goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
            return Math.ceil(num - (opt_epsilon || 2e-15));
        }
        math.safeCeil = safeCeil;
        ;
    })(math = goog.math || (goog.math = {}));
})(goog || (goog = {}));
/// <reference path="./math.ts" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A utility class for representing two-dimensional positions.
 */
goog.provide('goog.math.Coordinate');
goog.require('goog.math');
var goog;
(function (goog) {
    var math;
    (function (math) {
        var Coordinate = /** @class */ (function () {
            /**
             * Class for representing coordinates and positions.
             * @param {number=} opt_x Left, defaults to 0.
             * @param {number=} opt_y Top, defaults to 0.
             * @struct
             * @constructor
             */
            function Coordinate(opt_x, opt_y) {
                /**
                 * X-value
                 * @type {number}
                 */
                this.x = goog.isDef(opt_x) ? opt_x : 0;
                /**
                 * Y-value
                 * @type {number}
                 */
                this.y = goog.isDef(opt_y) ? opt_y : 0;
            }
            /**
             * Returns a new copy of the coordinate.
             * @return {!goog.math.Coordinate} A clone of this coordinate.
             */
            Coordinate.prototype.clone = function () {
                return new goog.math.Coordinate(this.x, this.y);
            };
            ;
            /**
             * Returns a nice string representing the coordinate.
             * @return {string} In the form (50, 73).
             * @override
             */
            Coordinate.prototype.toString = function () {
                return '(' + this.x + ', ' + this.y + ')';
            };
            ;
            /**
             * Returns whether the specified value is equal to this coordinate.
             * @param {*} other Some other value.
             * @return {boolean} Whether the specified value is equal to this coordinate.
             */
            Coordinate.prototype.equals = function (other) {
                return other instanceof goog.math.Coordinate &&
                    goog.math.Coordinate.equals(this, other);
            };
            ;
            /**
             * Rounds the x and y fields to the next larger integer values.
             * @return {!goog.math.Coordinate} This coordinate with ceil'd fields.
             */
            Coordinate.prototype.ceil = function () {
                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                return this;
            };
            ;
            /**
             * Rounds the x and y fields to the next smaller integer values.
             * @return {!goog.math.Coordinate} This coordinate with floored fields.
             */
            Coordinate.prototype.floor = function () {
                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
                return this;
            };
            ;
            /**
             * Rounds the x and y fields to the nearest integer values.
             * @return {!goog.math.Coordinate} This coordinate with rounded fields.
             */
            Coordinate.prototype.round = function () {
                this.x = Math.round(this.x);
                this.y = Math.round(this.y);
                return this;
            };
            ;
            /**
             * Translates this box by the given offsets. If a {@code goog.math.Coordinate}
             * is given, then the x and y values are translated by the coordinate's x and y.
             * Otherwise, x and y are translated by {@code tx} and {@code opt_ty}
             * respectively.
             * @param {number|goog.math.Coordinate} tx The value to translate x by or the
             *     the coordinate to translate this coordinate by.
             * @param {number=} opt_ty The value to translate y by.
             * @return {!goog.math.Coordinate} This coordinate after translating.
             */
            Coordinate.prototype.translate = function (tx, opt_ty) {
                if (tx instanceof goog.math.Coordinate) {
                    this.x += tx.x;
                    this.y += tx.y;
                }
                else {
                    this.x += Number(tx);
                    if (goog.isNumber(opt_ty)) {
                        this.y += opt_ty;
                    }
                }
                return this;
            };
            ;
            /**
             * Scales this coordinate by the given scale factors. The x and y values are
             * scaled by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy}
             * is not given, then {@code sx} is used for both x and y.
             * @param {number} sx The scale factor to use for the x dimension.
             * @param {number=} opt_sy The scale factor to use for the y dimension.
             * @return {!goog.math.Coordinate} This coordinate after scaling.
             */
            Coordinate.prototype.scale = function (sx, opt_sy) {
                var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
                this.x *= sx;
                this.y *= sy;
                return this;
            };
            ;
            /**
             * Rotates this coordinate clockwise about the origin (or, optionally, the given
             * center) by the given angle, in radians.
             * @param {number} radians The angle by which to rotate this coordinate
             *     clockwise about the given center, in radians.
             * @param {!goog.math.Coordinate=} opt_center The center of rotation. Defaults
             *     to (0, 0) if not given.
             */
            Coordinate.prototype.rotateRadians = function (radians, opt_center) {
                var center = opt_center || new goog.math.Coordinate(0, 0);
                var x = this.x;
                var y = this.y;
                var cos = Math.cos(radians);
                var sin = Math.sin(radians);
                this.x = (x - center.x) * cos - (y - center.y) * sin + center.x;
                this.y = (x - center.x) * sin + (y - center.y) * cos + center.y;
            };
            ;
            /**
             * Rotates this coordinate clockwise about the origin (or, optionally, the given
             * center) by the given angle, in degrees.
             * @param {number} degrees The angle by which to rotate this coordinate
             *     clockwise about the given center, in degrees.
             * @param {!goog.math.Coordinate=} opt_center The center of rotation. Defaults
             *     to (0, 0) if not given.
             */
            Coordinate.prototype.rotateDegrees = function (degrees, opt_center) {
                this.rotateRadians(goog.math.toRadians(degrees), opt_center);
            };
            ;
            return Coordinate;
        }());
        math.Coordinate = Coordinate;
    })(math = goog.math || (goog.math = {}));
})(goog || (goog = {}));
(function (goog) {
    var math;
    (function (math) {
        var Coordinate;
        (function (Coordinate) {
            /**
             * Compares coordinates for equality.
             * @param {goog.math.Coordinate} a A Coordinate.
             * @param {goog.math.Coordinate} b A Coordinate.
             * @return {boolean} True iff the coordinates are equal, or if both are null.
             */
            function equals(a, b) {
                if (a == b) {
                    return true;
                }
                if (!a || !b) {
                    return false;
                }
                return a.x == b.x && a.y == b.y;
            }
            Coordinate.equals = equals;
            ;
            /**
             * Returns the distance between two coordinates.
             * @param {!goog.math.Coordinate} a A Coordinate.
             * @param {!goog.math.Coordinate} b A Coordinate.
             * @return {number} The distance between {@code a} and {@code b}.
             */
            function distance(a, b) {
                var dx = a.x - b.x;
                var dy = a.y - b.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            Coordinate.distance = distance;
            ;
            /**
             * Returns the magnitude of a coordinate.
             * @param {!goog.math.Coordinate} a A Coordinate.
             * @return {number} The distance between the origin and {@code a}.
             */
            function magnitude(a) {
                return Math.sqrt(a.x * a.x + a.y * a.y);
            }
            Coordinate.magnitude = magnitude;
            ;
            /**
             * Returns the angle from the origin to a coordinate.
             * @param {!goog.math.Coordinate} a A Coordinate.
             * @return {number} The angle, in degrees, clockwise from the positive X
             *     axis to {@code a}.
             */
            function azimuth(a) {
                return goog.math.angle(0, 0, a.x, a.y);
            }
            Coordinate.azimuth = azimuth;
            ;
            /**
             * Returns the squared distance between two coordinates. Squared distances can
             * be used for comparisons when the actual value is not required.
             *
             * Performance note: eliminating the square root is an optimization often used
             * in lower-level languages, but the speed difference is not nearly as
             * pronounced in JavaScript (only a few percent.)
             *
             * @param {!goog.math.Coordinate} a A Coordinate.
             * @param {!goog.math.Coordinate} b A Coordinate.
             * @return {number} The squared distance between {@code a} and {@code b}.
             */
            function squaredDistance(a, b) {
                var dx = a.x - b.x;
                var dy = a.y - b.y;
                return dx * dx + dy * dy;
            }
            Coordinate.squaredDistance = squaredDistance;
            ;
            /**
             * Returns the difference between two coordinates as a new
             * goog.math.Coordinate.
             * @param {!goog.math.Coordinate} a A Coordinate.
             * @param {!goog.math.Coordinate} b A Coordinate.
             * @return {!goog.math.Coordinate} A Coordinate representing the difference
             *     between {@code a} and {@code b}.
             */
            function difference(a, b) {
                return new goog.math.Coordinate(a.x - b.x, a.y - b.y);
            }
            Coordinate.difference = difference;
            ;
            /**
             * Returns the sum of two coordinates as a new goog.math.Coordinate.
             * @param {!goog.math.Coordinate} a A Coordinate.
             * @param {!goog.math.Coordinate} b A Coordinate.
             * @return {!goog.math.Coordinate} A Coordinate representing the sum of the two
             *     coordinates.
             */
            function sum(a, b) {
                return new goog.math.Coordinate(a.x + b.x, a.y + b.y);
            }
            Coordinate.sum = sum;
            ;
        })(Coordinate = math.Coordinate || (math.Coordinate = {}));
    })(math = goog.math || (goog.math = {}));
})(goog || (goog = {}));
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A utility class for representing two-dimensional sizes.
 * @author brenneman@google.com (Shawn Brenneman)
 */
goog.provide('goog.math.Size');
var goog;
(function (goog) {
    var math;
    (function (math) {
        var Size = /** @class */ (function () {
            /**
             * Class for representing sizes consisting of a width and height. Undefined
             * width and height support is deprecated and results in compiler warning.
             * @param {number} width Width.
             * @param {number} height Height.
             * @struct
             * @constructor
             */
            function Size(width, height) {
                /**
                 * Width
                 * @type {number}
                 */
                this.width = width;
                /**
                 * Height
                 * @type {number}
                 */
                this.height = height;
            }
            /**
             * @return {!goog.math.Size} A new copy of the Size.
             */
            Size.prototype.clone = function () {
                return new goog.math.Size(this.width, this.height);
            };
            ;
            // if (goog.DEBUG) {
            /**
             * Returns a nice string representing size.
             * @return {string} In the form (50 x 73).
             * @override
             */
            Size.prototype.toString = function () {
                return '(' + this.width + ' x ' + this.height + ')';
            };
            ;
            // }
            /**
             * @return {number} The longer of the two dimensions in the size.
             */
            Size.prototype.getLongest = function () {
                return Math.max(this.width, this.height);
            };
            ;
            /**
             * @return {number} The shorter of the two dimensions in the size.
             */
            Size.prototype.getShortest = function () {
                return Math.min(this.width, this.height);
            };
            ;
            /**
             * @return {number} The area of the size (width * height).
             */
            Size.prototype.area = function () {
                return this.width * this.height;
            };
            ;
            /**
             * @return {number} The perimeter of the size (width + height) * 2.
             */
            Size.prototype.perimeter = function () {
                return (this.width + this.height) * 2;
            };
            ;
            /**
             * @return {number} The ratio of the size's width to its height.
             */
            Size.prototype.aspectRatio = function () {
                return this.width / this.height;
            };
            ;
            /**
             * @return {boolean} True if the size has zero area, false if both dimensions
             *     are non-zero numbers.
             */
            Size.prototype.isEmpty = function () {
                return !this.area();
            };
            ;
            /**
             * Clamps the width and height parameters upward to integer values.
             * @return {!goog.math.Size} This size with ceil'd components.
             */
            Size.prototype.ceil = function () {
                this.width = Math.ceil(this.width);
                this.height = Math.ceil(this.height);
                return this;
            };
            ;
            /**
             * @param {!goog.math.Size} target The target size.
             * @return {boolean} True if this Size is the same size or smaller than the
             *     target size in both dimensions.
             */
            Size.prototype.fitsInside = function (target) {
                return this.width <= target.width && this.height <= target.height;
            };
            ;
            /**
             * Clamps the width and height parameters downward to integer values.
             * @return {!goog.math.Size} This size with floored components.
             */
            Size.prototype.floor = function () {
                this.width = Math.floor(this.width);
                this.height = Math.floor(this.height);
                return this;
            };
            ;
            /**
             * Rounds the width and height parameters to integer values.
             * @return {!goog.math.Size} This size with rounded components.
             */
            Size.prototype.round = function () {
                this.width = Math.round(this.width);
                this.height = Math.round(this.height);
                return this;
            };
            ;
            /**
             * Scales this size by the given scale factors. The width and height are scaled
             * by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy} is not
             * given, then {@code sx} is used for both the width and height.
             * @param {number} sx The scale factor to use for the width.
             * @param {number=} opt_sy The scale factor to use for the height.
             * @return {!goog.math.Size} This Size object after scaling.
             */
            Size.prototype.scale = function (sx, opt_sy) {
                var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
                this.width *= sx;
                this.height *= sy;
                return this;
            };
            ;
            /**
             * Uniformly scales the size to perfectly cover the dimensions of a given size.
             * If the size is already larger than the target, it will be scaled down to the
             * minimum size at which it still covers the entire target. The original aspect
             * ratio will be preserved.
             *
             * This function assumes that both Sizes contain strictly positive dimensions.
             * @param {!goog.math.Size} target The target size.
             * @return {!goog.math.Size} This Size object, after optional scaling.
             */
            Size.prototype.scaleToCover = function (target) {
                var s = this.aspectRatio() <= target.aspectRatio() ?
                    target.width / this.width :
                    target.height / this.height;
                return this.scale(s);
            };
            ;
            /**
             * Uniformly scales the size to fit inside the dimensions of a given size. The
             * original aspect ratio will be preserved.
             *
             * This function assumes that both Sizes contain strictly positive dimensions.
             * @param {!goog.math.Size} target The target size.
             * @return {!goog.math.Size} This Size object, after optional scaling.
             */
            Size.prototype.scaleToFit = function (target) {
                var s = this.aspectRatio() > target.aspectRatio() ?
                    target.width / this.width :
                    target.height / this.height;
                return this.scale(s);
            };
            ;
            return Size;
        }());
        math.Size = Size;
    })(math = goog.math || (goog.math = {}));
})(goog || (goog = {}));
(function (goog) {
    var math;
    (function (math) {
        var Size;
        (function (Size) {
            /**
             * Compares sizes for equality.
             * @param {goog.math.Size} a A Size.
             * @param {goog.math.Size} b A Size.
             * @return {boolean} True iff the sizes have equal widths and equal
             *     heights, or if both are null.
             */
            function equals(a, b) {
                if (a == b) {
                    return true;
                }
                if (!a || !b) {
                    return false;
                }
                return a.width == b.width && a.height == b.height;
            }
            Size.equals = equals;
        })(Size = math.Size || (math.Size = {}));
    })(math = goog.math || (goog.math = {}));
})(goog || (goog = {}));
/// <reference path="../../base.ts" />
/// <reference path="../../string/string.ts" />
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utilities used by goog.labs.userAgent tools. These functions
 * should not be used outside of goog.labs.userAgent.*.
 *
 *
 * @author nnaze@google.com (Nathan Naze)
 */
goog.provide('goog.labs.userAgent.util');
goog.require('goog.string');
var goog;
(function (goog) {
    var labs;
    (function (labs) {
        var userAgent;
        (function (userAgent_1) {
            var util;
            (function (util) {
                /**
                 * Gets the native userAgent string from navigator if it exists.
                 * If navigator or navigator.userAgent string is missing, returns an empty
                 * string.
                 * @return {string}
                 * @private
                 */
                function getNativeUserAgentString_() {
                    var navigator = goog.labs.userAgent.util.getNavigator_();
                    if (navigator) {
                        var userAgent = navigator.userAgent;
                        if (userAgent) {
                            return userAgent;
                        }
                    }
                    return '';
                }
                util.getNativeUserAgentString_ = getNativeUserAgentString_;
                ;
                /**
                 * Getter for the native navigator.
                 * This is a separate function so it can be stubbed out in testing.
                 * @return {Navigator}
                 * @private
                 */
                function getNavigator_() {
                    return goog.global.navigator;
                }
                util.getNavigator_ = getNavigator_;
                ;
                /**
                 * A possible override for applications which wish to not check
                 * navigator.userAgent but use a specified value for detection instead.
                 * @private {string}
                 */
                util.userAgent_ = goog.labs.userAgent.util.getNativeUserAgentString_();
                /**
                 * Applications may override browser detection on the built in
                 * navigator.userAgent object by setting this string. Set to null to use the
                 * browser object instead.
                 * @param {?string=} opt_userAgent The User-Agent override.
                 */
                function setUserAgent(opt_userAgent) {
                    goog.labs.userAgent.util.userAgent_ =
                        opt_userAgent || goog.labs.userAgent.util.getNativeUserAgentString_();
                }
                util.setUserAgent = setUserAgent;
                ;
                /**
                 * @return {string} The user agent string.
                 */
                function getUserAgent() {
                    return goog.labs.userAgent.util.userAgent_;
                }
                util.getUserAgent = getUserAgent;
                ;
                /**
                 * @param {string} str
                 * @return {boolean} Whether the user agent contains the given string.
                 */
                function matchUserAgent(str) {
                    var userAgent = goog.labs.userAgent.util.getUserAgent();
                    return goog.string.contains(userAgent, str);
                }
                util.matchUserAgent = matchUserAgent;
                ;
                /**
                 * @param {string} str
                 * @return {boolean} Whether the user agent contains the given string, ignoring
                 *     case.
                 */
                function matchUserAgentIgnoreCase(str) {
                    var userAgent = goog.labs.userAgent.util.getUserAgent();
                    return goog.string.caseInsensitiveContains(userAgent, str);
                }
                util.matchUserAgentIgnoreCase = matchUserAgentIgnoreCase;
                ;
                /**
                 * Parses the user agent into tuples for each section.
                 * @param {string} userAgent
                 * @return {!Array<!Array<string>>} Tuples of key, version, and the contents
                 *     of the parenthetical.
                 */
                function extractVersionTuples(userAgent) {
                    // Matches each section of a user agent string.
                    // Example UA:
                    // Mozilla/5.0 (iPad; U; CPU OS 3_2_1 like Mac OS X; en-us)
                    // AppleWebKit/531.21.10 (KHTML, like Gecko) Mobile/7B405
                    // This has three version tuples: Mozilla, AppleWebKit, and Mobile.
                    var versionRegExp = new RegExp(
                    // Key. Note that a key may have a space.
                    // (i.e. 'Mobile Safari' in 'Mobile Safari/5.0')
                    '(\\w[\\w ]+)' +
                        '/' + // slash
                        '([^\\s]+)' + // version (i.e. '5.0b')
                        '\\s*' + // whitespace
                        '(?:\\((.*?)\\))?', // parenthetical info. parentheses not matched.
                    'g');
                    var data = [];
                    var match;
                    // Iterate and collect the version tuples.  Each iteration will be the
                    // next regex match.
                    while (match = versionRegExp.exec(userAgent)) {
                        data.push([
                            match[1],
                            match[2],
                            // || undefined as this is not undefined in IE7 and IE8
                            match[3] || undefined // info
                        ]);
                    }
                    return data;
                }
                util.extractVersionTuples = extractVersionTuples;
                ;
            })(util = userAgent_1.util || (userAgent_1.util = {}));
        })(userAgent = labs.userAgent || (labs.userAgent = {}));
    })(labs = goog.labs || (goog.labs = {}));
})(goog || (goog = {}));
/// <reference path="../base.ts" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utilities for manipulating objects/maps/hashes.
 * @author arv@google.com (Erik Arvidsson)
 */
goog.provide('goog.object');
var goog;
(function (goog) {
    var object;
    (function (object) {
        /**
         * Whether two values are not observably distinguishable. This
         * correctly detects that 0 is not the same as -0 and two NaNs are
         * practically equivalent.
         *
         * The implementation is as suggested by harmony:egal proposal.
         *
         * @param {*} v The first value to compare.
         * @param {*} v2 The second value to compare.
         * @return {boolean} Whether two values are not observably distinguishable.
         * @see http://wiki.ecmascript.org/doku.php?id=harmony:egal
         */
        function is(v, v2) {
            if (v === v2) {
                // 0 === -0, but they are not identical.
                // We need the cast because the compiler requires that v2 is a
                // number (although 1/v2 works with non-number). We cast to ? to
                // stop the compiler from type-checking this statement.
                return v !== 0 || 1 / v === 1 / /** @type {?} */ (v2);
            }
            // NaN is non-reflexive: NaN !== NaN, although they are identical.
            return v !== v && v2 !== v2;
        }
        object.is = is;
        ;
        /**
         * Calls a function for each element in an object/map/hash.
         *
         * @param {Object<K,V>} obj The object over which to iterate.
         * @param {function(this:T,V,?,Object<K,V>):?} f The function to call
         *     for every element. This function takes 3 arguments (the value, the
         *     key and the object) and the return value is ignored.
         * @param {T=} opt_obj This is used as the 'this' object within f.
         * @template T,K,V
         */
        function forEach(obj, f, opt_obj) {
            for (var key in obj) {
                f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);
            }
        }
        object.forEach = forEach;
        ;
        /**
         * Calls a function for each element in an object/map/hash. If that call returns
         * true, adds the element to a new object.
         *
         * @param {Object<K,V>} obj The object over which to iterate.
         * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to call
         *     for every element. This
         *     function takes 3 arguments (the value, the key and the object)
         *     and should return a boolean. If the return value is true the
         *     element is added to the result object. If it is false the
         *     element is not included.
         * @param {T=} opt_obj This is used as the 'this' object within f.
         * @return {!Object<K,V>} a new object in which only elements that passed the
         *     test are present.
         * @template T,K,V
         */
        function filter(obj, f, opt_obj) {
            var res = {};
            for (var key in obj) {
                if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {
                    res[key] = obj[key];
                }
            }
            return res;
        }
        object.filter = filter;
        ;
        /**
         * For every element in an object/map/hash calls a function and inserts the
         * result into a new object.
         *
         * @param {Object<K,V>} obj The object over which to iterate.
         * @param {function(this:T,V,?,Object<K,V>):R} f The function to call
         *     for every element. This function
         *     takes 3 arguments (the value, the key and the object)
         *     and should return something. The result will be inserted
         *     into a new object.
         * @param {T=} opt_obj This is used as the 'this' object within f.
         * @return {!Object<K,R>} a new object with the results from f.
         * @template T,K,V,R
         */
        function map(obj, f, opt_obj) {
            var res = {};
            for (var key in obj) {
                res[key] = f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);
            }
            return res;
        }
        object.map = map;
        ;
        /**
         * Calls a function for each element in an object/map/hash. If any
         * call returns true, returns true (without checking the rest). If
         * all calls return false, returns false.
         *
         * @param {Object<K,V>} obj The object to check.
         * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to
         *     call for every element. This function
         *     takes 3 arguments (the value, the key and the object) and should
         *     return a boolean.
         * @param {T=} opt_obj This is used as the 'this' object within f.
         * @return {boolean} true if any element passes the test.
         * @template T,K,V
         */
        function some(obj, f, opt_obj) {
            for (var key in obj) {
                if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {
                    return true;
                }
            }
            return false;
        }
        object.some = some;
        ;
        /**
         * Calls a function for each element in an object/map/hash. If
         * all calls return true, returns true. If any call returns false, returns
         * false at this point and does not continue to check the remaining elements.
         *
         * @param {Object<K,V>} obj The object to check.
         * @param {?function(this:T,V,?,Object<K,V>):boolean} f The function to
         *     call for every element. This function
         *     takes 3 arguments (the value, the key and the object) and should
         *     return a boolean.
         * @param {T=} opt_obj This is used as the 'this' object within f.
         * @return {boolean} false if any element fails the test.
         * @template T,K,V
         */
        function every(obj, f, opt_obj) {
            for (var key in obj) {
                if (!f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {
                    return false;
                }
            }
            return true;
        }
        object.every = every;
        ;
        /**
         * Returns the number of key-value pairs in the object map.
         *
         * @param {Object} obj The object for which to get the number of key-value
         *     pairs.
         * @return {number} The number of key-value pairs in the object map.
         */
        function getCount(obj) {
            var rv = 0;
            for (var key in obj) {
                rv++;
            }
            return rv;
        }
        object.getCount = getCount;
        ;
        /**
         * Returns one key from the object map, if any exists.
         * For map literals the returned key will be the first one in most of the
         * browsers (a know exception is Konqueror).
         *
         * @param {Object} obj The object to pick a key from.
         * @return {string|undefined} The key or undefined if the object is empty.
         */
        function getAnyKey(obj) {
            for (var key in obj) {
                return key;
            }
        }
        object.getAnyKey = getAnyKey;
        ;
        /**
         * Returns one value from the object map, if any exists.
         * For map literals the returned value will be the first one in most of the
         * browsers (a know exception is Konqueror).
         *
         * @param {Object<K,V>} obj The object to pick a value from.
         * @return {V|undefined} The value or undefined if the object is empty.
         * @template K,V
         */
        function getAnyValue(obj) {
            for (var key in obj) {
                return obj[key];
            }
        }
        object.getAnyValue = getAnyValue;
        ;
        /**
         * Whether the object/hash/map contains the given object as a value.
         * An alias for goog.object.containsValue(obj, val).
         *
         * @param {Object<K,V>} obj The object in which to look for val.
         * @param {V} val The object for which to check.
         * @return {boolean} true if val is present.
         * @template K,V
         */
        function contains(obj, val) {
            return goog.object.containsValue(obj, val);
        }
        object.contains = contains;
        ;
        /**
         * Returns the values of the object/map/hash.
         *
         * @param {Object<K,V>} obj The object from which to get the values.
         * @return {!Array<V>} The values in the object/map/hash.
         * @template K,V
         */
        function getValues(obj) {
            var res = [];
            var i = 0;
            for (var key in obj) {
                res[i++] = obj[key];
            }
            return res;
        }
        object.getValues = getValues;
        ;
        /**
         * Returns the keys of the object/map/hash.
         *
         * @param {Object} obj The object from which to get the keys.
         * @return {!Array<string>} Array of property keys.
         */
        function getKeys(obj) {
            var res = [];
            var i = 0;
            for (var key in obj) {
                res[i++] = key;
            }
            return res;
        }
        object.getKeys = getKeys;
        ;
        /**
         * Get a value from an object multiple levels deep.  This is useful for
         * pulling values from deeply nested objects, such as JSON responses.
         * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)
         *
         * @param {!Object} obj An object to get the value from.  Can be array-like.
         * @param {...(string|number|!IArrayLike<number|string>)}
         *     var_args A number of keys
         *     (as strings, or numbers, for array-like objects).  Can also be
         *     specified as a single array of keys.
         * @return {*} The resulting value.  If, at any point, the value for a key
         *     in the current object is null or undefined, returns undefined.
         */
        function getValueByKeys(obj) {
            var var_args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                var_args[_i - 1] = arguments[_i];
            }
            var isArrayLike = goog.isArrayLike(var_args);
            var keys = isArrayLike ? var_args : arguments;
            // Start with the 2nd parameter for the variable parameters syntax.
            for (var i = isArrayLike ? 0 : 1; i < keys.length; i++) {
                if (obj == null)
                    return undefined;
                obj = obj[keys[i]];
            }
            return obj;
        }
        object.getValueByKeys = getValueByKeys;
        ;
        /**
         * Whether the object/map/hash contains the given key.
         *
         * @param {Object} obj The object in which to look for key.
         * @param {?} key The key for which to check.
         * @return {boolean} true If the map contains the key.
         */
        function containsKey(obj, key) {
            return obj !== null && key in obj;
        }
        object.containsKey = containsKey;
        ;
        /**
         * Whether the object/map/hash contains the given value. This is O(n).
         *
         * @param {Object<K,V>} obj The object in which to look for val.
         * @param {V} val The value for which to check.
         * @return {boolean} true If the map contains the value.
         * @template K,V
         */
        function containsValue(obj, val) {
            for (var key in obj) {
                if (obj[key] == val) {
                    return true;
                }
            }
            return false;
        }
        object.containsValue = containsValue;
        ;
        /**
         * Searches an object for an element that satisfies the given condition and
         * returns its key.
         * @param {Object<K,V>} obj The object to search in.
         * @param {function(this:T,V,string,Object<K,V>):boolean} f The
         *      function to call for every element. Takes 3 arguments (the value,
         *     the key and the object) and should return a boolean.
         * @param {T=} opt_this An optional "this" context for the function.
         * @return {string|undefined} The key of an element for which the function
         *     returns true or undefined if no such element is found.
         * @template T,K,V
         */
        function findKey(obj, f, opt_this) {
            for (var key in obj) {
                if (f.call(/** @type {?} */ (opt_this), obj[key], key, obj)) {
                    return key;
                }
            }
            return undefined;
        }
        object.findKey = findKey;
        ;
        /**
         * Searches an object for an element that satisfies the given condition and
         * returns its value.
         * @param {Object<K,V>} obj The object to search in.
         * @param {function(this:T,V,string,Object<K,V>):boolean} f The function
         *     to call for every element. Takes 3 arguments (the value, the key
         *     and the object) and should return a boolean.
         * @param {T=} opt_this An optional "this" context for the function.
         * @return {V} The value of an element for which the function returns true or
         *     undefined if no such element is found.
         * @template T,K,V
         */
        function findValue(obj, f, opt_this) {
            var key = goog.object.findKey(obj, f, opt_this);
            return key && obj[key];
        }
        object.findValue = findValue;
        ;
        /**
         * Whether the object/map/hash is empty.
         *
         * @param {Object} obj The object to test.
         * @return {boolean} true if obj is empty.
         */
        function isEmpty(obj) {
            for (var key in obj) {
                return false;
            }
            return true;
        }
        object.isEmpty = isEmpty;
        ;
        /**
         * Removes all key value pairs from the object/map/hash.
         *
         * @param {Object} obj The object to clear.
         */
        function clear(obj) {
            for (var i in obj) {
                delete obj[i];
            }
        }
        object.clear = clear;
        ;
        /**
         * Removes a key-value pair based on the key.
         *
         * @param {Object} obj The object from which to remove the key.
         * @param {?} key The key to remove.
         * @return {boolean} Whether an element was removed.
         */
        function remove(obj, key) {
            var rv;
            if (rv = key in /** @type {!Object} */ (obj)) {
                delete obj[key];
            }
            return rv;
        }
        object.remove = remove;
        ;
        /**
         * Adds a key-value pair to the object. Throws an exception if the key is
         * already in use. Use set if you want to change an existing pair.
         *
         * @param {Object<K,V>} obj The object to which to add the key-value pair.
         * @param {string} key The key to add.
         * @param {V} val The value to add.
         * @template K,V
         */
        function add(obj, key, val) {
            if (obj !== null && key in obj) {
                throw new Error('The object already contains the key "' + key + '"');
            }
            goog.object.set(obj, key, val);
        }
        object.add = add;
        ;
        /**
         * Returns the value for the given key.
         *
         * @param {Object<K,V>} obj The object from which to get the value.
         * @param {string} key The key for which to get the value.
         * @param {R=} opt_val The value to return if no item is found for the given
         *     key (default is undefined).
         * @return {V|R|undefined} The value for the given key.
         * @template K,V,R
         */
        function get(obj, key, opt_val) {
            if (obj !== null && key in obj) {
                return obj[key];
            }
            return opt_val;
        }
        object.get = get;
        ;
        /**
         * Adds a key-value pair to the object/map/hash.
         *
         * @param {Object<K,V>} obj The object to which to add the key-value pair.
         * @param {string} key The key to add.
         * @param {V} value The value to add.
         * @template K,V
         */
        function set(obj, key, value) {
            obj[key] = value;
        }
        object.set = set;
        ;
        /**
         * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
         *
         * @param {Object<K,V>} obj The object to which to add the key-value pair.
         * @param {string} key The key to add.
         * @param {V} value The value to add if the key wasn't present.
         * @return {V} The value of the entry at the end of the function.
         * @template K,V
         */
        function setIfUndefined(obj, key, value) {
            return key in /** @type {!Object} */ (obj) ? obj[key] : (obj[key] = value);
        }
        object.setIfUndefined = setIfUndefined;
        ;
        /**
         * Sets a key and value to an object if the key is not set. The value will be
         * the return value of the given function. If the key already exists, the
         * object will not be changed and the function will not be called (the function
         * will be lazily evaluated -- only called if necessary).
         *
         * This function is particularly useful for use with a map used a as a cache.
         *
         * @param {!Object<K,V>} obj The object to which to add the key-value pair.
         * @param {string} key The key to add.
         * @param {function():V} f The value to add if the key wasn't present.
         * @return {V} The value of the entry at the end of the function.
         * @template K,V
         */
        function setWithReturnValueIfNotSet(obj, key, f) {
            if (key in obj) {
                return obj[key];
            }
            var val = f();
            obj[key] = val;
            return val;
        }
        object.setWithReturnValueIfNotSet = setWithReturnValueIfNotSet;
        ;
        /**
         * Compares two objects for equality using === on the values.
         *
         * @param {!Object<K,V>} a
         * @param {!Object<K,V>} b
         * @return {boolean}
         * @template K,V
         */
        function equals(a, b) {
            for (var k in a) {
                if (!(k in b) || a[k] !== b[k]) {
                    return false;
                }
            }
            for (var k in b) {
                if (!(k in a)) {
                    return false;
                }
            }
            return true;
        }
        object.equals = equals;
        ;
        /**
         * Returns a shallow clone of the object.
         *
         * @param {Object<K,V>} obj Object to clone.
         * @return {!Object<K,V>} Clone of the input object.
         * @template K,V
         */
        function clone(obj) {
            // We cannot use the prototype trick because a lot of methods depend on where
            // the actual key is set.
            var res = {};
            for (var key in obj) {
                res[key] = obj[key];
            }
            return res;
            // We could also use goog.mixin but I wanted this to be independent from that.
        }
        object.clone = clone;
        ;
        /**
         * Clones a value. The input may be an Object, Array, or basic type. Objects and
         * arrays will be cloned recursively.
         *
         * WARNINGS:
         * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects
         * that refer to themselves will cause infinite recursion.
         *
         * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and
         * copies UIDs created by <code>getUid</code> into cloned results.
         *
         * @param {T} obj The value to clone.
         * @return {T} A clone of the input value.
         * @template T
         */
        function unsafeClone(obj) {
            var type = goog.typeOf(obj);
            if (type == 'object' || type == 'array') {
                if (goog.isFunction(obj.clone)) {
                    return obj.clone();
                }
                var clone = type == 'array' ? [] : {};
                for (var key in obj) {
                    clone[key] = goog.object.unsafeClone(obj[key]);
                }
                return clone;
            }
            return obj;
        }
        object.unsafeClone = unsafeClone;
        ;
        /**
         * Returns a new object in which all the keys and values are interchanged
         * (keys become values and values become keys). If multiple keys map to the
         * same value, the chosen transposed value is implementation-dependent.
         *
         * @param {Object} obj The object to transpose.
         * @return {!Object} The transposed object.
         */
        function transpose(obj) {
            var transposed = {};
            for (var key in obj) {
                transposed[obj[key]] = key;
            }
            return transposed;
        }
        object.transpose = transpose;
        ;
        /**
         * The names of the fields that are defined on Object.prototype.
         * @type {Array<string>}
         * @private
         */
        object.PROTOTYPE_FIELDS_ = [
            'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
            'toLocaleString', 'toString', 'valueOf'
        ];
        /**
         * Extends an object with another object.
         * This operates 'in-place'; it does not create a new Object.
         *
         * Example:
         * var o = {};
         * goog.object.extend(o, {a: 0, b: 1});
         * o; // {a: 0, b: 1}
         * goog.object.extend(o, {b: 2, c: 3});
         * o; // {a: 0, b: 2, c: 3}
         *
         * @param {Object} target The object to modify. Existing properties will be
         *     overwritten if they are also present in one of the objects in
         *     {@code var_args}.
         * @param {...Object} var_args The objects from which values will be copied.
         */
        function extend(target, var_args) {
            var key, source;
            for (var i = 1; i < arguments.length; i++) {
                source = arguments[i];
                for (key in source) {
                    target[key] = source[key];
                }
                // For IE the for-in-loop does not contain any properties that are not
                // enumerable on the prototype object (for example isPrototypeOf from
                // Object.prototype) and it will also not include 'replace' on objects that
                // extend String and change 'replace' (not that it is common for anyone to
                // extend anything except Object).
                for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {
                    key = goog.object.PROTOTYPE_FIELDS_[j];
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                        target[key] = source[key];
                    }
                }
            }
        }
        object.extend = extend;
        ;
        /**
         * Creates a new object built from the key-value pairs provided as arguments.
         * @param {...*} var_args If only one argument is provided and it is an array
         *     then this is used as the arguments, otherwise even arguments are used as
         *     the property names and odd arguments are used as the property values.
         * @return {!Object} The new object.
         * @throws {Error} If there are uneven number of arguments or there is only one
         *     non array argument.
         */
        function create() {
            var var_args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                var_args[_i] = arguments[_i];
            }
            var argLength = arguments.length;
            if (argLength == 1 && goog.isArray(arguments[0])) {
                return goog.object.create.apply(null, arguments[0]);
            }
            if (argLength % 2) {
                throw new Error('Uneven number of arguments');
            }
            var rv = {};
            for (var i = 0; i < argLength; i += 2) {
                rv[arguments[i]] = arguments[i + 1];
            }
            return rv;
        }
        object.create = create;
        ;
        /**
         * Creates a new object where the property names come from the arguments but
         * the value is always set to true
         * @param {...*} var_args If only one argument is provided and it is an array
         *     then this is used as the arguments, otherwise the arguments are used
         *     as the property names.
         * @return {!Object} The new object.
         */
        function createSet() {
            var var_args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                var_args[_i] = arguments[_i];
            }
            var argLength = arguments.length;
            if (argLength == 1 && goog.isArray(arguments[0])) {
                return goog.object.createSet.apply(null, arguments[0]);
            }
            var rv = {};
            for (var i = 0; i < argLength; i++) {
                rv[arguments[i]] = true;
            }
            return rv;
        }
        object.createSet = createSet;
        ;
        /**
         * Creates an immutable view of the underlying object, if the browser
         * supports immutable objects.
         *
         * In default mode, writes to this view will fail silently. In strict mode,
         * they will throw an error.
         *
         * @param {!Object<K,V>} obj An object.
         * @return {!Object<K,V>} An immutable view of that object, or the
         *     original object if this browser does not support immutables.
         * @template K,V
         */
        function createImmutableView(obj) {
            var result = obj;
            if (Object.isFrozen && !Object.isFrozen(obj)) {
                result = Object.create(obj);
                Object.freeze(result);
            }
            return result;
        }
        object.createImmutableView = createImmutableView;
        ;
        /**
         * @param {!Object} obj An object.
         * @return {boolean} Whether this is an immutable view of the object.
         */
        function isImmutableView(obj) {
            return !!Object.isFrozen && Object.isFrozen(obj);
        }
        object.isImmutableView = isImmutableView;
        ;
        /**
         * Get all properties names on a given Object regardless of enumerability.
         *
         * <p> If the browser does not support {@code Object.getOwnPropertyNames} nor
         * {@code Object.getPrototypeOf} then this is equivalent to using {@code
         * goog.object.getKeys}
         *
         * @param {?Object} obj The object to get the properties of.
         * @param {boolean=} opt_includeObjectPrototype Whether properties defined on
         *     {@code Object.prototype} should be included in the result.
         * @param {boolean=} opt_includeFunctionPrototype Whether properties defined on
         *     {@code Function.prototype} should be included in the result.
         * @return {!Array<string>}
         * @public
         */
        function getAllPropertyNames(obj, opt_includeObjectPrototype, opt_includeFunctionPrototype) {
            if (!obj) {
                return [];
            }
            // Naively use a for..in loop to get the property names if the browser doesn't
            // support any other APIs for getting it.
            if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {
                return goog.object.getKeys(obj);
            }
            var visitedSet = {};
            // Traverse the prototype chain and add all properties to the visited set.
            var proto = obj;
            while (proto &&
                (proto !== Object.prototype || !!opt_includeObjectPrototype) &&
                (proto !== Function.prototype || !!opt_includeFunctionPrototype)) {
                var names = Object.getOwnPropertyNames(proto);
                for (var i = 0; i < names.length; i++) {
                    visitedSet[names[i]] = true;
                }
                proto = Object.getPrototypeOf(proto);
            }
            return goog.object.getKeys(visitedSet);
        }
        object.getAllPropertyNames = getAllPropertyNames;
        ;
    })(object = goog.object || (goog.object = {}));
})(goog || (goog = {}));
/// <reference path="../../array/array.ts" />
/// <reference path="./util.ts" />
/// <reference path="../../object/object" />
/// <reference path="../../string/string" />
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Closure user agent detection (Browser).
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For more information on rendering engine, platform, or device see the other
 * sub-namespaces in goog.labs.userAgent, goog.labs.userAgent.platform,
 * goog.labs.userAgent.device respectively.)
 *
 * @author martone@google.com (Andy Martone)
 */
goog.provide('goog.labs.userAgent.browser');
goog.require('goog.array');
goog.require('goog.labs.userAgent.util');
goog.require('goog.object');
goog.require('goog.string');
var goog;
(function (goog) {
    var labs;
    (function (labs) {
        var userAgent;
        (function (userAgent_2) {
            var browser;
            (function (browser) {
                // TODO(nnaze): Refactor to remove excessive exclusion logic in matching
                // functions.
                /**
                 * @return {boolean} Whether the user's browser is Opera.  Note: Chromium
                 *     based Opera (Opera 15+) is detected as Chrome to avoid unnecessary
                 *     special casing.
                 * @private
                 */
                function matchOpera_() {
                    return goog.labs.userAgent.util.matchUserAgent('Opera');
                }
                browser.matchOpera_ = matchOpera_;
                ;
                /**
                 * @return {boolean} Whether the user's browser is IE.
                 * @private
                 */
                function matchIE_() {
                    return goog.labs.userAgent.util.matchUserAgent('Trident') ||
                        goog.labs.userAgent.util.matchUserAgent('MSIE');
                }
                browser.matchIE_ = matchIE_;
                ;
                /**
                 * @return {boolean} Whether the user's browser is Edge.
                 * @private
                 */
                function matchEdge_() {
                    return goog.labs.userAgent.util.matchUserAgent('Edge');
                }
                browser.matchEdge_ = matchEdge_;
                ;
                /**
                 * @return {boolean} Whether the user's browser is Firefox.
                 * @private
                 */
                function matchFirefox_() {
                    return goog.labs.userAgent.util.matchUserAgent('Firefox');
                }
                browser.matchFirefox_ = matchFirefox_;
                ;
                /**
                 * @return {boolean} Whether the user's browser is Safari.
                 * @private
                 */
                function matchSafari_() {
                    return goog.labs.userAgent.util.matchUserAgent('Safari') &&
                        !(goog.labs.userAgent.browser.matchChrome_() ||
                            goog.labs.userAgent.browser.matchCoast_() ||
                            goog.labs.userAgent.browser.matchOpera_() ||
                            goog.labs.userAgent.browser.matchEdge_() ||
                            goog.labs.userAgent.browser.isSilk() ||
                            goog.labs.userAgent.util.matchUserAgent('Android'));
                }
                browser.matchSafari_ = matchSafari_;
                ;
                /**
                 * @return {boolean} Whether the user's browser is Coast (Opera's Webkit-based
                 *     iOS browser).
                 * @private
                 */
                function matchCoast_() {
                    return goog.labs.userAgent.util.matchUserAgent('Coast');
                }
                browser.matchCoast_ = matchCoast_;
                ;
                /**
                 * @return {boolean} Whether the user's browser is iOS Webview.
                 * @private
                 */
                function matchIosWebview_() {
                    // iOS Webview does not show up as Chrome or Safari. Also check for Opera's
                    // WebKit-based iOS browser, Coast.
                    return (goog.labs.userAgent.util.matchUserAgent('iPad') ||
                        goog.labs.userAgent.util.matchUserAgent('iPhone')) &&
                        !goog.labs.userAgent.browser.matchSafari_() &&
                        !goog.labs.userAgent.browser.matchChrome_() &&
                        !goog.labs.userAgent.browser.matchCoast_() &&
                        goog.labs.userAgent.util.matchUserAgent('AppleWebKit');
                }
                browser.matchIosWebview_ = matchIosWebview_;
                ;
                /**
                 * @return {boolean} Whether the user's browser is Chrome.
                 * @private
                 */
                function matchChrome_() {
                    return (goog.labs.userAgent.util.matchUserAgent('Chrome') ||
                        goog.labs.userAgent.util.matchUserAgent('CriOS')) &&
                        !goog.labs.userAgent.browser.matchEdge_();
                }
                browser.matchChrome_ = matchChrome_;
                ;
                /**
                 * @return {boolean} Whether the user's browser is the Android browser.
                 * @private
                 */
                function matchAndroidBrowser_() {
                    // Android can appear in the user agent string for Chrome on Android.
                    // This is not the Android standalone browser if it does.
                    return goog.labs.userAgent.util.matchUserAgent('Android') &&
                        !(goog.labs.userAgent.browser.isChrome() ||
                            goog.labs.userAgent.browser.isFirefox() ||
                            goog.labs.userAgent.browser.isOpera() ||
                            goog.labs.userAgent.browser.isSilk());
                }
                browser.matchAndroidBrowser_ = matchAndroidBrowser_;
                ;
                /**
                 * @return {boolean} Whether the user's browser is Opera.
                 */
                browser.isOpera = goog.labs.userAgent.browser.matchOpera_;
                /**
                 * @return {boolean} Whether the user's browser is IE.
                 */
                browser.isIE = goog.labs.userAgent.browser.matchIE_;
                /**
                 * @return {boolean} Whether the user's browser is Edge.
                 */
                browser.isEdge = goog.labs.userAgent.browser.matchEdge_;
                /**
                 * @return {boolean} Whether the user's browser is Firefox.
                 */
                browser.isFirefox = goog.labs.userAgent.browser.matchFirefox_;
                /**
                 * @return {boolean} Whether the user's browser is Safari.
                 */
                browser.isSafari = goog.labs.userAgent.browser.matchSafari_;
                /**
                 * @return {boolean} Whether the user's browser is Coast (Opera's Webkit-based
                 *     iOS browser).
                 */
                browser.isCoast = goog.labs.userAgent.browser.matchCoast_;
                /**
                 * @return {boolean} Whether the user's browser is iOS Webview.
                 */
                browser.isIosWebview = goog.labs.userAgent.browser.matchIosWebview_;
                /**
                 * @return {boolean} Whether the user's browser is Chrome.
                 */
                browser.isChrome = goog.labs.userAgent.browser.matchChrome_;
                /**
                 * @return {boolean} Whether the user's browser is the Android browser.
                 */
                browser.isAndroidBrowser = goog.labs.userAgent.browser.matchAndroidBrowser_;
                /**
                 * For more information, see:
                 * http://docs.aws.amazon.com/silk/latest/developerguide/user-agent.html
                 * @return {boolean} Whether the user's browser is Silk.
                 */
                function isSilk() {
                    return goog.labs.userAgent.util.matchUserAgent('Silk');
                }
                browser.isSilk = isSilk;
                ;
                /**
                 * @return {string} The browser version or empty string if version cannot be
                 *     determined. Note that for Internet Explorer, this returns the version of
                 *     the browser, not the version of the rendering engine. (IE 8 in
                 *     compatibility mode will return 8.0 rather than 7.0. To determine the
                 *     rendering engine version, look at document.documentMode instead. See
                 *     http://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx for more
                 *     details.)
                 */
                function getVersion() {
                    var userAgentString = goog.labs.userAgent.util.getUserAgent();
                    // Special case IE since IE's version is inside the parenthesis and
                    // without the '/'.
                    if (goog.labs.userAgent.browser.isIE()) {
                        return goog.labs.userAgent.browser.getIEVersion_(userAgentString);
                    }
                    var versionTuples = goog.labs.userAgent.util.extractVersionTuples(userAgentString);
                    // Construct a map for easy lookup.
                    var versionMap = {};
                    goog.array.forEach(versionTuples, function (tuple) {
                        // Note that the tuple is of length three, but we only care about the
                        // first two.
                        var key = tuple[0];
                        var value = tuple[1];
                        versionMap[key] = value;
                    });
                    var versionMapHasKey = goog.partial(goog.object.containsKey, versionMap);
                    // Gives the value with the first key it finds, otherwise empty string.
                    function lookUpValueWithKeys(keys) {
                        var key = goog.array.find(keys, versionMapHasKey);
                        return versionMap[key] || '';
                    }
                    // Check Opera before Chrome since Opera 15+ has "Chrome" in the string.
                    // See
                    // http://my.opera.com/ODIN/blog/2013/07/15/opera-user-agent-strings-opera-15-and-beyond
                    if (goog.labs.userAgent.browser.isOpera()) {
                        // Opera 10 has Version/10.0 but Opera/9.8, so look for "Version" first.
                        // Opera uses 'OPR' for more recent UAs.
                        return lookUpValueWithKeys(['Version', 'Opera']);
                    }
                    // Check Edge before Chrome since it has Chrome in the string.
                    if (goog.labs.userAgent.browser.isEdge()) {
                        return lookUpValueWithKeys(['Edge']);
                    }
                    if (goog.labs.userAgent.browser.isChrome()) {
                        return lookUpValueWithKeys(['Chrome', 'CriOS']);
                    }
                    // Usually products browser versions are in the third tuple after "Mozilla"
                    // and the engine.
                    var tuple = versionTuples[2];
                    return tuple && tuple[1] || '';
                }
                browser.getVersion = getVersion;
                ;
                /**
                 * @param {string|number} version The version to check.
                 * @return {boolean} Whether the browser version is higher or the same as the
                 *     given version.
                 */
                function isVersionOrHigher(version) {
                    return goog.string.compareVersions(goog.labs.userAgent.browser.getVersion(), version) >= 0;
                }
                browser.isVersionOrHigher = isVersionOrHigher;
                ;
                /**
                 * Determines IE version. More information:
                 * http://msdn.microsoft.com/en-us/library/ie/bg182625(v=vs.85).aspx#uaString
                 * http://msdn.microsoft.com/en-us/library/hh869301(v=vs.85).aspx
                 * http://blogs.msdn.com/b/ie/archive/2010/03/23/introducing-ie9-s-user-agent-string.aspx
                 * http://blogs.msdn.com/b/ie/archive/2009/01/09/the-internet-explorer-8-user-agent-string-updated-edition.aspx
                 *
                 * @param {string} userAgent the User-Agent.
                 * @return {string}
                 * @private
                 */
                function getIEVersion_(userAgent) {
                    // IE11 may identify itself as MSIE 9.0 or MSIE 10.0 due to an IE 11 upgrade
                    // bug. Example UA:
                    // Mozilla/5.0 (MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; rv:11.0)
                    // like Gecko.
                    // See http://www.whatismybrowser.com/developers/unknown-user-agent-fragments.
                    var rv = /rv: *([\d\.]*)/.exec(userAgent);
                    if (rv && rv[1]) {
                        return rv[1];
                    }
                    var version = '';
                    var msie = /MSIE +([\d\.]+)/.exec(userAgent);
                    if (msie && msie[1]) {
                        // IE in compatibility mode usually identifies itself as MSIE 7.0; in this
                        // case, use the Trident version to determine the version of IE. For more
                        // details, see the links above.
                        var tridentVersion = /Trident\/(\d.\d)/.exec(userAgent);
                        if (msie[1] == '7.0') {
                            if (tridentVersion && tridentVersion[1]) {
                                switch (tridentVersion[1]) {
                                    case '4.0':
                                        version = '8.0';
                                        break;
                                    case '5.0':
                                        version = '9.0';
                                        break;
                                    case '6.0':
                                        version = '10.0';
                                        break;
                                    case '7.0':
                                        version = '11.0';
                                        break;
                                }
                            }
                            else {
                                version = '7.0';
                            }
                        }
                        else {
                            version = msie[1];
                        }
                    }
                    return version;
                }
                browser.getIEVersion_ = getIEVersion_;
                ;
            })(browser = userAgent_2.browser || (userAgent_2.browser = {}));
        })(userAgent = labs.userAgent || (labs.userAgent = {}));
    })(labs = goog.labs || (goog.labs = {}));
})(goog || (goog = {}));
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Closure user agent detection.
 * @see http://en.wikipedia.org/wiki/User_agent
 * For more information on browser brand, platform, or device see the other
 * sub-namespaces in goog.labs.userAgent (browser, platform, and device).
 *
 */
goog.provide('goog.labs.userAgent.engine');
goog.require('goog.array');
goog.require('goog.labs.userAgent.util');
goog.require('goog.string');
var goog;
(function (goog) {
    var labs;
    (function (labs) {
        var userAgent;
        (function (userAgent) {
            var engine;
            (function (engine) {
                /**
                 * @return {boolean} Whether the rendering engine is Presto.
                 */
                function isPresto() {
                    return goog.labs.userAgent.util.matchUserAgent('Presto');
                }
                engine.isPresto = isPresto;
                ;
                /**
                 * @return {boolean} Whether the rendering engine is Trident.
                 */
                function isTrident() {
                    // IE only started including the Trident token in IE8.
                    return goog.labs.userAgent.util.matchUserAgent('Trident') ||
                        goog.labs.userAgent.util.matchUserAgent('MSIE');
                }
                engine.isTrident = isTrident;
                ;
                /**
                 * @return {boolean} Whether the rendering engine is Edge.
                 */
                function isEdge() {
                    return goog.labs.userAgent.util.matchUserAgent('Edge');
                }
                engine.isEdge = isEdge;
                ;
                /**
                 * @return {boolean} Whether the rendering engine is WebKit.
                 */
                function isWebKit() {
                    return goog.labs.userAgent.util.matchUserAgentIgnoreCase('WebKit') &&
                        !goog.labs.userAgent.engine.isEdge();
                }
                engine.isWebKit = isWebKit;
                ;
                /**
                 * @return {boolean} Whether the rendering engine is Gecko.
                 */
                function isGecko() {
                    return goog.labs.userAgent.util.matchUserAgent('Gecko') &&
                        !goog.labs.userAgent.engine.isWebKit() &&
                        !goog.labs.userAgent.engine.isTrident() &&
                        !goog.labs.userAgent.engine.isEdge();
                }
                engine.isGecko = isGecko;
                ;
                /**
                 * @return {string} The rendering engine's version or empty string if version
                 *     can't be determined.
                 */
                function getVersion() {
                    var userAgentString = goog.labs.userAgent.util.getUserAgent();
                    if (userAgentString) {
                        var tuples = goog.labs.userAgent.util.extractVersionTuples(userAgentString);
                        var engineTuple = goog.labs.userAgent.engine.getEngineTuple_(tuples);
                        if (engineTuple) {
                            // In Gecko, the version string is either in the browser info or the
                            // Firefox version.  See Gecko user agent string reference:
                            // http://goo.gl/mULqa
                            if (engineTuple[0] == 'Gecko') {
                                return goog.labs.userAgent.engine.getVersionForKey_(tuples, 'Firefox');
                            }
                            return engineTuple[1];
                        }
                        // MSIE has only one version identifier, and the Trident version is
                        // specified in the parenthetical. IE Edge is covered in the engine tuple
                        // detection.
                        var browserTuple = tuples[0];
                        var info;
                        if (browserTuple && (info = browserTuple[2])) {
                            var match = /Trident\/([^\s;]+)/.exec(info);
                            if (match) {
                                return match[1];
                            }
                        }
                    }
                    return '';
                }
                engine.getVersion = getVersion;
                ;
                /**
                 * @param {!Array<!Array<string>>} tuples Extracted version tuples.
                 * @return {!Array<string>|undefined} The engine tuple or undefined if not
                 *     found.
                 * @private
                 */
                function getEngineTuple_(tuples) {
                    if (!goog.labs.userAgent.engine.isEdge()) {
                        return tuples[1];
                    }
                    for (var i = 0; i < tuples.length; i++) {
                        var tuple = tuples[i];
                        if (tuple[0] == 'Edge') {
                            return tuple;
                        }
                    }
                }
                engine.getEngineTuple_ = getEngineTuple_;
                ;
                /**
                 * @param {string|number} version The version to check.
                 * @return {boolean} Whether the rendering engine version is higher or the same
                 *     as the given version.
                 */
                function isVersionOrHigher(version) {
                    return goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(), version) >= 0;
                }
                engine.isVersionOrHigher = isVersionOrHigher;
                ;
                /**
                 * @param {!Array<!Array<string>>} tuples Version tuples.
                 * @param {string} key The key to look for.
                 * @return {string} The version string of the given key, if present.
                 *     Otherwise, the empty string.
                 * @private
                 */
                function getVersionForKey_(tuples, key) {
                    // TODO(nnaze): Move to util if useful elsewhere.
                    var pair = goog.array.find(tuples, function (pair) { return key == pair[0]; });
                    return pair && pair[1] || '';
                }
                engine.getVersionForKey_ = getVersionForKey_;
                ;
            })(engine = userAgent.engine || (userAgent.engine = {}));
        })(userAgent = labs.userAgent || (labs.userAgent = {}));
    })(labs = goog.labs || (goog.labs = {}));
})(goog || (goog = {}));
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Closure user agent platform detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For more information on browser brand, rendering engine, or device see the
 * other sub-namespaces in goog.labs.userAgent (browser, engine, and device
 * respectively).
 *
 */
goog.provide('goog.labs.userAgent.platform');
goog.require('goog.labs.userAgent.util');
goog.require('goog.string');
var goog;
(function (goog) {
    var labs;
    (function (labs) {
        var userAgent;
        (function (userAgent) {
            var platform;
            (function (platform) {
                /**
                 * @return {boolean} Whether the platform is Android.
                 */
                function isAndroid() {
                    return goog.labs.userAgent.util.matchUserAgent('Android');
                }
                platform.isAndroid = isAndroid;
                ;
                /**
                 * @return {boolean} Whether the platform is iPod.
                 */
                function isIpod() {
                    return goog.labs.userAgent.util.matchUserAgent('iPod');
                }
                platform.isIpod = isIpod;
                ;
                /**
                 * @return {boolean} Whether the platform is iPhone.
                 */
                function isIphone() {
                    return goog.labs.userAgent.util.matchUserAgent('iPhone') &&
                        !goog.labs.userAgent.util.matchUserAgent('iPod') &&
                        !goog.labs.userAgent.util.matchUserAgent('iPad');
                }
                platform.isIphone = isIphone;
                ;
                /**
                 * @return {boolean} Whether the platform is iPad.
                 */
                function isIpad() {
                    return goog.labs.userAgent.util.matchUserAgent('iPad');
                }
                platform.isIpad = isIpad;
                ;
                /**
                 * @return {boolean} Whether the platform is iOS.
                 */
                function isIos() {
                    return goog.labs.userAgent.platform.isIphone() ||
                        goog.labs.userAgent.platform.isIpad() ||
                        goog.labs.userAgent.platform.isIpod();
                }
                platform.isIos = isIos;
                ;
                /**
                 * @return {boolean} Whether the platform is Mac.
                 */
                function isMacintosh() {
                    return goog.labs.userAgent.util.matchUserAgent('Macintosh');
                }
                platform.isMacintosh = isMacintosh;
                ;
                /**
                 * Note: ChromeOS is not considered to be Linux as it does not report itself
                 * as Linux in the user agent string.
                 * @return {boolean} Whether the platform is Linux.
                 */
                function isLinux() {
                    return goog.labs.userAgent.util.matchUserAgent('Linux');
                }
                platform.isLinux = isLinux;
                ;
                /**
                 * @return {boolean} Whether the platform is Windows.
                 */
                function isWindows() {
                    return goog.labs.userAgent.util.matchUserAgent('Windows');
                }
                platform.isWindows = isWindows;
                ;
                /**
                 * @return {boolean} Whether the platform is ChromeOS.
                 */
                function isChromeOS() {
                    return goog.labs.userAgent.util.matchUserAgent('CrOS');
                }
                platform.isChromeOS = isChromeOS;
                ;
                /**
                 * @return {boolean} Whether the platform is Chromecast.
                 */
                function isChromecast() {
                    return goog.labs.userAgent.util.matchUserAgent('CrKey');
                }
                platform.isChromecast = isChromecast;
                ;
                /**
                 * The version of the platform. We only determine the version for Windows,
                 * Mac, and Chrome OS. It doesn't make much sense on Linux. For Windows, we only
                 * look at the NT version. Non-NT-based versions (e.g. 95, 98, etc.) are given
                 * version 0.0.
                 *
                 * @return {string} The platform version or empty string if version cannot be
                 *     determined.
                 */
                function getVersion() {
                    var userAgentString = goog.labs.userAgent.util.getUserAgent();
                    var version = '', re;
                    if (goog.labs.userAgent.platform.isWindows()) {
                        re = /Windows (?:NT|Phone) ([0-9.]+)/;
                        var match = re.exec(userAgentString);
                        if (match) {
                            version = match[1];
                        }
                        else {
                            version = '0.0';
                        }
                    }
                    else if (goog.labs.userAgent.platform.isIos()) {
                        re = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/;
                        var match = re.exec(userAgentString);
                        // Report the version as x.y.z and not x_y_z
                        version = match && match[1].replace(/_/g, '.');
                    }
                    else if (goog.labs.userAgent.platform.isMacintosh()) {
                        re = /Mac OS X ([0-9_.]+)/;
                        var match = re.exec(userAgentString);
                        // Note: some old versions of Camino do not report an OSX version.
                        // Default to 10.
                        version = match ? match[1].replace(/_/g, '.') : '10';
                    }
                    else if (goog.labs.userAgent.platform.isAndroid()) {
                        re = /Android\s+([^\);]+)(\)|;)/;
                        var match = re.exec(userAgentString);
                        version = match && match[1];
                    }
                    else if (goog.labs.userAgent.platform.isChromeOS()) {
                        re = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/;
                        var match = re.exec(userAgentString);
                        version = match && match[1];
                    }
                    return version || '';
                }
                platform.getVersion = getVersion;
                ;
                /**
                 * @param {string|number} version The version to check.
                 * @return {boolean} Whether the browser version is higher or the same as the
                 *     given version.
                 */
                function isVersionOrHigher(version) {
                    return goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(), version) >= 0;
                }
                platform.isVersionOrHigher = isVersionOrHigher;
                ;
            })(platform = userAgent.platform || (userAgent.platform = {}));
        })(userAgent = labs.userAgent || (labs.userAgent = {}));
    })(labs = goog.labs || (goog.labs = {}));
})(goog || (goog = {}));
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Useful compiler idioms.
 *
 * @author johnlenz@google.com (John Lenz)
 */
goog.provide('goog.reflect');
var goog;
(function (goog) {
    var reflect;
    (function (reflect) {
        /**
         * Syntax for object literal casts.
         * @see http://go/jscompiler-renaming
         * @see https://goo.gl/CRs09P
         *
         * Use this if you have an object literal whose keys need to have the same names
         * as the properties of some class even after they are renamed by the compiler.
         *
         * @param {!Function} type Type to cast to.
         * @param {Object} object Object literal to cast.
         * @return {Object} The object literal.
         */
        function object(type, object) {
            return object;
        }
        reflect.object = object;
        ;
        /**
         * Syntax for renaming property strings.
         * @see http://go/jscompiler-renaming
         * @see https://goo.gl/CRs09P
         *
         * Use this if you have an need to access a property as a string, but want
         * to also have the property renamed by the compiler. In contrast to
         * goog.reflect.object, this method takes an instance of an object.
         *
         * Properties must be simple names (not qualified names).
         *
         * @param {string} prop Name of the property
         * @param {!Object} object Instance of the object whose type will be used
         *     for renaming
         * @return {string} The renamed property.
         */
        function objectProperty(prop, object) {
            return prop;
        }
        reflect.objectProperty = objectProperty;
        ;
        /**
         * To assert to the compiler that an operation is needed when it would
         * otherwise be stripped. For example:
         * <code>
         *     // Force a layout
         *     goog.reflect.sinkValue(dialog.offsetHeight);
         * </code>
         * @param {T} x
         * @return {T}
         * @template T
         */
        function sinkValue(x) {
            goog.reflect.sinkValue[' '](x);
            return x;
        }
        reflect.sinkValue = sinkValue;
        ;
        /**
         * The compiler should optimize this function away iff no one ever uses
         * goog.reflect.sinkValue.
         */
        goog.reflect.sinkValue[' '] = goog.nullFunction;
        /**
         * Check if a property can be accessed without throwing an exception.
         * @param {Object} obj The owner of the property.
         * @param {string} prop The property name.
         * @return {boolean} Whether the property is accessible. Will also return true
         *     if obj is null.
         */
        function canAccessProperty(obj, prop) {
            try {
                goog.reflect.sinkValue(obj[prop]);
                return true;
            }
            catch (e) {
            }
            return false;
        }
        reflect.canAccessProperty = canAccessProperty;
        ;
        /**
         * Retrieves a value from a cache given a key. The compiler provides special
         * consideration for this call such that it is generally considered side-effect
         * free. However, if the {@code opt_keyFn} or {@code valueFn} have side-effects
         * then the entire call is considered to have side-effects.
         *
         * Conventionally storing the value on the cache would be considered a
         * side-effect and preclude unused calls from being pruned, ie. even if
         * the value was never used, it would still always be stored in the cache.
         *
         * Providing a side-effect free {@code valueFn} and {@code opt_keyFn}
         * allows unused calls to {@code goog.reflect.cache} to be pruned.
         *
         * @param {!Object<K, V>} cacheObj The object that contains the cached values.
         * @param {?} key The key to lookup in the cache. If it is not string or number
         *     then a {@code opt_keyFn} should be provided. The key is also used as the
         *     parameter to the {@code valueFn}.
         * @param {function(?):V} valueFn The value provider to use to calculate the
         *     value to store in the cache. This function should be side-effect free
         *     to take advantage of the optimization.
         * @param {function(?):K=} opt_keyFn The key provider to determine the cache
         *     map key. This should be used if the given key is not a string or number.
         *     If not provided then the given key is used. This function should be
         *     side-effect free to take advantage of the optimization.
         * @return {V} The cached or calculated value.
         * @template K
         * @template V
         */
        function cache(cacheObj, key, valueFn, opt_keyFn) {
            var storedKey = opt_keyFn ? opt_keyFn(key) : key;
            if (Object.prototype.hasOwnProperty.call(cacheObj, storedKey)) {
                return cacheObj[storedKey];
            }
            return (cacheObj[storedKey] = valueFn(key));
        }
        reflect.cache = cache;
        ;
    })(reflect = goog.reflect || (goog.reflect = {}));
})(goog || (goog = {}));
/// <reference path="../labs/userAgent/browser" />
/// <reference path="../labs/userAgent/engine" />
/// <reference path="../labs/userAgent/platform" />
/// <reference path="../labs/userAgent/util" />
/// <reference path="../reflect/reflect" />
/// <reference path="../string/string" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rendering engine detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For information on the browser brand (such as Safari versus Chrome), see
 * goog.userAgent.product.
 * @author arv@google.com (Erik Arvidsson)
 * @see ../demos/useragent.html
 */
goog.provide('goog.userAgent');
goog.require('goog.labs.userAgent.browser');
goog.require('goog.labs.userAgent.engine');
goog.require('goog.labs.userAgent.platform');
goog.require('goog.labs.userAgent.util');
goog.require('goog.reflect');
goog.require('goog.string');
/**
 * @define {boolean} Whether we know at compile-time that the browser is IE.
 */
goog.define('goog.userAgent.ASSUME_IE', false);
/**
 * @define {boolean} Whether we know at compile-time that the browser is EDGE.
 */
goog.define('goog.userAgent.ASSUME_EDGE', false);
/**
 * @define {boolean} Whether we know at compile-time that the browser is GECKO.
 */
goog.define('goog.userAgent.ASSUME_GECKO', false);
/**
 * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.
 */
goog.define('goog.userAgent.ASSUME_WEBKIT', false);
/**
 * @define {boolean} Whether we know at compile-time that the browser is a
 *     mobile device running WebKit e.g. iPhone or Android.
 */
goog.define('goog.userAgent.ASSUME_MOBILE_WEBKIT', false);
/**
 * @define {boolean} Whether we know at compile-time that the browser is OPERA.
 */
goog.define('goog.userAgent.ASSUME_OPERA', false);
/**
 * @define {boolean} Whether the
 *     {@code goog.userAgent.isVersionOrHigher}
 *     function will return true for any version.
 */
goog.define('goog.userAgent.ASSUME_ANY_VERSION', false);
var goog;
(function (goog) {
    var userAgent;
    (function (userAgent_3) {
        /**
         * @define {boolean} Whether we know at compile-time that the browser is IE.
         */
        userAgent_3.ASSUME_IE = false;
        /**
         * @define {boolean} Whether we know at compile-time that the browser is EDGE.
         */
        userAgent_3.ASSUME_EDGE = false;
        /**
         * @define {boolean} Whether we know at compile-time that the browser is GECKO.
         */
        userAgent_3.ASSUME_GECKO = false;
        /**
         * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.
         */
        userAgent_3.ASSUME_WEBKIT = false;
        /**
         * @define {boolean} Whether we know at compile-time that the browser is a
         *     mobile device running WebKit e.g. iPhone or Android.
         */
        userAgent_3.ASSUME_MOBILE_WEBKIT = false;
        /**
         * @define {boolean} Whether we know at compile-time that the browser is OPERA.
         */
        userAgent_3.ASSUME_OPERA = false;
        /**
         * @define {boolean} Whether the
         *     {@code goog.userAgent.isVersionOrHigher}
         *     function will return true for any version.
         */
        userAgent_3.ASSUME_ANY_VERSION = false;
        /**
         * Whether we know the browser engine at compile-time.
         * @type {boolean}
         * @private
         */
        userAgent_3.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE ||
            goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO ||
            goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT ||
            goog.userAgent.ASSUME_OPERA;
        /**
         * Returns the userAgent string for the current browser.
         *
         * @return {string} The userAgent string.
         */
        function getUserAgentString() {
            return goog.labs.userAgent.util.getUserAgent();
        }
        userAgent_3.getUserAgentString = getUserAgentString;
        ;
        /**
         * TODO(nnaze): Change type to "Navigator" and update compilation targets.
         * @return {?Object} The native navigator object.
         */
        function getNavigator() {
            // Need a local navigator reference instead of using the global one,
            // to avoid the rare case where they reference different objects.
            // (in a WorkerPool, for example).
            return goog.global['navigator'] || null;
        }
        userAgent_3.getNavigator = getNavigator;
        ;
        /**
         * Whether the user agent is Opera.
         * @type {boolean}
         */
        userAgent_3.OPERA = goog.userAgent.BROWSER_KNOWN_ ?
            goog.userAgent.ASSUME_OPERA :
            goog.labs.userAgent.browser.isOpera();
        /**
        * Whether the user agent is Internet Explorer.
        * @type {boolean}
        */
        userAgent_3.IE = goog.userAgent.BROWSER_KNOWN_ ?
            goog.userAgent.ASSUME_IE :
            goog.labs.userAgent.browser.isIE();
        /**
        * Whether the user agent is Microsoft Edge.
        * @type {boolean}
        */
        userAgent_3.EDGE = goog.userAgent.BROWSER_KNOWN_ ?
            goog.userAgent.ASSUME_EDGE :
            goog.labs.userAgent.engine.isEdge();
        /**
        * Whether the user agent is MS Internet Explorer or MS Edge.
        * @type {boolean}
        */
        userAgent_3.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE;
        /**
        * Whether the user agent is Gecko. Gecko is the rendering engine used by
        * Mozilla, Firefox, and others.
        * @type {boolean}
        */
        userAgent_3.GECKO = goog.userAgent.BROWSER_KNOWN_ ?
            goog.userAgent.ASSUME_GECKO :
            goog.labs.userAgent.engine.isGecko();
        /**
        * Whether the user agent is WebKit. WebKit is the rendering engine that
        * Safari, Android and others use.
        * @type {boolean}
        */
        userAgent_3.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?
            goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :
            goog.labs.userAgent.engine.isWebKit();
        /**
         * Whether the user agent is running on a mobile device.
         *
         * This is a separate function so that the logic can be tested.
         *
         * TODO(nnaze): Investigate swapping in goog.labs.userAgent.device.isMobile().
         *
         * @return {boolean} Whether the user agent is running on a mobile device.
         * @private
         */
        function isMobile_() {
            return goog.userAgent.WEBKIT &&
                goog.labs.userAgent.util.matchUserAgent('Mobile');
        }
        userAgent_3.isMobile_ = isMobile_;
        ;
        /**
         * Whether the user agent is running on a mobile device.
         *
         * TODO(nnaze): Consider deprecating MOBILE when labs.userAgent
         *   is promoted as the gecko/webkit logic is likely inaccurate.
         *
         * @type {boolean}
         */
        userAgent_3.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_();
        /**
         * Used while transitioning code to use WEBKIT instead.
         * @type {boolean}
         * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.
         * TODO(nicksantos): Delete this from goog.userAgent.
         */
        userAgent_3.SAFARI = goog.userAgent.WEBKIT;
        /**
         * @return {string} the platform (operating system) the user agent is running
         *     on. Default to empty string because navigator.platform may not be defined
         *     (on Rhino, for example).
         * @private
         */
        function determinePlatform_() {
            var navigator = goog.userAgent.getNavigator();
            return navigator && navigator.platform || '';
        }
        userAgent_3.determinePlatform_ = determinePlatform_;
        ;
        /**
         * The platform (operating system) the user agent is running on. Default to
         * empty string because navigator.platform may not be defined (on Rhino, for
         * example).
         * @type {string}
         */
        userAgent_3.PLATFORM = goog.userAgent.determinePlatform_();
        /**
         * @define {boolean} Whether the user agent is running on a Macintosh operating
         *     system.
         */
        userAgent_3.ASSUME_MAC = false;
        /**
         * @define {boolean} Whether the user agent is running on a Windows operating
         *     system.
         */
        userAgent_3.ASSUME_WINDOWS = false;
        /**
         * @define {boolean} Whether the user agent is running on a Linux operating
         *     system.
         */
        userAgent_3.ASSUME_LINUX = false;
        /**
         * @define {boolean} Whether the user agent is running on a X11 windowing
         *     system.
         */
        userAgent_3.ASSUME_X11 = false;
        /**
         * @define {boolean} Whether the user agent is running on Android.
         */
        userAgent_3.ASSUME_ANDROID = false;
        /**
         * @define {boolean} Whether the user agent is running on an iPhone.
         */
        userAgent_3.ASSUME_IPHONE = false;
        /**
         * @define {boolean} Whether the user agent is running on an iPad.
         */
        userAgent_3.ASSUME_IPAD = false;
        /**
         * @define {boolean} Whether the user agent is running on an iPod.
         */
        userAgent_3.ASSUME_IPOD = false;
        /**
         * @type {boolean}
         * @private
         */
        userAgent_3.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC ||
            goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX ||
            goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID ||
            goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD ||
            goog.userAgent.ASSUME_IPOD;
        /**
        * Whether the user agent is running on a Macintosh operating system.
        * @type {boolean}
        */
        userAgent_3.MAC = goog.userAgent.PLATFORM_KNOWN_ ?
            goog.userAgent.ASSUME_MAC :
            goog.labs.userAgent.platform.isMacintosh();
        /**
        * Whether the user agent is running on a Windows operating system.
        * @type {boolean}
        */
        userAgent_3.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?
            goog.userAgent.ASSUME_WINDOWS :
            goog.labs.userAgent.platform.isWindows();
        /**
        * Whether the user agent is Linux per the legacy behavior of
        * goog.userAgent.LINUX, which considered ChromeOS to also be
        * Linux.
        * @return {boolean}
        * @private
        */
        function isLegacyLinux_() {
            return goog.labs.userAgent.platform.isLinux() ||
                goog.labs.userAgent.platform.isChromeOS();
        }
        userAgent_3.isLegacyLinux_ = isLegacyLinux_;
        ;
        /**
        * Whether the user agent is running on a Linux operating system.
        *
        * Note that goog.userAgent.LINUX considers ChromeOS to be Linux,
        * while goog.labs.userAgent.platform considers ChromeOS and
        * Linux to be different OSes.
        *
        * @type {boolean}
        */
        userAgent_3.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?
            goog.userAgent.ASSUME_LINUX :
            goog.userAgent.isLegacyLinux_();
        /**
        * @return {boolean} Whether the user agent is an X11 windowing system.
        * @private
        */
        function isX11_() {
            var navigator = goog.userAgent.getNavigator();
            return !!navigator &&
                goog.string.contains(navigator['appVersion'] || '', 'X11');
        }
        userAgent_3.isX11_ = isX11_;
        ;
        /**
        * Whether the user agent is running on a X11 windowing system.
        * @type {boolean}
        */
        userAgent_3.X11 = goog.userAgent.PLATFORM_KNOWN_ ?
            goog.userAgent.ASSUME_X11 :
            goog.userAgent.isX11_();
        /**
        * Whether the user agent is running on Android.
        * @type {boolean}
        */
        userAgent_3.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ?
            goog.userAgent.ASSUME_ANDROID :
            goog.labs.userAgent.platform.isAndroid();
        /**
        * Whether the user agent is running on an iPhone.
        * @type {boolean}
        */
        userAgent_3.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ?
            goog.userAgent.ASSUME_IPHONE :
            goog.labs.userAgent.platform.isIphone();
        /**
        * Whether the user agent is running on an iPad.
        * @type {boolean}
        */
        userAgent_3.IPAD = goog.userAgent.PLATFORM_KNOWN_ ?
            goog.userAgent.ASSUME_IPAD :
            goog.labs.userAgent.platform.isIpad();
        /**
        * Whether the user agent is running on an iPod.
        * @type {boolean}
        */
        userAgent_3.IPOD = goog.userAgent.PLATFORM_KNOWN_ ?
            goog.userAgent.ASSUME_IPOD :
            goog.labs.userAgent.platform.isIpod();
        /**
        * Whether the user agent is running on iOS.
        * @type {boolean}
        */
        userAgent_3.IOS = goog.userAgent.PLATFORM_KNOWN_ ?
            (goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD ||
                goog.userAgent.ASSUME_IPOD) :
            goog.labs.userAgent.platform.isIos();
        /**
        * @return {string} The string that describes the version number of the user
        *     agent.
        * @private
        */
        function determineVersion_() {
            // All browsers have different ways to detect the version and they all have
            // different naming schemes.
            // version is a string rather than a number because it may contain 'b', 'a',
            // and so on.
            var version = '';
            var arr = goog.userAgent.getVersionRegexResult_();
            if (arr) {
                version = arr ? arr[1] : '';
            }
            if (goog.userAgent.IE) {
                // IE9 can be in document mode 9 but be reporting an inconsistent user agent
                // version.  If it is identifying as a version lower than 9 we take the
                // documentMode as the version instead.  IE8 has similar behavior.
                // It is recommended to set the X-UA-Compatible header to ensure that IE9
                // uses documentMode 9.
                var docMode = goog.userAgent.getDocumentMode_();
                if (docMode != null && docMode > parseFloat(version)) {
                    return String(docMode);
                }
            }
            return version;
        }
        userAgent_3.determineVersion_ = determineVersion_;
        ;
        /**
        * @return {?Array|undefined} The version regex matches from parsing the user
        *     agent string. These regex statements must be executed inline so they can
        *     be compiled out by the closure compiler with the rest of the useragent
        *     detection logic when ASSUME_* is specified.
        * @private
        */
        function getVersionRegexResult_() {
            var userAgent = goog.userAgent.getUserAgentString();
            if (goog.userAgent.GECKO) {
                return /rv\:([^\);]+)(\)|;)/.exec(userAgent);
            }
            if (goog.userAgent.EDGE) {
                return /Edge\/([\d\.]+)/.exec(userAgent);
            }
            if (goog.userAgent.IE) {
                return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(userAgent);
            }
            if (goog.userAgent.WEBKIT) {
                // WebKit/125.4
                return /WebKit\/(\S+)/.exec(userAgent);
            }
            if (goog.userAgent.OPERA) {
                // If none of the above browsers were detected but the browser is Opera, the
                // only string that is of interest is 'Version/<number>'.
                return /(?:Version)[ \/]?(\S+)/.exec(userAgent);
            }
            return undefined;
        }
        userAgent_3.getVersionRegexResult_ = getVersionRegexResult_;
        ;
        /**
        * @return {number|undefined} Returns the document mode (for testing).
        * @private
        */
        function getDocumentMode_() {
            // NOTE(user): goog.userAgent may be used in context where there is no DOM.
            var doc = goog.global['document'];
            return doc ? doc['documentMode'] : undefined;
        }
        userAgent_3.getDocumentMode_ = getDocumentMode_;
        ;
        /**
        * The version of the user agent. This is a string because it might contain
        * 'b' (as in beta) as well as multiple dots.
        * @type {string}
        */
        userAgent_3.VERSION = goog.userAgent.determineVersion_();
        /**
        * Compares two version numbers.
        *
        * @param {string} v1 Version of first item.
        * @param {string} v2 Version of second item.
        *
        * @return {number}  1 if first argument is higher
        *                   0 if arguments are equal
        *                  -1 if second argument is higher.
        * @deprecated Use goog.string.compareVersions.
        */
        function compare(v1, v2) {
            return goog.string.compareVersions(v1, v2);
        }
        userAgent_3.compare = compare;
        ;
        /**
        * Cache for {@link goog.userAgent.isVersionOrHigher}.
        * Calls to compareVersions are surprisingly expensive and, as a browser's
        * version number is unlikely to change during a session, we cache the results.
        * @const
        * @private
        */
        userAgent_3.isVersionOrHigherCache_ = {};
        /**
        * Whether the user agent version is higher or the same as the given version.
        * NOTE: When checking the version numbers for Firefox and Safari, be sure to
        * use the engine's version, not the browser's version number.  For example,
        * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.
        * Opera and Internet Explorer versions match the product release number.<br>
        * @see <a href="http://en.wikipedia.org/wiki/Safari_version_history">
        *     Webkit</a>
        * @see <a href="http://en.wikipedia.org/wiki/Gecko_engine">Gecko</a>
        *
        * @param {string|number} version The version to check.
        * @return {boolean} Whether the user agent version is higher or the same as
        *     the given version.
        */
        function isVersionOrHigher(version) {
            return goog.userAgent.ASSUME_ANY_VERSION ||
                goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_, version, function () {
                    return goog.string.compareVersions(goog.userAgent.VERSION, version) >= 0;
                });
        }
        userAgent_3.isVersionOrHigher = isVersionOrHigher;
        ;
        /**
        * Deprecated alias to {@code goog.userAgent.isVersionOrHigher}.
        * @param {string|number} version The version to check.
        * @return {boolean} Whether the user agent version is higher or the same as
        *     the given version.
        * @deprecated Use goog.userAgent.isVersionOrHigher().
        */
        userAgent_3.isVersion = goog.userAgent.isVersionOrHigher;
        /**
        * Whether the IE effective document mode is higher or the same as the given
        * document mode version.
        * NOTE: Only for IE, return false for another browser.
        *
        * @param {number} documentMode The document mode version to check.
        * @return {boolean} Whether the IE effective document mode is higher or the
        *     same as the given version.
        */
        function isDocumentModeOrHigher(documentMode) {
            return Number(goog.userAgent.DOCUMENT_MODE) >= documentMode;
        }
        userAgent_3.isDocumentModeOrHigher = isDocumentModeOrHigher;
        ;
        /**
        * Deprecated alias to {@code goog.userAgent.isDocumentModeOrHigher}.
        * @param {number} version The version to check.
        * @return {boolean} Whether the IE effective document mode is higher or the
        *      same as the given version.
        * @deprecated Use goog.userAgent.isDocumentModeOrHigher().
        */
        userAgent_3.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;
        /**
        * For IE version < 7, documentMode is undefined, so attempt to use the
        * CSS1Compat property to see if we are in standards mode. If we are in
        * standards mode, treat the browser version as the document mode. Otherwise,
        * IE is emulating version 5.
        * @type {number|undefined}
        * @const
        */
        userAgent_3.DOCUMENT_MODE = (function () {
            var doc = goog.global['document'];
            var mode = goog.userAgent.getDocumentMode_();
            if (!doc || !goog.userAgent.IE) {
                return undefined;
            }
            return mode || (doc['compatMode'] == 'CSS1Compat' ?
                parseInt(goog.userAgent.VERSION, 10) :
                5);
        })();
    })(userAgent = goog.userAgent || (goog.userAgent = {}));
})(goog || (goog = {}));
/**
 * @define {boolean} Whether the user agent is running on a Macintosh operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_MAC', false);
/**
 * @define {boolean} Whether the user agent is running on a Windows operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_WINDOWS', false);
/**
 * @define {boolean} Whether the user agent is running on a Linux operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_LINUX', false);
/**
 * @define {boolean} Whether the user agent is running on a X11 windowing
 *     system.
 */
goog.define('goog.userAgent.ASSUME_X11', false);
/**
 * @define {boolean} Whether the user agent is running on Android.
 */
goog.define('goog.userAgent.ASSUME_ANDROID', false);
/**
 * @define {boolean} Whether the user agent is running on an iPhone.
 */
goog.define('goog.userAgent.ASSUME_IPHONE', false);
/**
 * @define {boolean} Whether the user agent is running on an iPad.
 */
goog.define('goog.userAgent.ASSUME_IPAD', false);
/**
 * @define {boolean} Whether the user agent is running on an iPod.
 */
goog.define('goog.userAgent.ASSUME_IPOD', false);
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Browser capability checks for the dom package.
 *
 */
goog.provide('goog.dom.BrowserFeature');
goog.require('goog.userAgent');
var goog;
(function (goog) {
    var dom;
    (function (dom) {
        /**
         * Enum of browser capabilities.
         * @enum {boolean}
         */
        dom.BrowserFeature = {
            /**
             * Whether attributes 'name' and 'type' can be added to an element after it's
             * created. False in Internet Explorer prior to version 9.
             */
            CAN_ADD_NAME_OR_TYPE_ATTRIBUTES: (!goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9)),
            /**
            * Whether we can use element.children to access an element's Element
            * children. Available since Gecko 1.9.1, IE 9. (IE<9 also includes comment
            * nodes in the collection.)
            */
            CAN_USE_CHILDREN_ATTRIBUTE: !goog.userAgent.GECKO && !goog.userAgent.IE ||
                goog.userAgent.IE && goog.userAgent.isDocumentModeOrHigher(9) ||
                goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9.1'),
            /**
            * Opera, Safari 3, and Internet Explorer 9 all support innerText but they
            * include text nodes in script and style tags. Not document-mode-dependent.
            */
            CAN_USE_INNER_TEXT: (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9')),
            /**
            * MSIE, Opera, and Safari>=4 support element.parentElement to access an
            * element's parent if it is an Element.
            */
            CAN_USE_PARENT_ELEMENT_PROPERTY: goog.userAgent.IE || goog.userAgent.OPERA || goog.userAgent.WEBKIT,
            /**
            * Whether NoScope elements need a scoped element written before them in
            * innerHTML.
            * MSDN: http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx#1
            */
            INNER_HTML_NEEDS_SCOPED_ELEMENT: goog.userAgent.IE,
            /**
            * Whether we use legacy IE range API.
            */
            LEGACY_IE_RANGES: goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)
        };
    })(dom = goog.dom || (goog.dom = {}));
})(goog || (goog = {}));
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
goog.provide('goog.string.Const');
goog.require('goog.asserts');
goog.require('goog.string.TypedString');
var goog;
(function (goog) {
    var string;
    (function (string) {
        var Const = /** @class */ (function () {
            /**
             * Wrapper for compile-time-constant strings.
             *
             * Const is a wrapper for strings that can only be created from program
             * constants (i.e., string literals).  This property relies on a custom Closure
             * compiler check that {@code goog.string.Const.from} is only invoked on
             * compile-time-constant expressions.
             *
             * Const is useful in APIs whose correct and secure use requires that certain
             * arguments are not attacker controlled: Compile-time constants are inherently
             * under the control of the application and not under control of external
             * attackers, and hence are safe to use in such contexts.
             *
             * Instances of this type must be created via its factory method
             * {@code goog.string.Const.from} and not by invoking its constructor.  The
             * constructor intentionally takes no parameters and the type is immutable;
             * hence only a default instance corresponding to the empty string can be
             * obtained via constructor invocation.
             *
             * @see goog.string.Const#from
             * @constructor
             * @final
             * @struct
             * @implements {goog.string.TypedString}
             */
            function Const() {
                /**
                 * @override
                 * @const
                 */
                this.implementsGoogStringTypedString = true;
                /**
                 * The wrapped value of this Const object.  The field has a purposely ugly
                 * name to make (non-compiled) code that attempts to directly access this
                 * field stand out.
                 * @private {string}
                 */
                this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ = '';
                /**
                 * A type marker used to implement additional run-time type checking.
                 * @see goog.string.Const#unwrap
                 * @const {!Object}
                 * @private
                 */
                this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ =
                    goog.string.Const.TYPE_MARKER_;
            }
            ;
            /**
             * Returns this Const's value a string.
             *
             * IMPORTANT: In code where it is security-relevant that an object's type is
             * indeed {@code goog.string.Const}, use {@code goog.string.Const.unwrap}
             * instead of this method.
             *
             * @see goog.string.Const#unwrap
             * @override
             */
            Const.prototype.getTypedStringValue = function () {
                return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
            };
            ;
            /**
             * Returns a debug-string representation of this value.
             *
             * To obtain the actual string value wrapped inside an object of this type,
             * use {@code goog.string.Const.unwrap}.
             *
             * @see goog.string.Const#unwrap
             * @override
             */
            Const.prototype.toString = function () {
                return 'Const{' +
                    this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ +
                    '}';
            };
            ;
            return Const;
        }());
        string.Const = Const;
    })(string = goog.string || (goog.string = {}));
})(goog || (goog = {}));
(function (goog) {
    var string;
    (function (string) {
        var Const;
        (function (Const) {
            /**
             * Performs a runtime check that the provided object is indeed an instance
             * of {@code goog.string.Const}, and returns its value.
             * @param {!goog.string.Const} stringConst The object to extract from.
             * @return {string} The Const object's contained string, unless the run-time
             *     type check fails. In that case, {@code unwrap} returns an innocuous
             *     string, or, if assertions are enabled, throws
             *     {@code goog.asserts.AssertionError}.
             */
            function unwrap(stringConst) {
                // Perform additional run-time type-checking to ensure that stringConst is
                // indeed an instance of the expected type.  This provides some additional
                // protection against security bugs due to application code that disables type
                // checks.
                if (stringConst instanceof goog.string.Const &&
                    stringConst.constructor === goog.string.Const &&
                    stringConst.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ ===
                        goog.string.Const.TYPE_MARKER_) {
                    return stringConst
                        .stringConstValueWithSecurityContract__googStringSecurityPrivate_;
                }
                else {
                    goog.asserts.fail('expected object of type Const, got \'' + stringConst + '\'');
                    return 'type_error:Const';
                }
            }
            Const.unwrap = unwrap;
            ;
            /**
             * Creates a Const object from a compile-time constant string.
             *
             * It is illegal to invoke this function on an expression whose
             * compile-time-contant value cannot be determined by the Closure compiler.
             *
             * Correct invocations include,
             * <pre>
             *   var s = goog.string.Const.from('hello');
             *   var t = goog.string.Const.from('hello' + 'world');
             * </pre>
             *
             * In contrast, the following are illegal:
             * <pre>
             *   var s = goog.string.Const.from(getHello());
             *   var t = goog.string.Const.from('hello' + world);
             * </pre>
             *
             * @param {string} s A constant string from which to create a Const.
             * @return {!goog.string.Const} A Const object initialized to stringConst.
             */
            function from(s) {
                return goog.string.Const.create__googStringSecurityPrivate_(s);
            }
            Const.from = from;
            ;
            /**
             * Type marker for the Const type, used to implement additional run-time
             * type checking.
             * @const {!Object}
             * @private
             */
            Const.TYPE_MARKER_ = {};
            /**
             * Utility method to create Const instances.
             * @param {string} s The string to initialize the Const object with.
             * @return {!goog.string.Const} The initialized Const object.
             * @private
             */
            function create__googStringSecurityPrivate_(s) {
                var stringConst = new goog.string.Const();
                stringConst.stringConstValueWithSecurityContract__googStringSecurityPrivate_ =
                    s;
                return stringConst;
            }
            Const.create__googStringSecurityPrivate_ = create__googStringSecurityPrivate_;
            ;
            /**
             * A Const instance wrapping the empty string.
             * @const {!goog.string.Const}
             */
            Const.EMPTY = goog.string.Const.from('');
        })(Const = string.Const || (string.Const = {}));
    })(string = goog.string || (goog.string = {}));
})(goog || (goog = {}));
// Copyright 2014 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utilities for HTML element tag names.
 */
goog.provide('goog.dom.tags');
goog.require('goog.object');
var goog;
(function (goog) {
    var dom;
    (function (dom) {
        var tags;
        (function (tags) {
            /**
             * The void elements specified by
             * http://www.w3.org/TR/html-markup/syntax.html#void-elements.
             * @const @private {!Object<string, boolean>}
             */
            tags.VOID_TAGS_ = goog.object.createSet('area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr');
            /**
             * Checks whether the tag is void (with no contents allowed and no legal end
             * tag), for example 'br'.
             * @param {string} tagName The tag name in lower case.
             * @return {boolean}
             */
            function isVoidTag(tagName) {
                return goog.dom.tags.VOID_TAGS_[tagName] === true;
            }
            tags.isVoidTag = isVoidTag;
            ;
        })(tags = dom.tags || (dom.tags = {}));
    })(dom = goog.dom || (goog.dom = {}));
})(goog || (goog = {}));
// Copyright 2014 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview The SafeScript type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */
goog.provide('goog.html.SafeScript');
goog.require('goog.asserts');
goog.require('goog.string.Const');
goog.require('goog.string.TypedString');
var goog;
(function (goog) {
    var html;
    (function (html) {
        var SafeScript = /** @class */ (function () {
            /**
             * A string-like object which represents JavaScript code and that carries the
             * security type contract that its value, as a string, will not cause execution
             * of unconstrained attacker controlled code (XSS) when evaluated as JavaScript
             * in a browser.
             *
             * Instances of this type must be created via the factory method
             * {@code goog.html.SafeScript.fromConstant} and not by invoking its
             * constructor. The constructor intentionally takes no parameters and the type
             * is immutable; hence only a default instance corresponding to the empty string
             * can be obtained via constructor invocation.
             *
             * A SafeScript's string representation can safely be interpolated as the
             * content of a script element within HTML. The SafeScript string should not be
             * escaped before interpolation.
             *
             * Note that the SafeScript might contain text that is attacker-controlled but
             * that text should have been interpolated with appropriate escaping,
             * sanitization and/or validation into the right location in the script, such
             * that it is highly constrained in its effect (for example, it had to match a
             * set of whitelisted words).
             *
             * A SafeScript can be constructed via security-reviewed unchecked
             * conversions. In this case producers of SafeScript must ensure themselves that
             * the SafeScript does not contain unsafe script. Note in particular that
             * {@code &lt;} is dangerous, even when inside JavaScript strings, and so should
             * always be forbidden or JavaScript escaped in user controlled input. For
             * example, if {@code &lt;/script&gt;&lt;script&gt;evil&lt;/script&gt;"} were
             * interpolated inside a JavaScript string, it would break out of the context
             * of the original script element and {@code evil} would execute. Also note
             * that within an HTML script (raw text) element, HTML character references,
             * such as "&lt;" are not allowed. See
             * http://www.w3.org/TR/html5/scripting-1.html#restrictions-for-contents-of-script-elements.
             *
             * @see goog.html.SafeScript#fromConstant
             * @constructor
             * @final
             * @struct
             * @implements {goog.string.TypedString}
             */
            function SafeScript() {
                /**
                 * @override
                 * @const
                 */
                this.implementsGoogStringTypedString = true;
                /**
                 * The contained value of this SafeScript.  The field has a purposely
                 * ugly name to make (non-compiled) code that attempts to directly access this
                 * field stand out.
                 * @private {string}
                 */
                this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = '';
                /**
                 * A type marker used to implement additional run-time type checking.
                 * @see goog.html.SafeScript#unwrap
                 * @const {!Object}
                 * @private
                 */
                this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ =
                    goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
            }
            ;
            /**
             * Returns this SafeScript's value as a string.
             *
             * IMPORTANT: In code where it is security relevant that an object's type is
             * indeed {@code SafeScript}, use {@code goog.html.SafeScript.unwrap} instead of
             * this method. If in doubt, assume that it's security relevant. In particular,
             * note that goog.html functions which return a goog.html type do not guarantee
             * the returned instance is of the right type. For example:
             *
             * <pre>
             * var fakeSafeHtml = new String('fake');
             * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;
             * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);
             * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
             * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml
             * // instanceof goog.html.SafeHtml.
             * </pre>
             *
             * @see goog.html.SafeScript#unwrap
             * @override
             */
            SafeScript.prototype.getTypedStringValue = function () {
                return this.privateDoNotAccessOrElseSafeScriptWrappedValue_;
            };
            ;
            // if (goog.DEBUG) {
            /**
             * Returns a debug string-representation of this value.
             *
             * To obtain the actual string value wrapped in a SafeScript, use
             * {@code goog.html.SafeScript.unwrap}.
             *
             * @see goog.html.SafeScript#unwrap
             * @override
             */
            SafeScript.prototype.toString = function () {
                return 'SafeScript{' +
                    this.privateDoNotAccessOrElseSafeScriptWrappedValue_ + '}';
            };
            ;
            // }
            /**
             * Called from createSafeScriptSecurityPrivateDoNotAccessOrElse(). This
             * method exists only so that the compiler can dead code eliminate static
             * fields (like EMPTY) when they're not accessed.
             * @param {string} script
             * @return {!goog.html.SafeScript}
             * @private
             */
            SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_ = function (script) {
                this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = script;
                return this;
            };
            ;
            return SafeScript;
        }());
        html.SafeScript = SafeScript;
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
(function (goog) {
    var html;
    (function (html) {
        var SafeScript;
        (function (SafeScript) {
            /**
             * Type marker for the SafeScript type, used to implement additional
             * run-time type checking.
             * @const {!Object}
             * @private
             */
            SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
            /**
             * Creates a SafeScript object from a compile-time constant string.
             *
             * @param {!goog.string.Const} script A compile-time-constant string from which
             *     to create a SafeScript.
             * @return {!goog.html.SafeScript} A SafeScript object initialized to
             *     {@code script}.
             */
            function fromConstant(script) {
                var scriptString = goog.string.Const.unwrap(script);
                if (scriptString.length === 0) {
                    return goog.html.SafeScript.EMPTY;
                }
                return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(scriptString);
            }
            SafeScript.fromConstant = fromConstant;
            ;
            /**
             * Performs a runtime check that the provided object is indeed a
             * SafeScript object, and returns its value.
             *
             * @param {!goog.html.SafeScript} safeScript The object to extract from.
             * @return {string} The safeScript object's contained string, unless
             *     the run-time type check fails. In that case, {@code unwrap} returns an
             *     innocuous string, or, if assertions are enabled, throws
             *     {@code goog.asserts.AssertionError}.
             */
            function unwrap(safeScript) {
                // Perform additional Run-time type-checking to ensure that
                // safeScript is indeed an instance of the expected type.  This
                // provides some additional protection against security bugs due to
                // application code that disables type checks.
                // Specifically, the following checks are performed:
                // 1. The object is an instance of the expected type.
                // 2. The object is not an instance of a subclass.
                // 3. The object carries a type marker for the expected type. "Faking" an
                // object requires a reference to the type marker, which has names intended
                // to stand out in code reviews.
                if (safeScript instanceof goog.html.SafeScript &&
                    safeScript.constructor === goog.html.SafeScript &&
                    safeScript.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ===
                        goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
                    return safeScript.privateDoNotAccessOrElseSafeScriptWrappedValue_;
                }
                else {
                    goog.asserts.fail('expected object of type SafeScript, got \'' +
                        safeScript + '\' of type ' + goog.typeOf(safeScript));
                    return 'type_error:SafeScript';
                }
            }
            SafeScript.unwrap = unwrap;
            ;
            /**
             * Package-internal utility method to create SafeScript instances.
             *
             * @param {string} script The string to initialize the SafeScript object with.
             * @return {!goog.html.SafeScript} The initialized SafeScript object.
             * @package
             */
            function createSafeScriptSecurityPrivateDoNotAccessOrElse(script) {
                return new goog.html.SafeScript().initSecurityPrivateDoNotAccessOrElse_(script);
            }
            SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse = createSafeScriptSecurityPrivateDoNotAccessOrElse;
            ;
            /**
             * A SafeScript instance corresponding to the empty string.
             * @const {!goog.html.SafeScript}
             */
            SafeScript.EMPTY = goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse('');
        })(SafeScript = html.SafeScript || (html.SafeScript = {}));
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
// Copyright 2014 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview The SafeStyle type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */
goog.provide('goog.html.SafeStyle');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.html.SafeUrl');
goog.require('goog.string');
goog.require('goog.string.Const');
goog.require('goog.string.TypedString');
var goog;
(function (goog) {
    var html;
    (function (html) {
        /**
       * A string-like object which represents a sequence of CSS declarations
       * ({@code propertyName1: propertyvalue1; propertyName2: propertyValue2; ...})
       * and that carries the security type contract that its value, as a string,
       * will not cause untrusted script execution (XSS) when evaluated as CSS in a
       * browser.
       *
       * Instances of this type must be created via the factory methods
       * ({@code goog.html.SafeStyle.create} or
       * {@code goog.html.SafeStyle.fromConstant}) and not by invoking its
       * constructor. The constructor intentionally takes no parameters and the type
       * is immutable; hence only a default instance corresponding to the empty string
       * can be obtained via constructor invocation.
       *
       * SafeStyle's string representation can safely be:
       * <ul>
       *   <li>Interpolated as the content of a *quoted* HTML style attribute.
       *       However, the SafeStyle string *must be HTML-attribute-escaped* before
       *       interpolation.
       *   <li>Interpolated as the content of a {}-wrapped block within a stylesheet.
       *       '<' characters in the SafeStyle string *must be CSS-escaped* before
       *       interpolation. The SafeStyle string is also guaranteed not to be able
       *       to introduce new properties or elide existing ones.
       *   <li>Interpolated as the content of a {}-wrapped block within an HTML
       *       <style> element. '<' characters in the SafeStyle string
       *       *must be CSS-escaped* before interpolation.
       *   <li>Assigned to the style property of a DOM node. The SafeStyle string
       *       should not be escaped before being assigned to the property.
       * </ul>
       *
       * A SafeStyle may never contain literal angle brackets. Otherwise, it could
       * be unsafe to place a SafeStyle into a &lt;style&gt; tag (where it can't
       * be HTML escaped). For example, if the SafeStyle containing
       * "{@code font: 'foo &lt;style/&gt;&lt;script&gt;evil&lt;/script&gt;'}" were
       * interpolated within a &lt;style&gt; tag, this would then break out of the
       * style context into HTML.
       *
       * A SafeStyle may contain literal single or double quotes, and as such the
       * entire style string must be escaped when used in a style attribute (if
       * this were not the case, the string could contain a matching quote that
       * would escape from the style attribute).
       *
       * Values of this type must be composable, i.e. for any two values
       * {@code style1} and {@code style2} of this type,
       * {@code goog.html.SafeStyle.unwrap(style1) +
       * goog.html.SafeStyle.unwrap(style2)} must itself be a value that satisfies
       * the SafeStyle type constraint. This requirement implies that for any value
       * {@code style} of this type, {@code goog.html.SafeStyle.unwrap(style)} must
       * not end in a "property value" or "property name" context. For example,
       * a value of {@code background:url("} or {@code font-} would not satisfy the
       * SafeStyle contract. This is because concatenating such strings with a
       * second value that itself does not contain unsafe CSS can result in an
       * overall string that does. For example, if {@code javascript:evil())"} is
       * appended to {@code background:url("}, the resulting string may result in
       * the execution of a malicious script.
       *
       * TODO(mlourenco): Consider whether we should implement UTF-8 interchange
       * validity checks and blacklisting of newlines (including Unicode ones) and
       * other whitespace characters (\t, \f). Document here if so and also update
       * SafeStyle.fromConstant().
       *
       * The following example values comply with this type's contract:
       * <ul>
       *   <li><pre>width: 1em;</pre>
       *   <li><pre>height:1em;</pre>
       *   <li><pre>width: 1em;height: 1em;</pre>
       *   <li><pre>background:url('http://url');</pre>
       * </ul>
       * In addition, the empty string is safe for use in a CSS attribute.
       *
       * The following example values do NOT comply with this type's contract:
       * <ul>
       *   <li><pre>background: red</pre> (missing a trailing semi-colon)
       *   <li><pre>background:</pre> (missing a value and a trailing semi-colon)
       *   <li><pre>1em</pre> (missing an attribute name, which provides context for
       *       the value)
       * </ul>
       *
       * @see goog.html.SafeStyle#create
       * @see goog.html.SafeStyle#fromConstant
       * @see http://www.w3.org/TR/css3-syntax/
       */
        var SafeStyle = /** @class */ (function () {
            /**
             * @constructor
             * @final
             * @struct
             * @implements {goog.string.TypedString}
             */
            function SafeStyle() {
                /**
                 * @override
                 * @const
                 */
                this.implementsGoogStringTypedString = true;
                /**
                 * The contained value of this SafeStyle.  The field has a purposely
                 * ugly name to make (non-compiled) code that attempts to directly access this
                 * field stand out.
                 * @private {string}
                 */
                this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = '';
                /**
                 * A type marker used to implement additional run-time type checking.
                 * @see goog.html.SafeStyle#unwrap
                 * @const {!Object}
                 * @private
                 */
                this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ =
                    goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
            }
            /**
             * Returns this SafeStyle's value as a string.
             *
             * IMPORTANT: In code where it is security relevant that an object's type is
             * indeed {@code SafeStyle}, use {@code goog.html.SafeStyle.unwrap} instead of
             * this method. If in doubt, assume that it's security relevant. In particular,
             * note that goog.html functions which return a goog.html type do not guarantee
             * the returned instance is of the right type. For example:
             *
             * <pre>
             * var fakeSafeHtml = new String('fake');
             * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;
             * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);
             * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
             * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml
             * // instanceof goog.html.SafeHtml.
             * </pre>
             *
             * @see goog.html.SafeStyle#unwrap
             * @override
             */
            SafeStyle.prototype.getTypedStringValue = function () {
                return this.privateDoNotAccessOrElseSafeStyleWrappedValue_;
            };
            ;
            // if (goog.DEBUG) {
            /**
             * Returns a debug string-representation of this value.
             *
             * To obtain the actual string value wrapped in a SafeStyle, use
             * {@code goog.html.SafeStyle.unwrap}.
             *
             * @see goog.html.SafeStyle#unwrap
             * @override
             */
            SafeStyle.prototype.toString = function () {
                return 'SafeStyle{' + this.privateDoNotAccessOrElseSafeStyleWrappedValue_ +
                    '}';
            };
            ;
            // }
            /**
             * Called from createSafeStyleSecurityPrivateDoNotAccessOrElse(). This
             * method exists only so that the compiler can dead code eliminate static
             * fields (like EMPTY) when they're not accessed.
             * @param {string} style
             * @return {!goog.html.SafeStyle}
             * @private
             */
            SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_ = function (style) {
                this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = style;
                return this;
            };
            ;
            /**
             * Creates a SafeStyle object from a compile-time constant string.
             *
             * {@code style} should be in the format
             * {@code name: value; [name: value; ...]} and must not have any < or >
             * characters in it. This is so that SafeStyle's contract is preserved,
             * allowing the SafeStyle to correctly be interpreted as a sequence of CSS
             * declarations and without affecting the syntactic structure of any
             * surrounding CSS and HTML.
             *
             * This method performs basic sanity checks on the format of {@code style}
             * but does not constrain the format of {@code name} and {@code value}, except
             * for disallowing tag characters.
             *
             * @param {!goog.string.Const} style A compile-time-constant string from which
             *     to create a SafeStyle.
             * @return {!goog.html.SafeStyle} A SafeStyle object initialized to
             *     {@code style}.
             */
            SafeStyle.fromConstant = function (style) {
                var styleString = goog.string.Const.unwrap(style);
                if (styleString.length === 0) {
                    return goog.html.SafeStyle.EMPTY;
                }
                goog.html.SafeStyle.checkStyle_(styleString);
                goog.asserts.assert(goog.string.endsWith(styleString, ';'), 'Last character of style string is not \';\': ' + styleString);
                goog.asserts.assert(goog.string.contains(styleString, ':'), 'Style string must contain at least one \':\', to ' +
                    'specify a "name: value" pair: ' + styleString);
                return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(styleString);
            };
            ;
            /**
             * Checks if the style definition is valid.
             * @param {string} style
             * @private
             */
            SafeStyle.checkStyle_ = function (style) {
                goog.asserts.assert(!/[<>]/.test(style), 'Forbidden characters in style string: ' + style);
            };
            ;
            /**
             * Performs a runtime check that the provided object is indeed a
             * SafeStyle object, and returns its value.
             *
             * @param {!goog.html.SafeStyle} safeStyle The object to extract from.
             * @return {string} The safeStyle object's contained string, unless
             *     the run-time type check fails. In that case, {@code unwrap} returns an
             *     innocuous string, or, if assertions are enabled, throws
             *     {@code goog.asserts.AssertionError}.
             */
            SafeStyle.unwrap = function (safeStyle) {
                // Perform additional Run-time type-checking to ensure that
                // safeStyle is indeed an instance of the expected type.  This
                // provides some additional protection against security bugs due to
                // application code that disables type checks.
                // Specifically, the following checks are performed:
                // 1. The object is an instance of the expected type.
                // 2. The object is not an instance of a subclass.
                // 3. The object carries a type marker for the expected type. "Faking" an
                // object requires a reference to the type marker, which has names intended
                // to stand out in code reviews.
                if (safeStyle instanceof goog.html.SafeStyle &&
                    safeStyle.constructor === goog.html.SafeStyle &&
                    safeStyle.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ===
                        goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
                    return safeStyle.privateDoNotAccessOrElseSafeStyleWrappedValue_;
                }
                else {
                    goog.asserts.fail('expected object of type SafeStyle, got \'' +
                        safeStyle + '\' of type ' + goog.typeOf(safeStyle));
                    return 'type_error:SafeStyle';
                }
            };
            ;
            /**
             * Package-internal utility method to create SafeStyle instances.
             *
             * @param {string} style The string to initialize the SafeStyle object with.
             * @return {!goog.html.SafeStyle} The initialized SafeStyle object.
             * @package
             */
            SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse = function (style) {
                return new goog.html.SafeStyle().initSecurityPrivateDoNotAccessOrElse_(style);
            };
            ;
            /**
             * Creates a new SafeStyle object from the properties specified in the map.
             * @param {goog.html.SafeStyle.PropertyMap} map Mapping of property names to
             *     their values, for example {'margin': '1px'}. Names must consist of
             *     [-_a-zA-Z0-9]. Values might be strings consisting of
             *     [-,.'"%_!# a-zA-Z0-9], where " and ' must be properly balanced. We also
             *     allow simple functions like rgb() and url() which sanitizes its contents.
             *     Other values must be wrapped in goog.string.Const. URLs might be passed
             *     as goog.html.SafeUrl which will be wrapped into url(""). We also support
             *     array whose elements are joined with ' '. Null value causes skipping the
             *     property.
             * @return {!goog.html.SafeStyle}
             * @throws {Error} If invalid name is provided.
             * @throws {goog.asserts.AssertionError} If invalid value is provided. With
             *     disabled assertions, invalid value is replaced by
             *     goog.html.SafeStyle.INNOCUOUS_STRING.
             */
            SafeStyle.create = function (map) {
                var style = '';
                for (var name in map) {
                    if (!/^[-_a-zA-Z0-9]+$/.test(name)) {
                        throw new Error('Name allows only [-_a-zA-Z0-9], got: ' + name);
                    }
                    var value = map[name];
                    if (value == null) {
                        continue;
                    }
                    if (goog.isArray(value)) {
                        value = goog.array.map(value, goog.html.SafeStyle.sanitizePropertyValue_)
                            .join(' ');
                    }
                    else {
                        value = goog.html.SafeStyle.sanitizePropertyValue_(value);
                    }
                    style += name + ':' + value + ';';
                }
                if (!style) {
                    return goog.html.SafeStyle.EMPTY;
                }
                goog.html.SafeStyle.checkStyle_(style);
                return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style);
            };
            ;
            /**
             * Checks and converts value to string.
             * @param {!goog.html.SafeStyle.PropertyValue} value
             * @return {string}
             * @private
             */
            SafeStyle.sanitizePropertyValue_ = function (value) {
                if (value instanceof goog.html.SafeUrl) {
                    var url = goog.html.SafeUrl.unwrap(value);
                    return 'url("' + url.replace(/</g, '%3c').replace(/[\\"]/g, '\\$&') + '")';
                }
                var result = value instanceof goog.string.Const ?
                    goog.string.Const.unwrap(value) :
                    goog.html.SafeStyle.sanitizePropertyValueString_(String(value));
                // These characters can be used to change context and we don't want that even
                // with const values.
                goog.asserts.assert(!/[{;}]/.test(result), 'Value does not allow [{;}].');
                return result;
            };
            ;
            /**
             * Checks string value.
             * @param {string} value
             * @return {string}
             * @private
             */
            SafeStyle.sanitizePropertyValueString_ = function (value) {
                var valueWithoutFunctions = value.replace(goog.html.SafeUrl.FUNCTIONS_RE_, '$1')
                    .replace(goog.html.SafeUrl.URL_RE_, 'url');
                if (!goog.html.SafeStyle.VALUE_RE_.test(valueWithoutFunctions)) {
                    goog.asserts.fail('String value allows only ' + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ +
                        ' and simple functions, got: ' + value);
                    return goog.html.SafeStyle.INNOCUOUS_STRING;
                }
                else if (!goog.html.SafeStyle.hasBalancedQuotes_(value)) {
                    goog.asserts.fail('String value requires balanced quotes, got: ' + value);
                    return goog.html.SafeStyle.INNOCUOUS_STRING;
                }
                return goog.html.SafeStyle.sanitizeUrl_(value);
            };
            ;
            /**
             * Checks that quotes (" and ') are properly balanced inside a string. Assumes
             * that neither escape (\) nor any other character that could result in
             * breaking out of a string parsing context are allowed;
             * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
             * @param {string} value Untrusted CSS property value.
             * @return {boolean} True if property value is safe with respect to quote
             *     balancedness.
             * @private
             */
            SafeStyle.hasBalancedQuotes_ = function (value) {
                var outsideSingle = true;
                var outsideDouble = true;
                for (var i = 0; i < value.length; i++) {
                    var c = value.charAt(i);
                    if (c == "'" && outsideDouble) {
                        outsideSingle = !outsideSingle;
                    }
                    else if (c == '"' && outsideSingle) {
                        outsideDouble = !outsideDouble;
                    }
                }
                return outsideSingle && outsideDouble;
            };
            ;
            /**
             * Sanitize URLs inside url().
             *
             * NOTE: We could also consider using CSS.escape once that's available in the
             * browsers. However, loosely matching URL e.g. with url\(.*\) and then escaping
             * the contents would result in a slightly different language than CSS leading
             * to confusion of users. E.g. url(")") is valid in CSS but it would be invalid
             * as seen by our parser. On the other hand, url(\) is invalid in CSS but our
             * parser would be fine with it.
             *
             * @param {string} value Untrusted CSS property value.
             * @return {string}
             * @private
             */
            SafeStyle.sanitizeUrl_ = function (value) {
                return value.replace(goog.html.SafeUrl.URL_RE_, function (match, before, url, after) {
                    var quote = '';
                    url = url.replace(/^(['"])(.*)\1$/, function (match, start, inside) {
                        quote = start;
                        return inside;
                    });
                    var sanitized = goog.html.SafeUrl.sanitize(url).getTypedStringValue();
                    return before + quote + sanitized + quote + after;
                });
            };
            ;
            /**
             * Creates a new SafeStyle object by concatenating the values.
             * @param {...(!goog.html.SafeStyle|!Array<!goog.html.SafeStyle>)} var_args
             *     SafeStyles to concatenate.
             * @return {!goog.html.SafeStyle}
             */
            SafeStyle.concat = function (var_args) {
                var style = '';
                /**
                 * @param {!goog.html.SafeStyle|!Array<!goog.html.SafeStyle>} argument
                 */
                var addArgument = function (argument) {
                    if (goog.isArray(argument)) {
                        goog.array.forEach(argument, addArgument);
                    }
                    else {
                        style += goog.html.SafeStyle.unwrap(argument);
                    }
                };
                goog.array.forEach(arguments, addArgument);
                if (!style) {
                    return goog.html.SafeStyle.EMPTY;
                }
                return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style);
            };
            ;
            /**
           * Type marker for the SafeStyle type, used to implement additional
           * run-time type checking.
           * @const {!Object}
           * @private
           */
            SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
            /**
             * A SafeStyle instance corresponding to the empty string.
             * @const {!goog.html.SafeStyle}
             */
            SafeStyle.EMPTY = goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse('');
            /**
             * The innocuous string generated by goog.html.SafeStyle.create when passed
             * an unsafe value.
             * @const {string}
             */
            SafeStyle.INNOCUOUS_STRING = 'zClosurez';
            /**
             * Characters allowed in goog.html.SafeStyle.VALUE_RE_.
             * @private {string}
             */
            SafeStyle.VALUE_ALLOWED_CHARS_ = '[-,."\'%_!# a-zA-Z0-9]';
            /**
             * Regular expression for safe values.
             *
             * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure
             * they're balanced.
             *
             * ',' allows multiple values to be assigned to the same property
             * (e.g. background-attachment or font-family) and hence could allow
             * multiple values to get injected, but that should pose no risk of XSS.
             *
             * The expression checks only for XSS safety, not for CSS validity.
             * @const {!RegExp}
             * @private
             */
            SafeStyle.VALUE_RE_ = new RegExp('^' + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + '+$');
            /**
             * Regular expression for url(). We support URLs allowed by
             * https://www.w3.org/TR/css-syntax-3/#url-token-diagram without using escape
             * sequences. Use percent-encoding if you need to use special characters like
             * backslash.
             * @private @const {!RegExp}
             */
            SafeStyle.URL_RE_ = new RegExp('\\b(url\\([ \t\n]*)(' +
                '\'[ -&(-\\[\\]-~]*\'' + // Printable characters except ' and \.
                '|"[ !#-\\[\\]-~]*"' + // Printable characters except " and \.
                '|[!#-&*-\\[\\]-~]*' + // Printable characters except [ "'()\\].
                ')([ \t\n]*\\))', 'g');
            /**
             * Regular expression for simple functions.
             * @private @const {!RegExp}
             */
            SafeStyle.FUNCTIONS_RE_ = new RegExp('\\b(hsl|hsla|rgb|rgba|(rotate|scale|translate)(X|Y|Z|3d)?)' +
                '\\([-0-9a-z.%, ]+\\)', 'g');
            return SafeStyle;
        }());
        html.SafeStyle = SafeStyle;
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
// Copyright 2014 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview The SafeStyleSheet type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */
goog.provide('goog.html.SafeStyleSheet');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.html.SafeStyle');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.string.Const');
goog.require('goog.string.TypedString');
var goog;
(function (goog) {
    var html;
    (function (html) {
        /**
         * A string-like object which represents a CSS style sheet and that carries the
         * security type contract that its value, as a string, will not cause untrusted
         * script execution (XSS) when evaluated as CSS in a browser.
         *
         * Instances of this type must be created via the factory method
         * {@code goog.html.SafeStyleSheet.fromConstant} and not by invoking its
         * constructor. The constructor intentionally takes no parameters and the type
         * is immutable; hence only a default instance corresponding to the empty string
         * can be obtained via constructor invocation.
         *
         * A SafeStyleSheet's string representation can safely be interpolated as the
         * content of a style element within HTML. The SafeStyleSheet string should
         * not be escaped before interpolation.
         *
         * Values of this type must be composable, i.e. for any two values
         * {@code styleSheet1} and {@code styleSheet2} of this type,
         * {@code goog.html.SafeStyleSheet.unwrap(styleSheet1) +
         * goog.html.SafeStyleSheet.unwrap(styleSheet2)} must itself be a value that
         * satisfies the SafeStyleSheet type constraint. This requirement implies that
         * for any value {@code styleSheet} of this type,
         * {@code goog.html.SafeStyleSheet.unwrap(styleSheet1)} must end in
         * "beginning of rule" context.
      
        * A SafeStyleSheet can be constructed via security-reviewed unchecked
        * conversions. In this case producers of SafeStyleSheet must ensure themselves
        * that the SafeStyleSheet does not contain unsafe script. Note in particular
        * that {@code &lt;} is dangerous, even when inside CSS strings, and so should
        * always be forbidden or CSS-escaped in user controlled input. For example, if
        * {@code &lt;/style&gt;&lt;script&gt;evil&lt;/script&gt;"} were interpolated
        * inside a CSS string, it would break out of the context of the original
        * style element and {@code evil} would execute. Also note that within an HTML
        * style (raw text) element, HTML character references, such as
        * {@code &amp;lt;}, are not allowed. See
        *
        http://www.w3.org/TR/html5/scripting-1.html#restrictions-for-contents-of-script-elements
        * (similar considerations apply to the style element).
        *
        * @see goog.html.SafeStyleSheet#fromConstant
        */
        var SafeStyleSheet = /** @class */ (function () {
            /**
             * @constructor
             * @final
             * @struct
             * @implements {goog.string.TypedString}
             */
            function SafeStyleSheet() {
                /**
                 * @override
                 * @const
                 */
                this.implementsGoogStringTypedString = true;
                /**
                 * The contained value of this SafeStyleSheet.  The field has a purposely
                 * ugly name to make (non-compiled) code that attempts to directly access this
                 * field stand out.
                 * @private {string}
                 */
                this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = '';
                /**
                 * A type marker used to implement additional run-time type checking.
                 * @see goog.html.SafeStyleSheet#unwrap
                 * @const {!Object}
                 * @private
                 */
                this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ =
                    goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
            }
            /**
             * Returns this SafeStyleSheet's value as a string.
             *
             * IMPORTANT: In code where it is security relevant that an object's type is
             * indeed {@code SafeStyleSheet}, use {@code goog.html.SafeStyleSheet.unwrap}
             * instead of this method. If in doubt, assume that it's security relevant. In
             * particular, note that goog.html functions which return a goog.html type do
             * not guarantee the returned instance is of the right type. For example:
             *
             * <pre>
             * var fakeSafeHtml = new String('fake');
             * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;
             * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);
             * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
             * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml
             * // instanceof goog.html.SafeHtml.
             * </pre>
             *
             * @see goog.html.SafeStyleSheet#unwrap
             * @override
             */
            SafeStyleSheet.prototype.getTypedStringValue = function () {
                return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
            };
            ;
            // if (goog.DEBUG) {
            /**
             * Returns a debug string-representation of this value.
             *
             * To obtain the actual string value wrapped in a SafeStyleSheet, use
             * {@code goog.html.SafeStyleSheet.unwrap}.
             *
             * @see goog.html.SafeStyleSheet#unwrap
             * @override
             */
            SafeStyleSheet.prototype.toString = function () {
                return 'SafeStyleSheet{' +
                    this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ + '}';
            };
            ;
            // }
            /**
             * Called from createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(). This
             * method exists only so that the compiler can dead code eliminate static
             * fields (like EMPTY) when they're not accessed.
             * @param {string} styleSheet
             * @return {!goog.html.SafeStyleSheet}
             * @private
             */
            SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_ = function (styleSheet) {
                this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = styleSheet;
                return this;
            };
            ;
            /**
             * Performs a runtime check that the provided object is indeed a
             * SafeStyleSheet object, and returns its value.
             *
             * @param {!goog.html.SafeStyleSheet} safeStyleSheet The object to extract from.
             * @return {string} The safeStyleSheet object's contained string, unless
             *     the run-time type check fails. In that case, {@code unwrap} returns an
             *     innocuous string, or, if assertions are enabled, throws
             *     {@code goog.asserts.AssertionError}.
             */
            SafeStyleSheet.unwrap = function (safeStyleSheet) {
                // Perform additional Run-time type-checking to ensure that
                // safeStyleSheet is indeed an instance of the expected type.  This
                // provides some additional protection against security bugs due to
                // application code that disables type checks.
                // Specifically, the following checks are performed:
                // 1. The object is an instance of the expected type.
                // 2. The object is not an instance of a subclass.
                // 3. The object carries a type marker for the expected type. "Faking" an
                // object requires a reference to the type marker, which has names intended
                // to stand out in code reviews.
                if (safeStyleSheet instanceof goog.html.SafeStyleSheet &&
                    safeStyleSheet.constructor === goog.html.SafeStyleSheet &&
                    safeStyleSheet
                        .SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ===
                        goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
                    return safeStyleSheet.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
                }
                else {
                    goog.asserts.fail('expected object of type SafeStyleSheet, got \'' +
                        safeStyleSheet + '\' of type ' + goog.typeOf(safeStyleSheet));
                    return 'type_error:SafeStyleSheet';
                }
            };
            ;
            /**
             * Creates a style sheet consisting of one selector and one style definition.
             * Use {@link goog.html.SafeStyleSheet.concat} to create longer style sheets.
             * This function doesn't support @import, @media and similar constructs.
             * @param {string} selector CSS selector, e.g. '#id' or 'tag .class, #id'. We
             *     support CSS3 selectors: https://w3.org/TR/css3-selectors/#selectors.
             * @param {!goog.html.SafeStyle.PropertyMap|!goog.html.SafeStyle} style Style
             *     definition associated with the selector.
             * @return {!goog.html.SafeStyleSheet}
             * @throws {Error} If invalid selector is provided.
             */
            SafeStyleSheet.createRule = function (selector, style) {
                if (goog.string.contains(selector, '<')) {
                    throw new Error('Selector does not allow \'<\', got: ' + selector);
                }
                // Remove strings.
                var selectorToCheck = selector.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g, '');
                // Check characters allowed in CSS3 selectors.
                if (!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(selectorToCheck)) {
                    throw new Error('Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and ' +
                        'strings, got: ' + selector);
                }
                // Check balanced () and [].
                if (!goog.html.SafeStyleSheet.hasBalancedBrackets_(selectorToCheck)) {
                    throw new Error('() and [] in selector must be balanced, got: ' + selector);
                }
                if (!(style instanceof goog.html.SafeStyle)) {
                    style = goog.html.SafeStyle.create(style);
                }
                var styleSheet = selector + '{' + goog.html.SafeStyle.unwrap(style) + '}';
                return goog.html.SafeStyleSheet
                    .createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheet);
            };
            ;
            /**
             * Checks if a string has balanced () and [] brackets.
             * @param {string} s String to check.
             * @return {boolean}
             * @private
             */
            SafeStyleSheet.hasBalancedBrackets_ = function (s) {
                var brackets = { '(': ')', '[': ']' };
                var expectedBrackets = [];
                for (var i = 0; i < s.length; i++) {
                    var ch = s[i];
                    if (brackets[ch]) {
                        expectedBrackets.push(brackets[ch]);
                    }
                    else if (goog.object.contains(brackets, ch)) {
                        if (expectedBrackets.pop() != ch) {
                            return false;
                        }
                    }
                }
                return expectedBrackets.length == 0;
            };
            ;
            /**
             * Creates a new SafeStyleSheet object by concatenating values.
             * @param {...(!goog.html.SafeStyleSheet|!Array<!goog.html.SafeStyleSheet>)}
             *     var_args Values to concatenate.
             * @return {!goog.html.SafeStyleSheet}
             */
            SafeStyleSheet.concat = function (var_args) {
                var result = '';
                /**
                 * @param {!goog.html.SafeStyleSheet|!Array<!goog.html.SafeStyleSheet>}
                 *     argument
                 */
                var addArgument = function (argument) {
                    if (goog.isArray(argument)) {
                        goog.array.forEach(argument, addArgument);
                    }
                    else {
                        result += goog.html.SafeStyleSheet.unwrap(argument);
                    }
                };
                goog.array.forEach(arguments, addArgument);
                return goog.html.SafeStyleSheet
                    .createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(result);
            };
            ;
            /**
             * Creates a SafeStyleSheet object from a compile-time constant string.
             *
             * {@code styleSheet} must not have any &lt; characters in it, so that
             * the syntactic structure of the surrounding HTML is not affected.
             *
             * @param {!goog.string.Const} styleSheet A compile-time-constant string from
             *     which to create a SafeStyleSheet.
             * @return {!goog.html.SafeStyleSheet} A SafeStyleSheet object initialized to
             *     {@code styleSheet}.
             */
            SafeStyleSheet.fromConstant = function (styleSheet) {
                var styleSheetString = goog.string.Const.unwrap(styleSheet);
                if (styleSheetString.length === 0) {
                    return goog.html.SafeStyleSheet.EMPTY;
                }
                // > is a valid character in CSS selectors and there's no strict need to
                // block it if we already block <.
                goog.asserts.assert(!goog.string.contains(styleSheetString, '<'), "Forbidden '<' character in style sheet string: " + styleSheetString);
                return goog.html.SafeStyleSheet
                    .createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheetString);
            };
            ;
            /**
             * Package-internal utility method to create SafeStyleSheet instances.
             *
             * @param {string} styleSheet The string to initialize the SafeStyleSheet
             *     object with.
             * @return {!goog.html.SafeStyleSheet} The initialized SafeStyleSheet object.
             * @package
             */
            SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse = function (styleSheet) {
                return new goog.html.SafeStyleSheet().initSecurityPrivateDoNotAccessOrElse_(styleSheet);
            };
            ;
            /**
             * Type marker for the SafeStyleSheet type, used to implement additional
             * run-time type checking.
             * @const {!Object}
             * @private
             */
            SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
            /**
             * A SafeStyleSheet instance corresponding to the empty string.
             * @const {!goog.html.SafeStyleSheet}
             */
            SafeStyleSheet.EMPTY = goog.html.SafeStyleSheet
                .createSafeStyleSheetSecurityPrivateDoNotAccessOrElse('');
            return SafeStyleSheet;
        }());
        html.SafeStyleSheet = SafeStyleSheet;
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
// Copyright 2015 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Wrapper for URL and its createObjectUrl and revokeObjectUrl
 * methods that are part of the HTML5 File API.
 */
goog.provide('goog.fs.url');
var goog;
(function (goog) {
    var fs;
    (function (fs) {
        var url;
        (function (url_1) {
            /**
             * Creates a blob URL for a blob object.
             * Throws an error if the browser does not support Object Urls.
             *
             * @param {!Blob} blob The object for which to create the URL.
             * @return {string} The URL for the object.
             */
            function createObjectUrl(blob) {
                return goog.fs.url.getUrlObject_().createObjectURL(blob);
            }
            url_1.createObjectUrl = createObjectUrl;
            ;
            /**
             * Revokes a URL created by {@link goog.fs.url.createObjectUrl}.
             * Throws an error if the browser does not support Object Urls.
             *
             * @param {string} url The URL to revoke.
             */
            function revokeObjectUrl(url) {
                goog.fs.url.getUrlObject_().revokeObjectURL(url);
            }
            url_1.revokeObjectUrl = revokeObjectUrl;
            ;
            /**
             * Get the object that has the createObjectURL and revokeObjectURL functions for
             * this browser.
             *
             * @return {goog.fs.url.UrlObject_} The object for this browser.
             * @private
             */
            function getUrlObject_() {
                var urlObject = goog.fs.url.findUrlObject_();
                if (urlObject != null) {
                    return urlObject;
                }
                else {
                    throw new Error('This browser doesn\'t seem to support blob URLs');
                }
            }
            url_1.getUrlObject_ = getUrlObject_;
            ;
            /**
             * Finds the object that has the createObjectURL and revokeObjectURL functions
             * for this browser.
             *
             * @return {?goog.fs.url.UrlObject_} The object for this browser or null if the
             *     browser does not support Object Urls.
             * @private
             */
            function findUrlObject_() {
                // This is what the spec says to do
                // http://dev.w3.org/2006/webapi/FileAPI/#dfn-createObjectURL
                if (goog.isDef(goog.global.URL) &&
                    goog.isDef(goog.global.URL.createObjectURL)) {
                    return /** @type {goog.fs.url.UrlObject_} */ (goog.global.URL);
                    // This is what Chrome does (as of 10.0.648.6 dev)
                }
                else if (goog.isDef(goog.global.webkitURL) &&
                    goog.isDef(goog.global.webkitURL.createObjectURL)) {
                    return /** @type {goog.fs.url.UrlObject_} */ (goog.global.webkitURL);
                    // This is what the spec used to say to do
                }
                else if (goog.isDef(goog.global.createObjectURL)) {
                    return /** @type {goog.fs.url.UrlObject_} */ (goog.global);
                }
                else {
                    return null;
                }
            }
            url_1.findUrlObject_ = findUrlObject_;
            ;
            /**
             * Checks whether this browser supports Object Urls. If not, calls to
             * createObjectUrl and revokeObjectUrl will result in an error.
             *
             * @return {boolean} True if this browser supports Object Urls.
             */
            function browserSupportsObjectUrls() {
                return goog.fs.url.findUrlObject_() != null;
            }
            url_1.browserSupportsObjectUrls = browserSupportsObjectUrls;
            ;
        })(url = fs.url || (fs.url = {}));
    })(fs = goog.fs || (goog.fs = {}));
})(goog || (goog = {}));
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview The TrustedResourceUrl type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */
goog.provide('goog.html.TrustedResourceUrl');
goog.require('goog.asserts');
goog.require('goog.i18n.bidi.Dir');
goog.require('goog.i18n.bidi.DirectionalString');
goog.require('goog.string.Const');
goog.require('goog.string.TypedString');
var goog;
(function (goog) {
    var html;
    (function (html) {
        var TrustedResourceUrl = /** @class */ (function () {
            /**
             * A URL which is under application control and from which script, CSS, and
             * other resources that represent executable code, can be fetched.
             *
             * Given that the URL can only be constructed from strings under application
             * control and is used to load resources, bugs resulting in a malformed URL
             * should not have a security impact and are likely to be easily detectable
             * during testing. Given the wide number of non-RFC compliant URLs in use,
             * stricter validation could prevent some applications from being able to use
             * this type.
             *
             * Instances of this type must be created via the factory method,
             * ({@code fromConstant}, {@code fromConstants}, {@code format} or {@code
             * formatWithParams}), and not by invoking its constructor. The constructor
             * intentionally takes no parameters and the type is immutable; hence only a
             * default instance corresponding to the empty string can be obtained via
             * constructor invocation.
             *
             * @see goog.html.TrustedResourceUrl#fromConstant
             * @constructor
             * @final
             * @struct
             * @implements {goog.i18n.bidi.DirectionalString}
             * @implements {goog.string.TypedString}
             */
            function TrustedResourceUrl() {
                /**
                 * @override
                 * @const
                 */
                this.implementsGoogStringTypedString = true;
                /**
                 * @override
                 * @const
                 */
                this.implementsGoogI18nBidiDirectionalString = true;
                /**
                 * The contained value of this TrustedResourceUrl.  The field has a purposely
                 * ugly name to make (non-compiled) code that attempts to directly access this
                 * field stand out.
                 * @private {string}
                 */
                this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = '';
                /**
                 * A type marker used to implement additional run-time type checking.
                 * @see goog.html.TrustedResourceUrl#unwrap
                 * @const {!Object}
                 * @private
                 */
                this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ =
                    goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
            }
            ;
            /**
             * Returns this TrustedResourceUrl's value as a string.
             *
             * IMPORTANT: In code where it is security relevant that an object's type is
             * indeed {@code TrustedResourceUrl}, use
             * {@code goog.html.TrustedResourceUrl.unwrap} instead of this method. If in
             * doubt, assume that it's security relevant. In particular, note that
             * goog.html functions which return a goog.html type do not guarantee that
             * the returned instance is of the right type. For example:
             *
             * <pre>
             * var fakeSafeHtml = new String('fake');
             * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;
             * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);
             * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
             * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml instanceof
             * // goog.html.SafeHtml.
             * </pre>
             *
             * @see goog.html.TrustedResourceUrl#unwrap
             * @override
             */
            TrustedResourceUrl.prototype.getTypedStringValue = function () {
                return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;
            };
            ;
            /**
             * Returns this URLs directionality, which is always {@code LTR}.
             * @override
             */
            TrustedResourceUrl.prototype.getDirection = function () {
                return goog.i18n.bidi.Dir.LTR;
            };
            ;
            /**
             * Creates a new TrustedResourceUrl with params added to URL.
             * @param {!Object<string, *>} params Parameters to add to URL. Parameters with
             *     value {@code null} or {@code undefined} are skipped. Both keys and values
             *     are encoded. If the value is an array then the same parameter is added
             *     for every element in the array. Note that JavaScript doesn't guarantee
             *     the order of values in an object which might result in non-deterministic
             *     order of the parameters. However, browsers currently preserve the order.
             * @return {!goog.html.TrustedResourceUrl} New TrustedResourceUrl with params.
             */
            TrustedResourceUrl.prototype.cloneWithParams = function (params) {
                var url = goog.html.TrustedResourceUrl.unwrap(this);
                var separator = /\?/.test(url) ? '&' : '?';
                for (var key in params) {
                    var values = goog.isArray(params[key]) ? params[key] : [params[key]];
                    for (var i = 0; i < values.length; i++) {
                        if (values[i] == null) {
                            continue;
                        }
                        url += separator + encodeURIComponent(key) + '=' +
                            encodeURIComponent(String(values[i]));
                        separator = '&';
                    }
                }
                return goog.html.TrustedResourceUrl
                    .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(url);
            };
            ;
            return TrustedResourceUrl;
        }());
        html.TrustedResourceUrl = TrustedResourceUrl;
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
(function (goog) {
    var html;
    (function (html) {
        var TrustedResourceUrl;
        (function (TrustedResourceUrl) {
            /**
             * Performs a runtime check that the provided object is indeed a
             * TrustedResourceUrl object, and returns its value.
             *
             * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl The object to
             *     extract from.
             * @return {string} The trustedResourceUrl object's contained string, unless
             *     the run-time type check fails. In that case, {@code unwrap} returns an
             *     innocuous string, or, if assertions are enabled, throws
             *     {@code goog.asserts.AssertionError}.
             */
            function unwrap(trustedResourceUrl) {
                // Perform additional Run-time type-checking to ensure that
                // trustedResourceUrl is indeed an instance of the expected type.  This
                // provides some additional protection against security bugs due to
                // application code that disables type checks.
                // Specifically, the following checks are performed:
                // 1. The object is an instance of the expected type.
                // 2. The object is not an instance of a subclass.
                // 3. The object carries a type marker for the expected type. "Faking" an
                // object requires a reference to the type marker, which has names intended
                // to stand out in code reviews.
                if (trustedResourceUrl instanceof goog.html.TrustedResourceUrl &&
                    trustedResourceUrl.constructor === goog.html.TrustedResourceUrl &&
                    trustedResourceUrl
                        .TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ===
                        goog.html.TrustedResourceUrl
                            .TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
                    return trustedResourceUrl
                        .privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;
                }
                else {
                    goog.asserts.fail('expected object of type TrustedResourceUrl, got \'' +
                        trustedResourceUrl + '\' of type ' + goog.typeOf(trustedResourceUrl));
                    return 'type_error:TrustedResourceUrl';
                }
            }
            TrustedResourceUrl.unwrap = unwrap;
            ;
            /**
             * Creates a TrustedResourceUrl from a format string and arguments.
             *
             * The arguments for interpolation into the format string map labels to values.
             * Values of type `goog.string.Const` are interpolated without modifcation.
             * Values of other types are cast to string and encoded with
             * encodeURIComponent.
             *
             * `%{<label>}` markers are used in the format string to indicate locations
             * to be interpolated with the valued mapped to the given label. `<label>`
             * must contain only alphanumeric and `_` characters.
             *
             * The format string must start with one of the following:
             * - `https://<origin>/`
             * - `//<origin>/`
             * - `/<pathStart>`
             * - `about:blank`
             *
             * `<origin>` must contain only alphanumeric or any of the following: `-.:[]`.
             * `<pathStart>` is any character except `/` and `\`.
             *
             * Example usage:
             *
             *    var url = goog.html.TrustedResourceUrl.format(goog.string.Const.from(
             *        'https://www.google.com/search?q=%{query}'), {'query': searchTerm});
             *
             *    var url = goog.html.TrustedResourceUrl.format(goog.string.Const.from(
             *        '//www.youtube.com/v/%{videoId}?hl=en&fs=1%{autoplay}'), {
             *        'videoId': videoId,
             *        'autoplay': opt_autoplay ?
             *            goog.string.Const.from('&autoplay=1') : goog.string.Const.EMPTY
             *    });
             *
             * While this function can be used to create a TrustedResourceUrl from only
             * constants, fromConstant() and fromConstants() are generally preferable for
             * that purpose.
             *
             * @param {!goog.string.Const} format The format string.
             * @param {!Object<string, (string|number|!goog.string.Const)>} args Mapping
             *     of labels to values to be interpolated into the format string.
             *     goog.string.Const values are interpolated without encoding.
             * @return {!goog.html.TrustedResourceUrl}
             * @throws {!Error} On an invalid format string or if a label used in the
             *     the format string is not present in args.
             */
            function format(format, args) {
                var formatStr = goog.string.Const.unwrap(format);
                if (!goog.html.TrustedResourceUrl.BASE_URL_.test(formatStr)) {
                    throw new Error('Invalid TrustedResourceUrl format: ' + formatStr);
                }
                var result = formatStr.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_, function (match, id) {
                    if (!Object.prototype.hasOwnProperty.call(args, id)) {
                        throw new Error('Found marker, "' + id + '", in format string, "' + formatStr +
                            '", but no valid label mapping found ' +
                            'in args: ' + JSON.stringify(args));
                    }
                    var arg = args[id];
                    if (arg instanceof goog.string.Const) {
                        return goog.string.Const.unwrap(arg);
                    }
                    else {
                        return encodeURIComponent(String(arg));
                    }
                });
                return goog.html.TrustedResourceUrl
                    .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(result);
            }
            TrustedResourceUrl.format = format;
            ;
            /**
             * @private @const {!RegExp}
             */
            TrustedResourceUrl.FORMAT_MARKER_ = /%{(\w+)}/g;
            /**
             * The URL must be absolute, scheme-relative or path-absolute. So it must
             * start with:
             * - https:// followed by allowed origin characters.
             * - // followed by allowed origin characters.
             * - / not followed by / or \. There will only be an absolute path.
             *
             * Based on
             * https://url.spec.whatwg.org/commit-snapshots/56b74ce7cca8883eab62e9a12666e2fac665d03d/#url-parsing
             * an initial / which is not followed by another / or \ will end up in the "path
             * state" and from there it can only go to "fragment state" and "query state".
             *
             * We don't enforce a well-formed domain name. So '.' or '1.2' are valid.
             * That's ok because the origin comes from a compile-time constant.
             *
             * A regular expression is used instead of goog.uri for several reasons:
             * - Strictness. E.g. we don't want any userinfo component and we don't
             *   want '/./, nor \' in the first path component.
             * - Small trusted base. goog.uri is generic and might need to change,
             *   reasoning about all the ways it can parse a URL now and in the future
             *   is error-prone.
             * - Code size. We expect many calls to .format(), many of which might
             *   not be using goog.uri.
             * - Simplicity. Using goog.uri would likely not result in simpler nor shorter
             *   code.
             * @private @const {!RegExp}
             */
            TrustedResourceUrl.BASE_URL_ = /^(?:https:)?\/\/[0-9a-z.:[\]-]+\/|^\/[^\/\\]|^about:blank(#|$)/i;
            /**
             * Formats the URL same as TrustedResourceUrl.format and then adds extra URL
             * parameters.
             *
             * Example usage:
             *
             *     // Creates '//www.youtube.com/v/abc?autoplay=1' for videoId='abc' and
             *     // opt_autoplay=1. Creates '//www.youtube.com/v/abc' for videoId='abc'
             *     // and opt_autoplay=undefined.
             *     var url = goog.html.TrustedResourceUrl.formatWithParams(
             *         goog.string.Const.from('//www.youtube.com/v/%{videoId}'),
             *         {'videoId': videoId},
             *         {'autoplay': opt_autoplay});
             *
             * @param {!goog.string.Const} format The format string.
             * @param {!Object<string, (string|number|!goog.string.Const)>} args Mapping
             *     of labels to values to be interpolated into the format string.
             *     goog.string.Const values are interpolated without encoding.
             * @param {!Object<string, *>} params Parameters to add to URL. Parameters with
             *     value {@code null} or {@code undefined} are skipped. Both keys and values
             *     are encoded. If the value is an array then the same parameter is added
             *     for every element in the array. Note that JavaScript doesn't guarantee
             *     the order of values in an object which might result in non-deterministic
             *     order of the parameters. However, browsers currently preserve the order.
             * @return {!goog.html.TrustedResourceUrl}
             * @throws {!Error} On an invalid format string or if a label used in the
             *     the format string is not present in args.
             */
            function formatWithParams(format, args, params) {
                var url = goog.html.TrustedResourceUrl.format(format, args);
                return url.cloneWithParams(params);
            }
            TrustedResourceUrl.formatWithParams = formatWithParams;
            ;
            /**
             * Creates a TrustedResourceUrl object from a compile-time constant string.
             *
             * Compile-time constant strings are inherently program-controlled and hence
             * trusted.
             *
             * @param {!goog.string.Const} url A compile-time-constant string from which to
             *     create a TrustedResourceUrl.
             * @return {!goog.html.TrustedResourceUrl} A TrustedResourceUrl object
             *     initialized to {@code url}.
             */
            function fromConstant(url) {
                return goog.html.TrustedResourceUrl
                    .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(url));
            }
            TrustedResourceUrl.fromConstant = fromConstant;
            ;
            /**
             * Creates a TrustedResourceUrl object from a compile-time constant strings.
             *
             * Compile-time constant strings are inherently program-controlled and hence
             * trusted.
             *
             * @param {!Array<!goog.string.Const>} parts Compile-time-constant strings from
             *     which to create a TrustedResourceUrl.
             * @return {!goog.html.TrustedResourceUrl} A TrustedResourceUrl object
             *     initialized to concatenation of {@code parts}.
             */
            function fromConstants(parts) {
                var unwrapped = '';
                for (var i = 0; i < parts.length; i++) {
                    unwrapped += goog.string.Const.unwrap(parts[i]);
                }
                return goog.html.TrustedResourceUrl
                    .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(unwrapped);
            }
            TrustedResourceUrl.fromConstants = fromConstants;
            ;
            /**
             * Type marker for the TrustedResourceUrl type, used to implement additional
             * run-time type checking.
             * @const {!Object}
             * @private
             */
            TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
            /**
             * Package-internal utility method to create TrustedResourceUrl instances.
             *
             * @param {string} url The string to initialize the TrustedResourceUrl object
             *     with.
             * @return {!goog.html.TrustedResourceUrl} The initialized TrustedResourceUrl
             *     object.
             * @package
             */
            function createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(url) {
                var trustedResourceUrl = new goog.html.TrustedResourceUrl();
                trustedResourceUrl.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ =
                    url;
                return trustedResourceUrl;
            }
            TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse;
            ;
        })(TrustedResourceUrl = html.TrustedResourceUrl || (html.TrustedResourceUrl = {}));
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utility functions for supporting Bidi issues.
 */
/**
 * Namespace for bidi supporting functions.
 */
goog.provide('goog.i18n.bidi');
goog.provide('goog.i18n.bidi.Dir');
goog.provide('goog.i18n.bidi.DirectionalString');
goog.provide('goog.i18n.bidi.Format');
var goog;
(function (goog) {
    var i18n;
    (function (i18n) {
        var bidi;
        (function (bidi) {
            /**
             * @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant
             * to say that the current locale is a RTL locale.  This should only be used
             * if you want to override the default behavior for deciding whether the
             * current locale is RTL or not.
             *
             * {@see goog.i18n.bidi.IS_RTL}
             */
            bidi.FORCE_RTL = false;
            /**
             * Constant that defines whether or not the current locale is a RTL locale.
             * If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default
             * to check that {@link goog.LOCALE} is one of a few major RTL locales.
             *
             * <p>This is designed to be a maximally efficient compile-time constant. For
             * example, for the default goog.LOCALE, compiling
             * "if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}" should produce no code. It
             * is this design consideration that limits the implementation to only
             * supporting a few major RTL locales, as opposed to the broader repertoire of
             * something like goog.i18n.bidi.isRtlLanguage.
             *
             * <p>Since this constant refers to the directionality of the locale, it is up
             * to the caller to determine if this constant should also be used for the
             * direction of the UI.
             *
             * {@see goog.LOCALE}
             *
             * @type {boolean}
             *
             * TODO(user): write a test that checks that this is a compile-time constant.
             */
            bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL ||
                ((goog.LOCALE.substring(0, 2).toLowerCase() == 'ar' ||
                    goog.LOCALE.substring(0, 2).toLowerCase() == 'fa' ||
                    goog.LOCALE.substring(0, 2).toLowerCase() == 'he' ||
                    goog.LOCALE.substring(0, 2).toLowerCase() == 'iw' ||
                    goog.LOCALE.substring(0, 2).toLowerCase() == 'ps' ||
                    goog.LOCALE.substring(0, 2).toLowerCase() == 'sd' ||
                    goog.LOCALE.substring(0, 2).toLowerCase() == 'ug' ||
                    goog.LOCALE.substring(0, 2).toLowerCase() == 'ur' ||
                    goog.LOCALE.substring(0, 2).toLowerCase() == 'yi') &&
                    (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == '-' ||
                        goog.LOCALE.substring(2, 3) == '_')) ||
                (goog.LOCALE.length >= 3 &&
                    goog.LOCALE.substring(0, 3).toLowerCase() == 'ckb' &&
                    (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == '-' ||
                        goog.LOCALE.substring(3, 4) == '_'));
            /**
             * Unicode formatting characters and directionality string constants.
             * @enum {string}
             */
            var Format;
            (function (Format) {
                /** Unicode "Left-To-Right Embedding" (LRE) character. */
                Format["LRE"] = "\u202A";
                /** Unicode "Right-To-Left Embedding" (RLE) character. */
                Format["RLE"] = "\u202B";
                /** Unicode "Pop Directional Formatting" (PDF) character. */
                Format["PDF"] = "\u202C";
                /** Unicode "Left-To-Right Mark" (LRM) character. */
                Format["LRM"] = "\u200E";
                /** Unicode "Right-To-Left Mark" (RLM) character. */
                Format["RLM"] = "\u200F";
            })(Format = bidi.Format || (bidi.Format = {}));
            ;
            /**
             * Directionality enum.
             * @enum {number}
             */
            var Dir;
            (function (Dir) {
                /**
                 * Left-to-right.
                 */
                Dir[Dir["LTR"] = 1] = "LTR";
                /**
                 * Right-to-left.
                 */
                Dir[Dir["RTL"] = -1] = "RTL";
                /**
                 * Neither left-to-right nor right-to-left.
                 */
                Dir[Dir["NEUTRAL"] = 0] = "NEUTRAL";
            })(Dir = bidi.Dir || (bidi.Dir = {}));
            ;
            /**
             * 'right' string constant.
             * @type {string}
             */
            bidi.RIGHT = 'right';
            /**
             * 'left' string constant.
             * @type {string}
             */
            bidi.LEFT = 'left';
            /**
             * 'left' if locale is RTL, 'right' if not.
             * @type {string}
             */
            bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;
            /**
             * 'right' if locale is RTL, 'left' if not.
             * @type {string}
             */
            bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;
            /**
             * Convert a directionality given in various formats to a goog.i18n.bidi.Dir
             * constant. Useful for interaction with different standards of directionality
             * representation.
             *
             * @param {goog.i18n.bidi.Dir|number|boolean|null} givenDir Directionality given
             *     in one of the following formats:
             *     1. A goog.i18n.bidi.Dir constant.
             *     2. A number (positive = LTR, negative = RTL, 0 = neutral).
             *     3. A boolean (true = RTL, false = LTR).
             *     4. A null for unknown directionality.
             * @param {boolean=} opt_noNeutral Whether a givenDir of zero or
             *     goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in
             *     order to preserve legacy behavior.
             * @return {?goog.i18n.bidi.Dir} A goog.i18n.bidi.Dir constant matching the
             *     given directionality. If given null, returns null (i.e. unknown).
             */
            function toDir(givenDir, opt_noNeutral) {
                if (typeof givenDir == 'number') {
                    // This includes the non-null goog.i18n.bidi.Dir case.
                    return givenDir > 0 ? goog.i18n.bidi.Dir.LTR : givenDir < 0 ?
                        goog.i18n.bidi.Dir.RTL :
                        opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;
                }
                else if (givenDir == null) {
                    return null;
                }
                else {
                    // Must be typeof givenDir == 'boolean'.
                    return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
                }
            }
            bidi.toDir = toDir;
            ;
            /**
             * A practical pattern to identify strong LTR characters. This pattern is not
             * theoretically correct according to the Unicode standard. It is simplified for
             * performance and small code size.
             * @type {string}
             * @private
             */
            bidi.ltrChars_ = 'A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF' +
                '\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF';
            /**
             * A practical pattern to identify strong RTL character. This pattern is not
             * theoretically correct according to the Unicode standard. It is simplified
             * for performance and small code size.
             * @type {string}
             * @private
             */
            bidi.rtlChars_ = '\u0591-\u06EF\u06FA-\u07FF\u200F\uFB1D-\uFDFF\uFE70-\uFEFC';
            /**
             * Simplified regular expression for an HTML tag (opening or closing) or an HTML
             * escape. We might want to skip over such expressions when estimating the text
             * directionality.
             * @type {RegExp}
             * @private
             */
            bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;
            /**
             * Returns the input text with spaces instead of HTML tags or HTML escapes, if
             * opt_isStripNeeded is true. Else returns the input as is.
             * Useful for text directionality estimation.
             * Note: the function should not be used in other contexts; it is not 100%
             * correct, but rather a good-enough implementation for directionality
             * estimation purposes.
             * @param {string} str The given string.
             * @param {boolean=} opt_isStripNeeded Whether to perform the stripping.
             *     Default: false (to retain consistency with calling functions).
             * @return {string} The given string cleaned of HTML tags / escapes.
             * @private
             */
            function stripHtmlIfNeeded_(str, opt_isStripNeeded) {
                return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, '') : str;
            }
            bidi.stripHtmlIfNeeded_ = stripHtmlIfNeeded_;
            ;
            /**
             * Regular expression to check for RTL characters.
             * @type {RegExp}
             * @private
             */
            bidi.rtlCharReg_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + ']');
            /**
             * Regular expression to check for LTR characters.
             * @type {RegExp}
             * @private
             */
            bidi.ltrCharReg_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + ']');
            /**
             * Test whether the given string has any RTL characters in it.
             * @param {string} str The given string that need to be tested.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether the string contains RTL characters.
             */
            function hasAnyRtl(str, opt_isHtml) {
                return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
            }
            bidi.hasAnyRtl = hasAnyRtl;
            ;
            /**
             * Test whether the given string has any RTL characters in it.
             * @param {string} str The given string that need to be tested.
             * @return {boolean} Whether the string contains RTL characters.
             * @deprecated Use hasAnyRtl.
             */
            bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;
            /**
             * Test whether the given string has any LTR characters in it.
             * @param {string} str The given string that need to be tested.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether the string contains LTR characters.
             */
            function hasAnyLtr(str, opt_isHtml) {
                return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
            }
            bidi.hasAnyLtr = hasAnyLtr;
            ;
            /**
             * Regular expression pattern to check if the first character in the string
             * is LTR.
             * @type {RegExp}
             * @private
             */
            bidi.ltrRe_ = new RegExp('^[' + goog.i18n.bidi.ltrChars_ + ']');
            /**
             * Regular expression pattern to check if the first character in the string
             * is RTL.
             * @type {RegExp}
             * @private
             */
            bidi.rtlRe_ = new RegExp('^[' + goog.i18n.bidi.rtlChars_ + ']');
            /**
             * Check if the first character in the string is RTL or not.
             * @param {string} str The given string that need to be tested.
             * @return {boolean} Whether the first character in str is an RTL char.
             */
            function isRtlChar(str) {
                return goog.i18n.bidi.rtlRe_.test(str);
            }
            bidi.isRtlChar = isRtlChar;
            ;
            /**
             * Check if the first character in the string is LTR or not.
             * @param {string} str The given string that need to be tested.
             * @return {boolean} Whether the first character in str is an LTR char.
             */
            function isLtrChar(str) {
                return goog.i18n.bidi.ltrRe_.test(str);
            }
            bidi.isLtrChar = isLtrChar;
            ;
            /**
             * Check if the first character in the string is neutral or not.
             * @param {string} str The given string that need to be tested.
             * @return {boolean} Whether the first character in str is a neutral char.
             */
            function isNeutralChar(str) {
                return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);
            }
            bidi.isNeutralChar = isNeutralChar;
            ;
            /**
             * Regular expressions to check if a piece of text is of LTR directionality
             * on first character with strong directionality.
             * @type {RegExp}
             * @private
             */
            bidi.ltrDirCheckRe_ = new RegExp('^[^' + goog.i18n.bidi.rtlChars_ + ']*[' + goog.i18n.bidi.ltrChars_ + ']');
            /**
             * Regular expressions to check if a piece of text is of RTL directionality
             * on first character with strong directionality.
             * @type {RegExp}
             * @private
             */
            bidi.rtlDirCheckRe_ = new RegExp('^[^' + goog.i18n.bidi.ltrChars_ + ']*[' + goog.i18n.bidi.rtlChars_ + ']');
            /**
             * Check whether the first strongly directional character (if any) is RTL.
             * @param {string} str String being checked.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether RTL directionality is detected using the first
             *     strongly-directional character method.
             */
            function startsWithRtl(str, opt_isHtml) {
                return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
            }
            bidi.startsWithRtl = startsWithRtl;
            ;
            /**
             * Check whether the first strongly directional character (if any) is RTL.
             * @param {string} str String being checked.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether RTL directionality is detected using the first
             *     strongly-directional character method.
             * @deprecated Use startsWithRtl.
             */
            bidi.isRtlText = goog.i18n.bidi.startsWithRtl;
            /**
             * Check whether the first strongly directional character (if any) is LTR.
             * @param {string} str String being checked.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether LTR directionality is detected using the first
             *     strongly-directional character method.
             */
            function startsWithLtr(str, opt_isHtml) {
                return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
            }
            bidi.startsWithLtr = startsWithLtr;
            ;
            /**
             * Check whether the first strongly directional character (if any) is LTR.
             * @param {string} str String being checked.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether LTR directionality is detected using the first
             *     strongly-directional character method.
             * @deprecated Use startsWithLtr.
             */
            bidi.isLtrText = goog.i18n.bidi.startsWithLtr;
            /**
             * Regular expression to check if a string looks like something that must
             * always be LTR even in RTL text, e.g. a URL. When estimating the
             * directionality of text containing these, we treat these as weakly LTR,
             * like numbers.
             * @type {RegExp}
             * @private
             */
            bidi.isRequiredLtrRe_ = /^http:\/\/.*/;
            /**
             * Check whether the input string either contains no strongly directional
             * characters or looks like a url.
             * @param {string} str String being checked.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether neutral directionality is detected.
             */
            function isNeutralText(str, opt_isHtml) {
                str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);
                return goog.i18n.bidi.isRequiredLtrRe_.test(str) ||
                    !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);
            }
            bidi.isNeutralText = isNeutralText;
            ;
            /**
             * Regular expressions to check if the last strongly-directional character in a
             * piece of text is LTR.
             * @type {RegExp}
             * @private
             */
            bidi.ltrExitDirCheckRe_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + '][^' + goog.i18n.bidi.rtlChars_ + ']*$');
            /**
             * Regular expressions to check if the last strongly-directional character in a
             * piece of text is RTL.
             * @type {RegExp}
             * @private
             */
            bidi.rtlExitDirCheckRe_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + '][^' + goog.i18n.bidi.ltrChars_ + ']*$');
            /**
             * Check if the exit directionality a piece of text is LTR, i.e. if the last
             * strongly-directional character in the string is LTR.
             * @param {string} str String being checked.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether LTR exit directionality was detected.
             */
            function endsWithLtr(str, opt_isHtml) {
                return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
            }
            bidi.endsWithLtr = endsWithLtr;
            ;
            /**
             * Check if the exit directionality a piece of text is LTR, i.e. if the last
             * strongly-directional character in the string is LTR.
             * @param {string} str String being checked.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether LTR exit directionality was detected.
             * @deprecated Use endsWithLtr.
             */
            bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;
            /**
             * Check if the exit directionality a piece of text is RTL, i.e. if the last
             * strongly-directional character in the string is RTL.
             * @param {string} str String being checked.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether RTL exit directionality was detected.
             */
            function endsWithRtl(str, opt_isHtml) {
                return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
            }
            bidi.endsWithRtl = endsWithRtl;
            ;
            /**
             * Check if the exit directionality a piece of text is RTL, i.e. if the last
             * strongly-directional character in the string is RTL.
             * @param {string} str String being checked.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether RTL exit directionality was detected.
             * @deprecated Use endsWithRtl.
             */
            bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;
            /**
             * A regular expression for matching right-to-left language codes.
             * See {@link #isRtlLanguage} for the design.
             * @type {RegExp}
             * @private
             */
            bidi.rtlLocalesRe_ = new RegExp('^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|' +
                '.*[-_](Arab|Hebr|Thaa|Nkoo|Tfng))' +
                '(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)', 'i');
            /**
             * Check if a BCP 47 / III language code indicates an RTL language, i.e. either:
             * - a language code explicitly specifying one of the right-to-left scripts,
             *   e.g. "az-Arab", or<p>
             * - a language code specifying one of the languages normally written in a
             *   right-to-left script, e.g. "fa" (Farsi), except ones explicitly specifying
             *   Latin or Cyrillic script (which are the usual LTR alternatives).<p>
             * The list of right-to-left scripts appears in the 100-199 range in
             * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and
             * Hebrew are by far the most widely used. We also recognize Thaana, N'Ko, and
             * Tifinagh, which also have significant modern usage. The rest (Syriac,
             * Samaritan, Mandaic, etc.) seem to have extremely limited or no modern usage
             * and are not recognized to save on code size.
             * The languages usually written in a right-to-left script are taken as those
             * with Suppress-Script: Hebr|Arab|Thaa|Nkoo|Tfng  in
             * http://www.iana.org/assignments/language-subtag-registry,
             * as well as Central (or Sorani) Kurdish (ckb), Sindhi (sd) and Uyghur (ug).
             * Other subtags of the language code, e.g. regions like EG (Egypt), are
             * ignored.
             * @param {string} lang BCP 47 (a.k.a III) language code.
             * @return {boolean} Whether the language code is an RTL language.
             */
            function isRtlLanguage(lang) {
                return goog.i18n.bidi.rtlLocalesRe_.test(lang);
            }
            bidi.isRtlLanguage = isRtlLanguage;
            ;
            /**
             * Regular expression for bracket guard replacement in text.
             * @type {RegExp}
             * @private
             */
            bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
            /**
             * Apply bracket guard using LRM and RLM. This is to address the problem of
             * messy bracket display frequently happens in RTL layout.
             * This function works for plain text, not for HTML. In HTML, the opening
             * bracket might be in a different context than the closing bracket (such as
             * an attribute value).
             * @param {string} s The string that need to be processed.
             * @param {boolean=} opt_isRtlContext specifies default direction (usually
             *     direction of the UI).
             * @return {string} The processed string, with all bracket guarded.
             */
            function guardBracketInText(s, opt_isRtlContext) {
                var useRtl = opt_isRtlContext === undefined ? goog.i18n.bidi.hasAnyRtl(s) :
                    opt_isRtlContext;
                var mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;
                return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + '$&' + mark);
            }
            bidi.guardBracketInText = guardBracketInText;
            ;
            /**
             * Enforce the html snippet in RTL directionality regardless overall context.
             * If the html piece was enclosed by tag, dir will be applied to existing
             * tag, otherwise a span tag will be added as wrapper. For this reason, if
             * html snippet start with with tag, this tag must enclose the whole piece. If
             * the tag already has a dir specified, this new one will override existing
             * one in behavior (tested on FF and IE).
             * @param {string} html The string that need to be processed.
             * @return {string} The processed string, with directionality enforced to RTL.
             */
            function enforceRtlInHtml(html) {
                if (html.charAt(0) == '<') {
                    return html.replace(/<\w+/, '$& dir=rtl');
                }
                // '\n' is important for FF so that it won't incorrectly merge span groups
                return '\n<span dir=rtl>' + html + '</span>';
            }
            bidi.enforceRtlInHtml = enforceRtlInHtml;
            ;
            /**
             * Enforce RTL on both end of the given text piece using unicode BiDi formatting
             * characters RLE and PDF.
             * @param {string} text The piece of text that need to be wrapped.
             * @return {string} The wrapped string after process.
             */
            function enforceRtlInText(text) {
                return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;
            }
            bidi.enforceRtlInText = enforceRtlInText;
            ;
            /**
             * Enforce the html snippet in RTL directionality regardless overall context.
             * If the html piece was enclosed by tag, dir will be applied to existing
             * tag, otherwise a span tag will be added as wrapper. For this reason, if
             * html snippet start with with tag, this tag must enclose the whole piece. If
             * the tag already has a dir specified, this new one will override existing
             * one in behavior (tested on FF and IE).
             * @param {string} html The string that need to be processed.
             * @return {string} The processed string, with directionality enforced to RTL.
             */
            function enforceLtrInHtml(html) {
                if (html.charAt(0) == '<') {
                    return html.replace(/<\w+/, '$& dir=ltr');
                }
                // '\n' is important for FF so that it won't incorrectly merge span groups
                return '\n<span dir=ltr>' + html + '</span>';
            }
            bidi.enforceLtrInHtml = enforceLtrInHtml;
            ;
            /**
             * Enforce LTR on both end of the given text piece using unicode BiDi formatting
             * characters LRE and PDF.
             * @param {string} text The piece of text that need to be wrapped.
             * @return {string} The wrapped string after process.
             */
            function enforceLtrInText(text) {
                return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;
            }
            bidi.enforceLtrInText = enforceLtrInText;
            ;
            /**
             * Regular expression to find dimensions such as "padding: .3 0.4ex 5px 6;"
             * @type {RegExp}
             * @private
             */
            bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;
            /**
             * Regular expression for left.
             * @type {RegExp}
             * @private
             */
            bidi.leftRe_ = /left/gi;
            /**
             * Regular expression for right.
             * @type {RegExp}
             * @private
             */
            bidi.rightRe_ = /right/gi;
            /**
             * Placeholder regular expression for swapping.
             * @type {RegExp}
             * @private
             */
            bidi.tempRe_ = /%%%%/g;
            /**
             * Swap location parameters and 'left'/'right' in CSS specification. The
             * processed string will be suited for RTL layout. Though this function can
             * cover most cases, there are always exceptions. It is suggested to put
             * those exceptions in separate group of CSS string.
             * @param {string} cssStr CSS spefication string.
             * @return {string} Processed CSS specification string.
             */
            function mirrorCSS(cssStr) {
                return cssStr
                    .
                        // reverse dimensions
                        replace(goog.i18n.bidi.dimensionsRe_, ':$1 $4 $3 $2')
                    .replace(goog.i18n.bidi.leftRe_, '%%%%')
                    .
                        replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT)
                    .replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
            }
            bidi.mirrorCSS = mirrorCSS;
            ;
            /**
             * Regular expression for hebrew double quote substitution, finding quote
             * directly after hebrew characters.
             * @type {RegExp}
             * @private
             */
            bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g;
            /**
             * Regular expression for hebrew single quote substitution, finding quote
             * directly after hebrew characters.
             * @type {RegExp}
             * @private
             */
            bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g;
            /**
             * Replace the double and single quote directly after a Hebrew character with
             * GERESH and GERSHAYIM. In such case, most likely that's user intention.
             * @param {string} str String that need to be processed.
             * @return {string} Processed string with double/single quote replaced.
             */
            function normalizeHebrewQuote(str) {
                return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, '$1\u05f4')
                    .replace(goog.i18n.bidi.singleQuoteSubstituteRe_, '$1\u05f3');
            }
            bidi.normalizeHebrewQuote = normalizeHebrewQuote;
            ;
            /**
             * Regular expression to split a string into "words" for directionality
             * estimation based on relative word counts.
             * @type {RegExp}
             * @private
             */
            bidi.wordSeparatorRe_ = /\s+/;
            /**
             * Regular expression to check if a string contains any numerals. Used to
             * differentiate between completely neutral strings and those containing
             * numbers, which are weakly LTR.
             *
             * Native Arabic digits (\u0660 - \u0669) are not included because although they
             * do flow left-to-right inside a number, this is the case even if the  overall
             * directionality is RTL, and a mathematical expression using these digits is
             * supposed to flow right-to-left overall, including unary plus and minus
             * appearing to the right of a number, and this does depend on the overall
             * directionality being RTL. The digits used in Farsi (\u06F0 - \u06F9), on the
             * other hand, are included, since Farsi math (including unary plus and minus)
             * does flow left-to-right.
             *
             * @type {RegExp}
             * @private
             */
            bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/;
            /**
             * This constant controls threshold of RTL directionality.
             * @type {number}
             * @private
             */
            bidi.rtlDetectionThreshold_ = 0.40;
            /**
             * Estimates the directionality of a string based on relative word counts.
             * If the number of RTL words is above a certain percentage of the total number
             * of strongly directional words, returns RTL.
             * Otherwise, if any words are strongly or weakly LTR, returns LTR.
             * Otherwise, returns UNKNOWN, which is used to mean "neutral".
             * Numbers are counted as weakly LTR.
             * @param {string} str The string to be checked.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {goog.i18n.bidi.Dir} Estimated overall directionality of {@code str}.
             */
            function estimateDirection(str, opt_isHtml) {
                var rtlCount = 0;
                var totalCount = 0;
                var hasWeaklyLtr = false;
                var tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml)
                    .split(goog.i18n.bidi.wordSeparatorRe_);
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (goog.i18n.bidi.startsWithRtl(token)) {
                        rtlCount++;
                        totalCount++;
                    }
                    else if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) {
                        hasWeaklyLtr = true;
                    }
                    else if (goog.i18n.bidi.hasAnyLtr(token)) {
                        totalCount++;
                    }
                    else if (goog.i18n.bidi.hasNumeralsRe_.test(token)) {
                        hasWeaklyLtr = true;
                    }
                }
                return totalCount == 0 ?
                    (hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL) :
                    (rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ?
                        goog.i18n.bidi.Dir.RTL :
                        goog.i18n.bidi.Dir.LTR);
            }
            bidi.estimateDirection = estimateDirection;
            ;
            /**
             * Check the directionality of a piece of text, return true if the piece of
             * text should be laid out in RTL direction.
             * @param {string} str The piece of text that need to be detected.
             * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
             *     Default: false.
             * @return {boolean} Whether this piece of text should be laid out in RTL.
             */
            function detectRtlDirectionality(str, opt_isHtml) {
                return goog.i18n.bidi.estimateDirection(str, opt_isHtml) ==
                    goog.i18n.bidi.Dir.RTL;
            }
            bidi.detectRtlDirectionality = detectRtlDirectionality;
            ;
            /**
             * Sets text input element's directionality and text alignment based on a
             * given directionality. Does nothing if the given directionality is unknown or
             * neutral.
             * @param {Element} element Input field element to set directionality to.
             * @param {goog.i18n.bidi.Dir|number|boolean|null} dir Desired directionality,
             *     given in one of the following formats:
             *     1. A goog.i18n.bidi.Dir constant.
             *     2. A number (positive = LRT, negative = RTL, 0 = neutral).
             *     3. A boolean (true = RTL, false = LTR).
             *     4. A null for unknown directionality.
             */
            function setElementDirAndAlign(element, dir) {
                if (element) {
                    dir = goog.i18n.bidi.toDir(dir);
                    if (dir) {
                        element.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ?
                            goog.i18n.bidi.RIGHT :
                            goog.i18n.bidi.LEFT;
                        element.dir = dir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';
                    }
                }
            }
            bidi.setElementDirAndAlign = setElementDirAndAlign;
            ;
            /**
             * Sets element dir based on estimated directionality of the given text.
             * @param {!Element} element
             * @param {string} text
             */
            function setElementDirByTextDirectionality(element, text) {
                switch (goog.i18n.bidi.estimateDirection(text)) {
                    case (goog.i18n.bidi.Dir.LTR):
                        element.dir = 'ltr';
                        break;
                    case (goog.i18n.bidi.Dir.RTL):
                        element.dir = 'rtl';
                        break;
                    default:
                        // Default for no direction, inherit from document.
                        element.removeAttribute('dir');
                }
            }
            bidi.setElementDirByTextDirectionality = setElementDirByTextDirectionality;
            ;
        })(bidi = i18n.bidi || (i18n.bidi = {}));
    })(i18n = goog.i18n || (goog.i18n = {}));
})(goog || (goog = {}));
/**
 * @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant
 * to say that the current locale is a RTL locale.  This should only be used
 * if you want to override the default behavior for deciding whether the
 * current locale is RTL or not.
 *
 * {@see goog.i18n.bidi.IS_RTL}
 */
goog.define('goog.i18n.bidi.FORCE_RTL', false);
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
goog.provide('goog.string.TypedString');
/// <reference path="../specialtype.ts" />
/// <reference path="../base.ts" />
/// <reference path="../asserts/asserts.ts" />
/// <reference path="../fs/url.ts" />
/// <reference path="../html/trustedresourceurl.ts" />
/// <reference path="../i18n/bidi.ts" />
/// <reference path="../i18n/bidi.ts" />
/// <reference path="../string/string.ts" />
/// <reference path="../string/const.ts" />
/// <reference path="../string/typedstring.ts" />
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview The SafeUrl type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */
goog.provide('goog.html.SafeUrl');
goog.require('goog.asserts');
goog.require('goog.fs.url');
goog.require('goog.html.TrustedResourceUrl');
goog.require('goog.i18n.bidi.Dir');
goog.require('goog.i18n.bidi.DirectionalString');
goog.require('goog.string');
goog.require('goog.string.Const');
goog.require('goog.string.TypedString');
var goog;
(function (goog) {
    var html;
    (function (html) {
        var SafeUrl = /** @class */ (function () {
            /**
             * A string that is safe to use in URL context in DOM APIs and HTML documents.
             *
             * A SafeUrl is a string-like object that carries the security type contract
             * that its value as a string will not cause untrusted script execution
             * when evaluated as a hyperlink URL in a browser.
             *
             * Values of this type are guaranteed to be safe to use in URL/hyperlink
             * contexts, such as assignment to URL-valued DOM properties, in the sense that
             * the use will not result in a Cross-Site-Scripting vulnerability. Similarly,
             * SafeUrls can be interpolated into the URL context of an HTML template (e.g.,
             * inside a href attribute). However, appropriate HTML-escaping must still be
             * applied.
             *
             * Note that, as documented in {@code goog.html.SafeUrl.unwrap}, this type's
             * contract does not guarantee that instances are safe to interpolate into HTML
             * without appropriate escaping.
             *
             * Note also that this type's contract does not imply any guarantees regarding
             * the resource the URL refers to.  In particular, SafeUrls are <b>not</b>
             * safe to use in a context where the referred-to resource is interpreted as
             * trusted code, e.g., as the src of a script tag.
             *
             * Instances of this type must be created via the factory methods
             * ({@code goog.html.SafeUrl.fromConstant}, {@code goog.html.SafeUrl.sanitize}),
             * etc and not by invoking its constructor.  The constructor intentionally
             * takes no parameters and the type is immutable; hence only a default instance
             * corresponding to the empty string can be obtained via constructor invocation.
             *
             * @see goog.html.SafeUrl#fromConstant
             * @see goog.html.SafeUrl#from
             * @see goog.html.SafeUrl#sanitize
             * @constructor
             * @final
             * @struct
             * @implements {goog.i18n.bidi.DirectionalString}
             * @implements {goog.string.TypedString}
             */
            function SafeUrl() {
                /**
                 * @override
                 * @const
                 */
                this.implementsGoogStringTypedString = true;
                /**
                 * @override
                 * @const
                 */
                this.implementsGoogI18nBidiDirectionalString = true;
                /**
                 * The contained value of this SafeUrl.  The field has a purposely ugly
                 * name to make (non-compiled) code that attempts to directly access this
                 * field stand out.
                 * @private {string}
                 */
                this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = '';
                /**
                 * A type marker used to implement additional run-time type checking.
                 * @see goog.html.SafeUrl#unwrap
                 * @const {!Object}
                 * @private
                 */
                this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ =
                    goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
            }
            ;
            /**
         * Returns this SafeUrl's value a string.
         *
         * IMPORTANT: In code where it is security relevant that an object's type is
         * indeed {@code SafeUrl}, use {@code goog.html.SafeUrl.unwrap} instead of this
         * method. If in doubt, assume that it's security relevant. In particular, note
         * that goog.html functions which return a goog.html type do not guarantee that
         * the returned instance is of the right type. For example:
         *
         * <pre>
         * var fakeSafeHtml = new String('fake');
         * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;
         * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);
         * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
         * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml instanceof
         * // goog.html.SafeHtml.
         * </pre>
         *
         * IMPORTANT: The guarantees of the SafeUrl type contract only extend to the
         * behavior of browsers when interpreting URLs. Values of SafeUrl objects MUST
         * be appropriately escaped before embedding in a HTML document. Note that the
         * required escaping is context-sensitive (e.g. a different escaping is
         * required for embedding a URL in a style property within a style
         * attribute, as opposed to embedding in a href attribute).
         *
         * @see goog.html.SafeUrl#unwrap
         * @override
         */
            SafeUrl.prototype.getTypedStringValue = function () {
                return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
            };
            ;
            /**
             * Returns this URLs directionality, which is always {@code LTR}.
             * @override
             */
            SafeUrl.prototype.getDirection = function () {
                return goog.i18n.bidi.Dir.LTR;
            };
            ;
            // if (goog.DEBUG) {
            /**
             * Returns a debug string-representation of this value.
             *
             * To obtain the actual string value wrapped in a SafeUrl, use
             * {@code goog.html.SafeUrl.unwrap}.
             *
             * @see goog.html.SafeUrl#unwrap
             * @override
             */
            SafeUrl.prototype.toString = function () {
                return 'SafeUrl{' + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ +
                    '}';
            };
            ;
            return SafeUrl;
        }());
        html.SafeUrl = SafeUrl;
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
(function (goog) {
    var html;
    (function (html) {
        var SafeUrl;
        (function (SafeUrl) {
            /**
             * The innocuous string generated by goog.html.SafeUrl.sanitize when passed
             * an unsafe URL.
             *
             * about:invalid is registered in
             * http://www.w3.org/TR/css3-values/#about-invalid.
             * http://tools.ietf.org/html/rfc6694#section-2.2.1 permits about URLs to
             * contain a fragment, which is not to be considered when determining if an
             * about URL is well-known.
             *
             * Using about:invalid seems preferable to using a fixed data URL, since
             * browsers might choose to not report CSP violations on it, as legitimate
             * CSS function calls to attr() can result in this URL being produced. It is
             * also a standard URL which matches exactly the semantics we need:
             * "The about:invalid URI references a non-existent document with a generic
             * error condition. It can be used when a URI is necessary, but the default
             * value shouldn't be resolveable as any type of document".
             *
             * @const {string}
             */
            SafeUrl.INNOCUOUS_STRING = 'about:invalid#zClosurez';
            /**
             * Performs a runtime check that the provided object is indeed a SafeUrl
             * object, and returns its value.
             *
             * IMPORTANT: The guarantees of the SafeUrl type contract only extend to the
             * behavior of  browsers when interpreting URLs. Values of SafeUrl objects MUST
             * be appropriately escaped before embedding in a HTML document. Note that the
             * required escaping is context-sensitive (e.g. a different escaping is
             * required for embedding a URL in a style property within a style
             * attribute, as opposed to embedding in a href attribute).
             *
             * @param {!goog.html.SafeUrl} safeUrl The object to extract from.
             * @return {string} The SafeUrl object's contained string, unless the run-time
             *     type check fails. In that case, {@code unwrap} returns an innocuous
             *     string, or, if assertions are enabled, throws
             *     {@code goog.asserts.AssertionError}.
             */
            function unwrap(safeUrl) {
                // Perform additional Run-time type-checking to ensure that safeUrl is indeed
                // an instance of the expected type.  This provides some additional protection
                // against security bugs due to application code that disables type checks.
                // Specifically, the following checks are performed:
                // 1. The object is an instance of the expected type.
                // 2. The object is not an instance of a subclass.
                // 3. The object carries a type marker for the expected type. "Faking" an
                // object requires a reference to the type marker, which has names intended
                // to stand out in code reviews.
                if (safeUrl instanceof goog.html.SafeUrl &&
                    safeUrl.constructor === goog.html.SafeUrl &&
                    safeUrl.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ===
                        goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
                    return safeUrl.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
                }
                else {
                    goog.asserts.fail('expected object of type SafeUrl, got \'' +
                        safeUrl + '\' of type ' + goog.typeOf(safeUrl));
                    return 'type_error:SafeUrl';
                }
            }
            SafeUrl.unwrap = unwrap;
            ;
            /**
             * Creates a SafeUrl object from a compile-time constant string.
             *
             * Compile-time constant strings are inherently program-controlled and hence
             * trusted.
             *
             * @param {!goog.string.Const} url A compile-time-constant string from which to
             *         create a SafeUrl.
             * @return {!goog.html.SafeUrl} A SafeUrl object initialized to {@code url}.
             */
            function fromConstant(url) {
                return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(url));
            }
            SafeUrl.fromConstant = fromConstant;
            ;
            /**
             * Creates a SafeUrl wrapping a blob URL for the given {@code blob}.
             *
             * The blob URL is created with {@code URL.createObjectURL}. If the MIME type
             * for {@code blob} is not of a known safe audio, image or video MIME type,
             * then the SafeUrl will wrap {@link #INNOCUOUS_STRING}.
             *
             * @see http://www.w3.org/TR/FileAPI/#url
             * @param {!Blob} blob
             * @return {!goog.html.SafeUrl} The blob URL, or an innocuous string wrapped
             *   as a SafeUrl.
             */
            function fromBlob(blob) {
                var url = goog.html.SAFE_MIME_TYPE_PATTERN_.test(blob.type) ?
                    goog.fs.url.createObjectUrl(blob) :
                    goog.html.SafeUrl.INNOCUOUS_STRING;
                return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
            }
            SafeUrl.fromBlob = fromBlob;
            ;
            /**
             * Creates a SafeUrl wrapping a data: URL, after validating it matches a
             * known-safe audio, image or video MIME type.
             *
             * @param {string} dataUrl A valid base64 data URL with one of the whitelisted
             *     audio, image or video MIME types.
             * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}
             *     wrapped as a SafeUrl if it does not pass.
             */
            function fromDataUrl(dataUrl) {
                // There's a slight risk here that a browser sniffs the content type if it
                // doesn't know the MIME type and executes HTML within the data: URL. For this
                // to cause XSS it would also have to execute the HTML in the same origin
                // of the page with the link. It seems unlikely that both of these will
                // happen, particularly in not really old IEs.
                var match = dataUrl.match(goog.html.DATA_URL_PATTERN_);
                var valid = match && goog.html.SAFE_MIME_TYPE_PATTERN_.test(match[1]);
                return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(valid ? dataUrl : goog.html.SafeUrl.INNOCUOUS_STRING);
            }
            SafeUrl.fromDataUrl = fromDataUrl;
            ;
            /**
             * Creates a SafeUrl wrapping a tel: URL.
             *
             * @param {string} telUrl A tel URL.
             * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}
             *     wrapped as a SafeUrl if it does not pass.
             */
            function fromTelUrl(telUrl) {
                // There's a risk that a tel: URL could immediately place a call once
                // clicked, without requiring user confirmation. For that reason it is
                // handled in this separate function.
                if (!goog.string.caseInsensitiveStartsWith(telUrl, 'tel:')) {
                    telUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
                }
                return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(telUrl);
            }
            SafeUrl.fromTelUrl = fromTelUrl;
            ;
            /**
             * Creates a SafeUrl from TrustedResourceUrl. This is safe because
             * TrustedResourceUrl is more tightly restricted than SafeUrl.
             *
             * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl
             * @return {!goog.html.SafeUrl}
             */
            function fromTrustedResourceUrl(trustedResourceUrl) {
                return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(trustedResourceUrl));
            }
            SafeUrl.fromTrustedResourceUrl = fromTrustedResourceUrl;
            ;
            /**
             * Creates a SafeUrl object from {@code url}. If {@code url} is a
             * goog.html.SafeUrl then it is simply returned. Otherwise the input string is
             * validated to match a pattern of commonly used safe URLs.
             *
             * {@code url} may be a URL with the http, https, mailto or ftp scheme,
             * or a relative URL (i.e., a URL without a scheme; specifically, a
             * scheme-relative, absolute-path-relative, or path-relative URL).
             *
             * @see http://url.spec.whatwg.org/#concept-relative-url
             * @param {string|!goog.string.TypedString} url The URL to validate.
             * @return {!goog.html.SafeUrl} The validated URL, wrapped as a SafeUrl.
             */
            function sanitize(url) {
                if (url instanceof goog.html.SafeUrl) {
                    return url;
                }
                else if (url.implementsGoogStringTypedString) {
                    url = url.getTypedStringValue();
                }
                else {
                    url = String(url);
                }
                if (!goog.html.SAFE_URL_PATTERN_.test(url)) {
                    url = goog.html.SafeUrl.INNOCUOUS_STRING;
                }
                return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
            }
            SafeUrl.sanitize = sanitize;
            ;
            /**
             * Creates a SafeUrl object from {@code url}. If {@code url} is a
             * goog.html.SafeUrl then it is simply returned. Otherwise the input string is
             * validated to match a pattern of commonly used safe URLs.
             *
             * {@code url} may be a URL with the http, https, mailto or ftp scheme,
             * or a relative URL (i.e., a URL without a scheme; specifically, a
             * scheme-relative, absolute-path-relative, or path-relative URL).
             *
             * This function asserts (using goog.asserts) that the URL matches this pattern.
             * If it does not, in addition to failing the assert, an innocous URL will be
             * returned.
             *
             * @see http://url.spec.whatwg.org/#concept-relative-url
             * @param {string|!goog.string.TypedString} url The URL to validate.
             * @return {!goog.html.SafeUrl} The validated URL, wrapped as a SafeUrl.
             */
            function sanitizeAssertUnchanged(url) {
                if (url instanceof goog.html.SafeUrl) {
                    return url;
                }
                else if (url.implementsGoogStringTypedString) {
                    url = url.getTypedStringValue();
                }
                else {
                    url = String(url);
                }
                if (!goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(url))) {
                    url = goog.html.SafeUrl.INNOCUOUS_STRING;
                }
                return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
            }
            SafeUrl.sanitizeAssertUnchanged = sanitizeAssertUnchanged;
            ;
            /**
             * Type marker for the SafeUrl type, used to implement additional run-time
             * type checking.
             * @const {!Object}
             * @private
             */
            SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
            /**
             * Package-internal utility method to create SafeUrl instances.
             *
             * @param {string} url The string to initialize the SafeUrl object with.
             * @return {!goog.html.SafeUrl} The initialized SafeUrl object.
             * @package
             */
            function createSafeUrlSecurityPrivateDoNotAccessOrElse(url) {
                var safeUrl = new goog.html.SafeUrl();
                safeUrl.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = url;
                return safeUrl;
            }
            SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse = createSafeUrlSecurityPrivateDoNotAccessOrElse;
            ;
            /**
             * A SafeUrl corresponding to the special about:blank url.
             * @const {!goog.html.SafeUrl}
             */
            SafeUrl.ABOUT_BLANK = goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse('about:blank');
        })(SafeUrl = html.SafeUrl || (html.SafeUrl = {}));
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
(function (goog) {
    var html;
    (function (html) {
        /**
         * A pattern that matches Blob or data types that can have SafeUrls created
         * from URL.createObjectURL(blob) or via a data: URI.
         * @const
         * @private
         */
        html.SAFE_MIME_TYPE_PATTERN_ = new RegExp(
        // Note: Due to content-sniffing concerns, only add MIME types for
        // media formats.
        '^(?:audio/(?:3gpp|3gpp2|aac|midi|mp4|mpeg|ogg|x-m4a|x-wav|webm)|' +
            'image/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|' +
            // TODO(b/68188949): Due to content-sniffing concerns, text/csv should
            // be removed from the whitelist.
            'text/csv|' +
            'video/(?:mpeg|mp4|ogg|webm))$', 'i');
        /**
         * Matches a base-64 data URL, with the first match group being the MIME type.
         * @const
         * @private
         */
        html.DATA_URL_PATTERN_ = /^data:([^;,]*);base64,[a-z0-9+\/]+=*$/i;
        /**
         * A pattern that recognizes a commonly useful subset of URLs that satisfy
         * the SafeUrl contract.
         *
         * This regular expression matches a subset of URLs that will not cause script
         * execution if used in URL context within a HTML document. Specifically, this
         * regular expression matches if (comment from here on and regex copied from
         * Soy's EscapingConventions):
         * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
         * (2) or no protocol.  A protocol must be followed by a colon. The below
         *     allows that by allowing colons only after one of the characters [/?#].
         *     A colon after a hash (#) must be in the fragment.
         *     Otherwise, a colon after a (?) must be in a query.
         *     Otherwise, a colon after a single solidus (/) must be in a path.
         *     Otherwise, a colon after a double solidus (//) must be in the authority
         *     (before port).
         *
         * @private
         * @const {!RegExp}
         */
        html.SAFE_URL_PATTERN_ = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
/// <reference path="../specialtype.ts" />
/// <reference path="../base.ts" />
/// <reference path="../array/array.ts" />
/// <reference path="../asserts/asserts.ts" />
/// <reference path="../dom/tagname.ts" />
/// <reference path="../dom/tags.ts" />
/// <reference path="../html/safescript.ts" />
/// <reference path="../html/safestyle.ts" />
/// <reference path="../html/safestylesheet.ts" />
/// <reference path="../html/safeurl.ts" />
/// <reference path="../html/trustedresourceUrl.ts" />
/// <reference path="../i18n/bidi.ts" />
/// <reference path="../labs/userAgent/browser.ts" />
/// <reference path="../object/object.ts" />
/// <reference path="../string/string.ts" />
/// <reference path="../string/const.ts" />
/// <reference path="../string/typedstring.ts" />
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview The SafeHtml type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */
goog.provide('goog.html.SafeHtml');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom.TagName');
goog.require('goog.dom.tags');
goog.require('goog.html.SafeScript');
goog.require('goog.html.SafeStyle');
goog.require('goog.html.SafeStyleSheet');
goog.require('goog.html.SafeUrl');
goog.require('goog.html.TrustedResourceUrl');
goog.require('goog.i18n.bidi.Dir');
goog.require('goog.i18n.bidi.DirectionalString');
goog.require('goog.labs.userAgent.browser');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.string.Const');
goog.require('goog.string.TypedString');
var goog;
(function (goog) {
    var html;
    (function (html_1) {
        /**
         * A string that is safe to use in HTML context in DOM APIs and HTML documents.
         *
         * A SafeHtml is a string-like object that carries the security type contract
         * that its value as a string will not cause untrusted script execution when
         * evaluated as HTML in a browser.
         *
         * Values of this type are guaranteed to be safe to use in HTML contexts,
         * such as, assignment to the innerHTML DOM property, or interpolation into
         * a HTML template in HTML PC_DATA context, in the sense that the use will not
         * result in a Cross-Site-Scripting vulnerability.
         *
         * Instances of this type must be created via the factory methods
         * ({@code goog.html.SafeHtml.create}, {@code goog.html.SafeHtml.htmlEscape}),
         * etc and not by invoking its constructor.  The constructor intentionally
         * takes no parameters and the type is immutable; hence only a default instance
         * corresponding to the empty string can be obtained via constructor invocation.
         *
         * @see goog.html.SafeHtml#create
         * @see goog.html.SafeHtml#htmlEscape
         * @constructor
         * @final
         * @struct
         * @implements {goog.i18n.bidi.DirectionalString}
         * @implements {goog.string.TypedString}
         */
        var SafeHtml = /** @class */ (function () {
            function SafeHtml() {
                /**
                 * @override
                 * @const
                 */
                this.implementsGoogI18nBidiDirectionalString = true;
                /**
                 * @override
                 * @const
                 */
                this.implementsGoogStringTypedString = true;
                /**
                 * The contained value of this SafeHtml.  The field has a purposely ugly
                 * name to make (non-compiled) code that attempts to directly access this
                 * field stand out.
                 * @private {string}
                 */
                this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = '';
                /**
                 * A type marker used to implement additional run-time type checking.
                 * @see goog.html.SafeHtml#unwrap
                 * @const {!Object}
                 * @private
                 */
                this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ =
                    goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
                /**
                 * This SafeHtml's directionality, or null if unknown.
                 * @private {?goog.i18n.bidi.Dir}
                 */
                this.dir_ = null;
            }
            ;
            /** @override */
            SafeHtml.prototype.getDirection = function () {
                return this.dir_;
            };
            ;
            /**
             * Returns this SafeHtml's value as string.
             *
             * IMPORTANT: In code where it is security relevant that an object's type is
             * indeed {@code SafeHtml}, use {@code goog.html.SafeHtml.unwrap} instead of
             * this method. If in doubt, assume that it's security relevant. In particular,
             * note that goog.html functions which return a goog.html type do not guarantee
             * that the returned instance is of the right type. For example:
             *
             * <pre>
             * var fakeSafeHtml = new String('fake');
             * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;
             * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);
             * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
             * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml
             * // instanceof goog.html.SafeHtml.
             * </pre>
             *
             * @see goog.html.SafeHtml#unwrap
             * @override
             */
            SafeHtml.prototype.getTypedStringValue = function () {
                return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
            };
            ;
            // if (goog.DEBUG) {
            /**
             * Returns a debug string-representation of this value.
             *
             * To obtain the actual string value wrapped in a SafeHtml, use
             * {@code goog.html.SafeHtml.unwrap}.
             *
             * @see goog.html.SafeHtml#unwrap
             * @override
             */
            SafeHtml.prototype.toString = function () {
                return 'SafeHtml{' + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ +
                    '}';
            };
            ;
            // }
            /**
             * Performs a runtime check that the provided object is indeed a SafeHtml
             * object, and returns its value.
             * @param {!goog.html.SafeHtml} safeHtml The object to extract from.
             * @return {string} The SafeHtml object's contained string, unless the run-time
             *     type check fails. In that case, {@code unwrap} returns an innocuous
             *     string, or, if assertions are enabled, throws
             *     {@code goog.asserts.AssertionError}.
             */
            SafeHtml.unwrap = function (safeHtml) {
                // Perform additional run-time type-checking to ensure that safeHtml is indeed
                // an instance of the expected type.  This provides some additional protection
                // against security bugs due to application code that disables type checks.
                // Specifically, the following checks are performed:
                // 1. The object is an instance of the expected type.
                // 2. The object is not an instance of a subclass.
                // 3. The object carries a type marker for the expected type. "Faking" an
                // object requires a reference to the type marker, which has names intended
                // to stand out in code reviews.
                if (safeHtml instanceof goog.html.SafeHtml &&
                    safeHtml.constructor === goog.html.SafeHtml &&
                    safeHtml.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ===
                        goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
                    return safeHtml.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
                }
                else {
                    goog.asserts.fail('expected object of type SafeHtml, got \'' +
                        safeHtml + '\' of type ' + goog.typeOf(safeHtml));
                    return 'type_error:SafeHtml';
                }
            };
            ;
            /**
             * Returns HTML-escaped text as a SafeHtml object.
             *
             * If text is of a type that implements
             * {@code goog.i18n.bidi.DirectionalString}, the directionality of the new
             * {@code SafeHtml} object is set to {@code text}'s directionality, if known.
             * Otherwise, the directionality of the resulting SafeHtml is unknown (i.e.,
             * {@code null}).
             *
             * @param {!goog.html.SafeHtml.TextOrHtml_} textOrHtml The text to escape. If
             *     the parameter is of type SafeHtml it is returned directly (no escaping
             *     is done).
             * @return {!goog.html.SafeHtml} The escaped text, wrapped as a SafeHtml.
             */
            SafeHtml.htmlEscape = function (textOrHtml) {
                if (textOrHtml instanceof goog.html.SafeHtml) {
                    return textOrHtml;
                }
                var dir = null;
                if (textOrHtml.implementsGoogI18nBidiDirectionalString) {
                    dir = textOrHtml.getDirection();
                }
                var textAsString;
                if (textOrHtml.implementsGoogStringTypedString) {
                    textAsString = textOrHtml.getTypedStringValue();
                }
                else {
                    textAsString = String(textOrHtml);
                }
                return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.htmlEscape(textAsString), dir);
            };
            ;
            /**
             * Returns HTML-escaped text as a SafeHtml object, with newlines changed to
             * &lt;br&gt;.
             * @param {!goog.html.SafeHtml.TextOrHtml_} textOrHtml The text to escape. If
             *     the parameter is of type SafeHtml it is returned directly (no escaping
             *     is done).
             * @return {!goog.html.SafeHtml} The escaped text, wrapped as a SafeHtml.
             */
            SafeHtml.htmlEscapePreservingNewlines = function (textOrHtml) {
                if (textOrHtml instanceof goog.html.SafeHtml) {
                    return textOrHtml;
                }
                var html = goog.html.SafeHtml.htmlEscape(textOrHtml);
                return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.newLineToBr(goog.html.SafeHtml.unwrap(html)), html.getDirection());
            };
            ;
            /**
             * Returns HTML-escaped text as a SafeHtml object, with newlines changed to
             * &lt;br&gt; and escaping whitespace to preserve spatial formatting. Character
             * entity #160 is used to make it safer for XML.
             * @param {!goog.html.SafeHtml.TextOrHtml_} textOrHtml The text to escape. If
             *     the parameter is of type SafeHtml it is returned directly (no escaping
             *     is done).
             * @return {!goog.html.SafeHtml} The escaped text, wrapped as a SafeHtml.
             */
            SafeHtml.htmlEscapePreservingNewlinesAndSpaces = function (textOrHtml) {
                if (textOrHtml instanceof goog.html.SafeHtml) {
                    return textOrHtml;
                }
                var html = goog.html.SafeHtml.htmlEscape(textOrHtml);
                return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.whitespaceEscape(goog.html.SafeHtml.unwrap(html)), html.getDirection());
            };
            ;
            /**
             * Creates a SafeHtml content consisting of a tag with optional attributes and
             * optional content.
             *
             * For convenience tag names and attribute names are accepted as regular
             * strings, instead of goog.string.Const. Nevertheless, you should not pass
             * user-controlled values to these parameters. Note that these parameters are
             * syntactically validated at runtime, and invalid values will result in
             * an exception.
             *
             * Example usage:
             *
             * goog.html.SafeHtml.create('br');
             * goog.html.SafeHtml.create('div', {'class': 'a'});
             * goog.html.SafeHtml.create('p', {}, 'a');
             * goog.html.SafeHtml.create('p', {}, goog.html.SafeHtml.create('br'));
             *
             * goog.html.SafeHtml.create('span', {
             *   'style': {'margin': '0'}
             * });
             *
             * To guarantee SafeHtml's type contract is upheld there are restrictions on
             * attribute values and tag names.
             *
             * - For attributes which contain script code (on*), a goog.string.Const is
             *   required.
             * - For attributes which contain style (style), a goog.html.SafeStyle or a
             *   goog.html.SafeStyle.PropertyMap is required.
             * - For attributes which are interpreted as URLs (e.g. src, href) a
             *   goog.html.SafeUrl, goog.string.Const or string is required. If a string
             *   is passed, it will be sanitized with SafeUrl.sanitize().
             * - For tags which can load code or set security relevant page metadata,
             *   more specific goog.html.SafeHtml.create*() functions must be used. Tags
             *   which are not supported by this function are applet, base, embed, iframe,
             *   link, math, object, script, style, svg, and template.
             *
             * @param {!goog.dom.TagName|string} tagName The name of the tag. Only tag names
             *     consisting of [a-zA-Z0-9-] are allowed. Tag names documented above are
             *     disallowed.
             * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes
             *     Mapping from attribute names to their values. Only attribute names
             *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined causes
             *     the attribute to be omitted.
             * @param {!goog.html.SafeHtml.TextOrHtml_|
             *     !Array<!goog.html.SafeHtml.TextOrHtml_>=} opt_content Content to
             *     HTML-escape and put inside the tag. This must be empty for void tags
             *     like <br>. Array elements are concatenated.
             * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.
             * @throws {Error} If invalid tag name, attribute name, or attribute value is
             *     provided.
             * @throws {goog.asserts.AssertionError} If content for void tag is provided.
             */
            SafeHtml.create = function (tagName, opt_attributes, opt_content) {
                goog.html.SafeHtml.verifyTagName(String(tagName));
                return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(tagName), opt_attributes, opt_content);
            };
            ;
            /**
             * Verifies if the tag name is valid and if it doesn't change the context.
             * E.g. STRONG is fine but SCRIPT throws because it changes context. See
             * goog.html.SafeHtml.create for an explanation of allowed tags.
             * @param {string} tagName
             * @throws {Error} If invalid tag name is provided.
             * @package
             */
            SafeHtml.verifyTagName = function (tagName) {
                if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(tagName)) {
                    throw new Error('Invalid tag name <' + tagName + '>.');
                }
                if (tagName.toUpperCase() in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_) {
                    throw new Error('Tag name <' + tagName + '> is not allowed for SafeHtml.');
                }
            };
            ;
            /**
             * Creates a SafeHtml representing an iframe tag.
             *
             * This by default restricts the iframe as much as possible by setting the
             * sandbox attribute to the empty string. If the iframe requires less
             * restrictions, set the sandbox attribute as tight as possible, but do not rely
             * on the sandbox as a security feature because it is not supported by older
             * browsers. If a sandbox is essential to security (e.g. for third-party
             * frames), use createSandboxIframe which checks for browser support.
             *
             * @see https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe#attr-sandbox
             *
             * @param {?goog.html.TrustedResourceUrl=} opt_src The value of the src
             *     attribute. If null or undefined src will not be set.
             * @param {?goog.html.SafeHtml=} opt_srcdoc The value of the srcdoc attribute.
             *     If null or undefined srcdoc will not be set.
             * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes
             *     Mapping from attribute names to their values. Only attribute names
             *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined causes
             *     the attribute to be omitted.
             * @param {!goog.html.SafeHtml.TextOrHtml_|
             *     !Array<!goog.html.SafeHtml.TextOrHtml_>=} opt_content Content to
             *     HTML-escape and put inside the tag. Array elements are concatenated.
             * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.
             * @throws {Error} If invalid tag name, attribute name, or attribute value is
             *     provided. If opt_attributes contains the src or srcdoc attributes.
             */
            SafeHtml.createIframe = function (opt_src, opt_srcdoc, opt_attributes, opt_content) {
                if (opt_src) {
                    // Check whether this is really TrustedResourceUrl.
                    goog.html.TrustedResourceUrl.unwrap(opt_src);
                }
                var fixedAttributes = {};
                fixedAttributes['src'] = opt_src || null;
                fixedAttributes['srcdoc'] =
                    opt_srcdoc && goog.html.SafeHtml.unwrap(opt_srcdoc);
                var defaultAttributes = { 'sandbox': '' };
                var attributes = goog.html.SafeHtml.combineAttributes(fixedAttributes, defaultAttributes, opt_attributes);
                return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse('iframe', attributes, opt_content);
            };
            ;
            /**
             * Creates a SafeHtml representing a sandboxed iframe tag.
             *
             * The sandbox attribute is enforced in its most restrictive mode, an empty
             * string. Consequently, the security requirements for the src and srcdoc
             * attributes are relaxed compared to SafeHtml.createIframe. This function
             * will throw on browsers that do not support the sandbox attribute, as
             * determined by SafeHtml.canUseSandboxIframe.
             *
             * The SafeHtml returned by this function can trigger downloads with no
             * user interaction on Chrome (though only a few, further attempts are blocked).
             * Firefox and IE will block all downloads from the sandbox.
             *
             * @see https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe#attr-sandbox
             * @see https://lists.w3.org/Archives/Public/public-whatwg-archive/2013Feb/0112.html
             *
             * @param {string|!goog.html.SafeUrl=} opt_src The value of the src
             *     attribute. If null or undefined src will not be set.
             * @param {string=} opt_srcdoc The value of the srcdoc attribute.
             *     If null or undefined srcdoc will not be set. Will not be sanitized.
             * @param {!Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes
             *     Mapping from attribute names to their values. Only attribute names
             *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined causes
             *     the attribute to be omitted.
             * @param {!goog.html.SafeHtml.TextOrHtml_|
             *     !Array<!goog.html.SafeHtml.TextOrHtml_>=} opt_content Content to
             *     HTML-escape and put inside the tag. Array elements are concatenated.
             * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.
             * @throws {Error} If invalid tag name, attribute name, or attribute value is
             *     provided. If opt_attributes contains the src, srcdoc or sandbox
             *     attributes. If browser does not support the sandbox attribute on iframe.
             */
            SafeHtml.createSandboxIframe = function (opt_src, opt_srcdoc, opt_attributes, opt_content) {
                if (!goog.html.SafeHtml.canUseSandboxIframe()) {
                    throw new Error('The browser does not support sandboxed iframes.');
                }
                var fixedAttributes = {};
                if (opt_src) {
                    // Note that sanitize is a no-op on SafeUrl.
                    fixedAttributes['src'] =
                        goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(opt_src));
                }
                else {
                    fixedAttributes['src'] = null;
                }
                fixedAttributes['srcdoc'] = opt_srcdoc || null;
                fixedAttributes['sandbox'] = '';
                var attributes = goog.html.SafeHtml.combineAttributes(fixedAttributes, {}, opt_attributes);
                return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse('iframe', attributes, opt_content);
            };
            ;
            /**
             * Checks if the user agent supports sandboxed iframes.
             * @return {boolean}
             */
            SafeHtml.canUseSandboxIframe = function () {
                return goog.global['HTMLIFrameElement'] &&
                    ('sandbox' in goog.global['HTMLIFrameElement'].prototype);
            };
            ;
            /**
             * Creates a SafeHtml representing a script tag with the src attribute.
             * @param {!goog.html.TrustedResourceUrl} src The value of the src
             * attribute.
             * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=}
             * opt_attributes
             *     Mapping from attribute names to their values. Only attribute names
             *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined
             *     causes the attribute to be omitted.
             * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.
             * @throws {Error} If invalid attribute name or value is provided. If
             *     opt_attributes contains the src attribute.
             */
            SafeHtml.createScriptSrc = function (src, opt_attributes) {
                // TODO(mlourenco): The charset attribute should probably be blocked. If
                // its value is attacker controlled, the script contains attacker controlled
                // sub-strings (even if properly escaped) and the server does not set charset
                // then XSS is likely possible.
                // https://html.spec.whatwg.org/multipage/scripting.html#dom-script-charset
                // Check whether this is really TrustedResourceUrl.
                goog.html.TrustedResourceUrl.unwrap(src);
                var fixedAttributes = { 'src': src };
                var defaultAttributes = {};
                var attributes = goog.html.SafeHtml.combineAttributes(fixedAttributes, defaultAttributes, opt_attributes);
                return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse('script', attributes);
            };
            ;
            /**
             * Creates a SafeHtml representing a script tag. Does not allow the language,
             * src, text or type attributes to be set.
             * @param {!goog.html.SafeScript|!Array<!goog.html.SafeScript>}
             *     script Content to put inside the tag. Array elements are
             *     concatenated.
             * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes
             *     Mapping from attribute names to their values. Only attribute names
             *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined causes
             *     the attribute to be omitted.
             * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.
             * @throws {Error} If invalid attribute name or attribute value is provided. If
             *     opt_attributes contains the language, src, text or type attribute.
             */
            SafeHtml.createScript = function (script, opt_attributes) {
                for (var attr in opt_attributes) {
                    var attrLower = attr.toLowerCase();
                    if (attrLower == 'language' || attrLower == 'src' || attrLower == 'text' ||
                        attrLower == 'type') {
                        throw new Error('Cannot set "' + attrLower + '" attribute');
                    }
                }
                var content = '';
                script = goog.array.concat(script);
                for (var i = 0; i < script.length; i++) {
                    content += goog.html.SafeScript.unwrap(script[i]);
                }
                // Convert to SafeHtml so that it's not HTML-escaped. This is safe because
                // as part of its contract, SafeScript should have no dangerous '<'.
                var htmlContent = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(content, goog.i18n.bidi.Dir.NEUTRAL);
                return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse('script', opt_attributes, htmlContent);
            };
            ;
            /**
             * Creates a SafeHtml representing a style tag. The type attribute is set
             * to "text/css".
             * @param {!goog.html.SafeStyleSheet|!Array<!goog.html.SafeStyleSheet>}
             *     styleSheet Content to put inside the tag. Array elements are
             *     concatenated.
             * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes
             *     Mapping from attribute names to their values. Only attribute names
             *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined causes
             *     the attribute to be omitted.
             * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.
             * @throws {Error} If invalid attribute name or attribute value is provided. If
             *     opt_attributes contains the type attribute.
             */
            SafeHtml.createStyle = function (styleSheet, opt_attributes) {
                var fixedAttributes = { 'type': 'text/css' };
                var defaultAttributes = {};
                var attributes = goog.html.SafeHtml.combineAttributes(fixedAttributes, defaultAttributes, opt_attributes);
                var content = '';
                styleSheet = goog.array.concat(styleSheet);
                for (var i = 0; i < styleSheet.length; i++) {
                    content += goog.html.SafeStyleSheet.unwrap(styleSheet[i]);
                }
                // Convert to SafeHtml so that it's not HTML-escaped. This is safe because
                // as part of its contract, SafeStyleSheet should have no dangerous '<'.
                var htmlContent = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(content, goog.i18n.bidi.Dir.NEUTRAL);
                return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse('style', attributes, htmlContent);
            };
            ;
            /**
             * Creates a SafeHtml representing a meta refresh tag.
             * @param {!goog.html.SafeUrl|string} url Where to redirect. If a string is
             *     passed, it will be sanitized with SafeUrl.sanitize().
             * @param {number=} opt_secs Number of seconds until the page should be
             *     reloaded. Will be set to 0 if unspecified.
             * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.
             */
            SafeHtml.createMetaRefresh = function (url, opt_secs) {
                // Note that sanitize is a no-op on SafeUrl.
                var unwrappedUrl = goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(url));
                if (goog.labs.userAgent.browser.isIE() ||
                    goog.labs.userAgent.browser.isEdge()) {
                    // IE/EDGE can't parse the content attribute if the url contains a
                    // semicolon. We can fix this by adding quotes around the url, but then we
                    // can't parse quotes in the URL correctly. Also, it seems that IE/EDGE
                    // did not unescape semicolons in these URLs at some point in the past. We
                    // take a best-effort approach.
                    //
                    // If the URL has semicolons (which may happen in some cases, see
                    // http://www.w3.org/TR/1999/REC-html401-19991224/appendix/notes.html#h-B.2
                    // for instance), wrap it in single quotes to protect the semicolons.
                    // If the URL has semicolons and single quotes, url-encode the single quotes
                    // as well.
                    //
                    // This is imperfect. Notice that both ' and ; are reserved characters in
                    // URIs, so this could do the wrong thing, but at least it will do the wrong
                    // thing in only rare cases.
                    if (goog.string.contains(unwrappedUrl, ';')) {
                        unwrappedUrl = "'" + unwrappedUrl.replace(/'/g, '%27') + "'";
                    }
                }
                var attributes = {
                    'http-equiv': 'refresh',
                    'content': (opt_secs || 0) + '; url=' + unwrappedUrl
                };
                // This function will handle the HTML escaping for attributes.
                return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse('meta', attributes);
            };
            ;
            /**
             * @param {string} tagName The tag name.
             * @param {string} name The attribute name.
             * @param {!goog.html.SafeHtml.AttributeValue} value The attribute value.
             * @return {string} A "name=value" string.
             * @throws {Error} If attribute value is unsafe for the given tag and attribute.
             * @private
             */
            SafeHtml.getAttrNameAndValue_ = function (tagName, name, value) {
                // If it's goog.string.Const, allow any valid attribute name.
                if (value instanceof goog.string.Const) {
                    value = goog.string.Const.unwrap(value);
                }
                else if (name.toLowerCase() == 'style') {
                    value = goog.html.SafeHtml.getStyleValue_(value);
                }
                else if (/^on/i.test(name)) {
                    // TODO(jakubvrana): Disallow more attributes with a special meaning.
                    throw new Error('Attribute "' + name + '" requires goog.string.Const value, "' + value +
                        '" given.');
                    // URL attributes handled differently according to tag.
                }
                else if (name.toLowerCase() in goog.html.SafeHtml.URL_ATTRIBUTES_) {
                    if (value instanceof goog.html.TrustedResourceUrl) {
                        value = goog.html.TrustedResourceUrl.unwrap(value);
                    }
                    else if (value instanceof goog.html.SafeUrl) {
                        value = goog.html.SafeUrl.unwrap(value);
                    }
                    else if (goog.isString(value)) {
                        value = goog.html.SafeUrl.sanitize(value).getTypedStringValue();
                    }
                    else {
                        throw new Error('Attribute "' + name + '" on tag "' + tagName +
                            '" requires goog.html.SafeUrl, goog.string.Const, or string,' +
                            ' value "' + value + '" given.');
                    }
                }
                // Accept SafeUrl, TrustedResourceUrl, etc. for attributes which only require
                // HTML-escaping.
                if (value.implementsGoogStringTypedString) {
                    // Ok to call getTypedStringValue() since there's no reliance on the type
                    // contract for security here.
                    value = value.getTypedStringValue();
                }
                goog.asserts.assert(goog.isString(value) || goog.isNumber(value), 'String or number value expected, got ' + (typeof value) +
                    ' with value: ' + value);
                return name + '="' + goog.string.htmlEscape(String(value)) + '"';
            };
            ;
            /**
             * Gets value allowed in "style" attribute.
             * @param {!goog.html.SafeHtml.AttributeValue} value It could be SafeStyle or a
             *     map which will be passed to goog.html.SafeStyle.create.
             * @return {string} Unwrapped value.
             * @throws {Error} If string value is given.
             * @private
             */
            SafeHtml.getStyleValue_ = function (value) {
                if (!goog.isObject(value)) {
                    throw new Error('The "style" attribute requires goog.html.SafeStyle or map ' +
                        'of style properties, ' + (typeof value) + ' given: ' + value);
                }
                if (!(value instanceof goog.html.SafeStyle)) {
                    // Process the property bag into a style object.
                    value = goog.html.SafeStyle.create(value);
                }
                return goog.html.SafeStyle.unwrap(value);
            };
            ;
            /**
             * Creates a SafeHtml content with known directionality consisting of a tag with
             * optional attributes and optional content.
             * @param {!goog.i18n.bidi.Dir} dir Directionality.
             * @param {string} tagName
             * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes
             * @param {!goog.html.SafeHtml.TextOrHtml_|
             *     !Array<!goog.html.SafeHtml.TextOrHtml_>=} opt_content
             * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.
             */
            SafeHtml.createWithDir = function (dir, tagName, opt_attributes, opt_content) {
                var html = goog.html.SafeHtml.create(tagName, opt_attributes, opt_content);
                html.dir_ = dir;
                return html;
            };
            ;
            /**
             * Creates a new SafeHtml object by concatenating values.
             * @param {...(!goog.html.SafeHtml.TextOrHtml_|
             *     !Array<!goog.html.SafeHtml.TextOrHtml_>)} var_args Values to concatenate.
             * @return {!goog.html.SafeHtml}
             */
            SafeHtml.concat = function () {
                var var_args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    var_args[_i] = arguments[_i];
                }
                var dir = goog.i18n.bidi.Dir.NEUTRAL;
                var content = '';
                /**
                 * @param {!goog.html.SafeHtml.TextOrHtml_|
                 *     !Array<!goog.html.SafeHtml.TextOrHtml_>} argument
                 */
                var addArgument = function (argument) {
                    if (goog.isArray(argument)) {
                        goog.array.forEach(argument, addArgument);
                    }
                    else {
                        var html = goog.html.SafeHtml.htmlEscape(argument);
                        content += goog.html.SafeHtml.unwrap(html);
                        var htmlDir = html.getDirection();
                        if (dir == goog.i18n.bidi.Dir.NEUTRAL) {
                            dir = htmlDir;
                        }
                        else if (htmlDir != goog.i18n.bidi.Dir.NEUTRAL && dir != htmlDir) {
                            dir = null;
                        }
                    }
                };
                goog.array.forEach(arguments, addArgument);
                return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(content, dir);
            };
            ;
            /**
             * Creates a new SafeHtml object with known directionality by concatenating the
             * values.
             * @param {!goog.i18n.bidi.Dir} dir Directionality.
             * @param {...(!goog.html.SafeHtml.TextOrHtml_|
             *     !Array<!goog.html.SafeHtml.TextOrHtml_>)} var_args Elements of array
             *     arguments would be processed recursively.
             * @return {!goog.html.SafeHtml}
             */
            SafeHtml.concatWithDir = function (dir, var_args) {
                var html = goog.html.SafeHtml.concat(goog.array.slice(arguments, 1));
                html.dir_ = dir;
                return html;
            };
            ;
            /**
             * Package-internal utility method to create SafeHtml instances.
             *
             * @param {string} html The string to initialize the SafeHtml object with.
             * @param {?goog.i18n.bidi.Dir} dir The directionality of the SafeHtml to be
             *     constructed, or null if unknown.
             * @return {!goog.html.SafeHtml} The initialized SafeHtml object.
             * @package
             */
            SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse = function (html, dir) {
                return new goog.html.SafeHtml().initSecurityPrivateDoNotAccessOrElse_(html, dir);
            };
            ;
            /**
             * Called from createSafeHtmlSecurityPrivateDoNotAccessOrElse(). This
             * method exists only so that the compiler can dead code eliminate static
             * fields (like EMPTY) when they're not accessed.
             * @param {string} html
             * @param {?goog.i18n.bidi.Dir} dir
             * @return {!goog.html.SafeHtml}
             * @private
             */
            SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_ = function (html, dir) {
                this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = html;
                this.dir_ = dir;
                return this;
            };
            ;
            /**
             * Like create() but does not restrict which tags can be constructed.
             *
             * @param {string} tagName Tag name. Set or validated by caller.
             * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes
             * @param {(!goog.html.SafeHtml.TextOrHtml_|
             *     !Array<!goog.html.SafeHtml.TextOrHtml_>)=} opt_content
             * @return {!goog.html.SafeHtml}
             * @throws {Error} If invalid or unsafe attribute name or value is provided.
             * @throws {goog.asserts.AssertionError} If content for void tag is provided.
             * @package
             */
            SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse = function (tagName, opt_attributes, opt_content) {
                var dir = null;
                var result = '<' + tagName;
                result += goog.html.SafeHtml.stringifyAttributes(tagName, opt_attributes);
                var content = opt_content;
                if (!goog.isDefAndNotNull(content)) {
                    content = [];
                }
                else if (!goog.isArray(content)) {
                    content = [content];
                }
                if (goog.dom.tags.isVoidTag(tagName.toLowerCase())) {
                    goog.asserts.assert(!content.length, 'Void tag <' + tagName + '> does not allow content.');
                    result += '>';
                }
                else {
                    var html = goog.html.SafeHtml.concat(content);
                    result += '>' + goog.html.SafeHtml.unwrap(html) + '</' + tagName + '>';
                    dir = html.getDirection();
                }
                var dirAttribute = opt_attributes && opt_attributes['dir'];
                if (dirAttribute) {
                    if (/^(ltr|rtl|auto)$/i.test(dirAttribute)) {
                        // If the tag has the "dir" attribute specified then its direction is
                        // neutral because it can be safely used in any context.
                        dir = goog.i18n.bidi.Dir.NEUTRAL;
                    }
                    else {
                        dir = null;
                    }
                }
                return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(result, dir);
            };
            ;
            /**
             * Creates a string with attributes to insert after tagName.
             * @param {string} tagName
             * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes
             * @return {string} Returns an empty string if there are no attributes, returns
             *     a string starting with a space otherwise.
             * @throws {Error} If attribute value is unsafe for the given tag and attribute.
             * @package
             */
            SafeHtml.stringifyAttributes = function (tagName, opt_attributes) {
                var result = '';
                if (opt_attributes) {
                    for (var name in opt_attributes) {
                        if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(name)) {
                            throw new Error('Invalid attribute name "' + name + '".');
                        }
                        var value = opt_attributes[name];
                        if (!goog.isDefAndNotNull(value)) {
                            continue;
                        }
                        result +=
                            ' ' + goog.html.SafeHtml.getAttrNameAndValue_(tagName, name, value);
                    }
                }
                return result;
            };
            ;
            /**
             * @param {!Object<string, ?goog.html.SafeHtml.AttributeValue>} fixedAttributes
             * @param {!Object<string, string>} defaultAttributes
             * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes
             *     Optional attributes passed to create*().
             * @return {!Object<string, ?goog.html.SafeHtml.AttributeValue>}
             * @throws {Error} If opt_attributes contains an attribute with the same name
             *     as an attribute in fixedAttributes.
             * @package
             */
            SafeHtml.combineAttributes = function (fixedAttributes, defaultAttributes, opt_attributes) {
                var combinedAttributes = {};
                var name;
                for (name in fixedAttributes) {
                    goog.asserts.assert(name.toLowerCase() == name, 'Must be lower case');
                    combinedAttributes[name] = fixedAttributes[name];
                }
                for (name in defaultAttributes) {
                    goog.asserts.assert(name.toLowerCase() == name, 'Must be lower case');
                    combinedAttributes[name] = defaultAttributes[name];
                }
                for (name in opt_attributes) {
                    var nameLower = name.toLowerCase();
                    if (nameLower in fixedAttributes) {
                        throw new Error('Cannot override "' + nameLower + '" attribute, got "' + name +
                            '" with value "' + opt_attributes[name] + '"');
                    }
                    if (nameLower in defaultAttributes) {
                        delete combinedAttributes[nameLower];
                    }
                    combinedAttributes[name] = opt_attributes[name];
                }
                return combinedAttributes;
            };
            ;
            /**
             * Coerces an arbitrary object into a SafeHtml object.
             *
             * If {@code textOrHtml} is already of type {@code goog.html.SafeHtml}, the same
             * object is returned. Otherwise, {@code textOrHtml} is coerced to string, and
             * HTML-escaped. If {@code textOrHtml} is of a type that implements
             * {@code goog.i18n.bidi.DirectionalString}, its directionality, if known, is
             * preserved.
             *
             * @param {!goog.html.SafeHtml.TextOrHtml_} textOrHtml The text or SafeHtml to
             *     coerce.
             * @return {!goog.html.SafeHtml} The resulting SafeHtml object.
             * @deprecated Use goog.html.SafeHtml.htmlEscape.
             */
            SafeHtml.from = goog.html.SafeHtml.htmlEscape;
            /**
             * @const
             * @private
             */
            SafeHtml.VALID_NAMES_IN_TAG_ = /^[a-zA-Z0-9-]+$/;
            /**
             * Set of attributes containing URL as defined at
             * http://www.w3.org/TR/html5/index.html#attributes-1.
             * @private @const {!Object<string,boolean>}
             */
            SafeHtml.URL_ATTRIBUTES_ = goog.object.createSet('action', 'cite', 'data', 'formaction', 'href', 'manifest', 'poster', 'src');
            /**
             * Tags which are unsupported via create(). They might be supported via a
             * tag-specific create method. These are tags which might require a
             * TrustedResourceUrl in one of their attributes or a restricted type for
             * their content.
             * @private @const {!Object<string,boolean>}
             */
            SafeHtml.NOT_ALLOWED_TAG_NAMES_ = goog.object.createSet(goog.dom.TagName.APPLET, goog.dom.TagName.BASE, goog.dom.TagName.EMBED, goog.dom.TagName.IFRAME, goog.dom.TagName.LINK, goog.dom.TagName.MATH, goog.dom.TagName.META, goog.dom.TagName.OBJECT, goog.dom.TagName.SCRIPT, goog.dom.TagName.STYLE, goog.dom.TagName.SVG, goog.dom.TagName.TEMPLATE);
            /**
             * Type marker for the SafeHtml type, used to implement additional run-time
             * type checking.
             * @const {!Object}
             * @private
             */
            SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
            /**
             * A SafeHtml instance corresponding to the HTML doctype: "<!DOCTYPE html>".
             * @const {!goog.html.SafeHtml}
             */
            SafeHtml.DOCTYPE_HTML = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse('<!DOCTYPE html>', goog.i18n.bidi.Dir.NEUTRAL);
            /**
             * A SafeHtml instance corresponding to the empty string.
             * @const {!goog.html.SafeHtml}
             */
            SafeHtml.EMPTY = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse('', goog.i18n.bidi.Dir.NEUTRAL);
            /**
             * A SafeHtml instance corresponding to the <br> tag.
             * @const {!goog.html.SafeHtml}
             */
            SafeHtml.BR = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse('<br>', goog.i18n.bidi.Dir.NEUTRAL);
            return SafeHtml;
        }());
        html_1.SafeHtml = SafeHtml;
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Unchecked conversions to create values of goog.html types from
 * plain strings.  Use of these functions could potentially result in instances
 * of goog.html types that violate their type contracts, and hence result in
 * security vulnerabilties.
 *
 * Therefore, all uses of the methods herein must be carefully security
 * reviewed.  Avoid use of the methods in this file whenever possible; instead
 * prefer to create instances of goog.html types using inherently safe builders
 * or template systems.
 *
 *
 *
 * @visibility {//closure/goog/html:approved_for_unchecked_conversion}
 * @visibility {//closure/goog/bin/sizetests:__pkg__}
 */
goog.provide('goog.html.uncheckedconversions');
goog.require('goog.asserts');
goog.require('goog.html.SafeHtml');
goog.require('goog.html.SafeScript');
goog.require('goog.html.SafeStyle');
goog.require('goog.html.SafeStyleSheet');
goog.require('goog.html.SafeUrl');
goog.require('goog.html.TrustedResourceUrl');
goog.require('goog.string');
goog.require('goog.string.Const');
var goog;
(function (goog) {
    var html;
    (function (html_2) {
        var uncheckedconversions;
        (function (uncheckedconversions) {
            /**
             * Performs an "unchecked conversion" to SafeHtml from a plain string that is
             * known to satisfy the SafeHtml type contract.
             *
             * IMPORTANT: Uses of this method must be carefully security-reviewed to
             * ensure that the value of {@code html} satisfies the SafeHtml type contract
             * in all possible program states.
             *
             *
             * @param {!goog.string.Const} justification A constant string explaining why
             *     this use of this method is safe. May include a security review ticket
             *     number.
             * @param {string} html A string that is claimed to adhere to the SafeHtml
             *     contract.
             * @param {?goog.i18n.bidi.Dir=} opt_dir The optional directionality of the
             *     SafeHtml to be constructed. A null or undefined value signifies an
             *     unknown directionality.
             * @return {!goog.html.SafeHtml} The value of html, wrapped in a SafeHtml
             *     object.
             */
            function safeHtmlFromStringKnownToSatisfyTypeContract(justification, html, opt_dir) {
                // unwrap() called inside an assert so that justification can be optimized
                // away in production code.
                goog.asserts.assertString(goog.string.Const.unwrap(justification), 'must provide justification');
                goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), 'must provide non-empty justification');
                return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(html, opt_dir || null);
            }
            uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract = safeHtmlFromStringKnownToSatisfyTypeContract;
            ;
            /**
             * Performs an "unchecked conversion" to SafeScript from a plain string that
             * is known to satisfy the SafeScript type contract.
             *
             * IMPORTANT: Uses of this method must be carefully security-reviewed to
             * ensure that the value of {@code script} satisfies the SafeScript type
             * contract in all possible program states.
             *
             *
             * @param {!goog.string.Const} justification A constant string explaining why
             *     this use of this method is safe. May include a security review ticket
             *     number.
             * @param {string} script The string to wrap as a SafeScript.
             * @return {!goog.html.SafeScript} The value of {@code script}, wrapped in a
             *     SafeScript object.
             */
            function safeScriptFromStringKnownToSatisfyTypeContract(justification, script) {
                // unwrap() called inside an assert so that justification can be optimized
                // away in production code.
                goog.asserts.assertString(goog.string.Const.unwrap(justification), 'must provide justification');
                goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), 'must provide non-empty justification');
                return goog.html.SafeScript
                    .createSafeScriptSecurityPrivateDoNotAccessOrElse(script);
            }
            uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract = safeScriptFromStringKnownToSatisfyTypeContract;
            ;
            /**
             * Performs an "unchecked conversion" to SafeStyle from a plain string that is
             * known to satisfy the SafeStyle type contract.
             *
             * IMPORTANT: Uses of this method must be carefully security-reviewed to
             * ensure that the value of {@code style} satisfies the SafeStyle type
             * contract in all possible program states.
             *
             *
             * @param {!goog.string.Const} justification A constant string explaining why
             *     this use of this method is safe. May include a security review ticket
             *     number.
             * @param {string} style The string to wrap as a SafeStyle.
             * @return {!goog.html.SafeStyle} The value of {@code style}, wrapped in a
             *     SafeStyle object.
             */
            function safeStyleFromStringKnownToSatisfyTypeContract(justification, style) {
                // unwrap() called inside an assert so that justification can be optimized
                // away in production code.
                goog.asserts.assertString(goog.string.Const.unwrap(justification), 'must provide justification');
                goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), 'must provide non-empty justification');
                return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style);
            }
            uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract = safeStyleFromStringKnownToSatisfyTypeContract;
            ;
            /**
             * Performs an "unchecked conversion" to SafeStyleSheet from a plain string
             * that is known to satisfy the SafeStyleSheet type contract.
             *
             * IMPORTANT: Uses of this method must be carefully security-reviewed to
             * ensure that the value of {@code styleSheet} satisfies the SafeStyleSheet
             * type contract in all possible program states.
             *
             *
             * @param {!goog.string.Const} justification A constant string explaining why
             *     this use of this method is safe. May include a security review ticket
             *     number.
             * @param {string} styleSheet The string to wrap as a SafeStyleSheet.
             * @return {!goog.html.SafeStyleSheet} The value of {@code styleSheet}, wrapped
             *     in a SafeStyleSheet object.
             */
            function safeStyleSheetFromStringKnownToSatisfyTypeContract(justification, styleSheet) {
                // unwrap() called inside an assert so that justification can be optimized
                // away in production code.
                goog.asserts.assertString(goog.string.Const.unwrap(justification), 'must provide justification');
                goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), 'must provide non-empty justification');
                return goog.html.SafeStyleSheet
                    .createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheet);
            }
            uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract = safeStyleSheetFromStringKnownToSatisfyTypeContract;
            ;
            /**
             * Performs an "unchecked conversion" to SafeUrl from a plain string that is
             * known to satisfy the SafeUrl type contract.
             *
             * IMPORTANT: Uses of this method must be carefully security-reviewed to
             * ensure that the value of {@code url} satisfies the SafeUrl type contract in
             * all possible program states.
             *
             *
             * @param {!goog.string.Const} justification A constant string explaining why
             *     this use of this method is safe. May include a security review ticket
             *     number.
             * @param {string} url The string to wrap as a SafeUrl.
             * @return {!goog.html.SafeUrl} The value of {@code url}, wrapped in a SafeUrl
             *     object.
             */
            function safeUrlFromStringKnownToSatisfyTypeContract(justification, url) {
                // unwrap() called inside an assert so that justification can be optimized
                // away in production code.
                goog.asserts.assertString(goog.string.Const.unwrap(justification), 'must provide justification');
                goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), 'must provide non-empty justification');
                return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
            }
            uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract = safeUrlFromStringKnownToSatisfyTypeContract;
            ;
            /**
             * Performs an "unchecked conversion" to TrustedResourceUrl from a plain
             * string that is known to satisfy the TrustedResourceUrl type contract.
             *
             * IMPORTANT: Uses of this method must be carefully security-reviewed to
             * ensure that the value of {@code url} satisfies the TrustedResourceUrl type
             * contract in all possible program states.
             *
             *
             * @param {!goog.string.Const} justification A constant string explaining why
             *     this use of this method is safe. May include a security review ticket
             *     number.
             * @param {string} url The string to wrap as a TrustedResourceUrl.
             * @return {!goog.html.TrustedResourceUrl} The value of {@code url}, wrapped in
             *     a TrustedResourceUrl object.
             */
            function trustedResourceUrlFromStringKnownToSatisfyTypeContract(justification, url) {
                // unwrap() called inside an assert so that justification can be optimized
                // away in production code.
                goog.asserts.assertString(goog.string.Const.unwrap(justification), 'must provide justification');
                goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), 'must provide non-empty justification');
                return goog.html.TrustedResourceUrl
                    .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(url);
            }
            uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract = trustedResourceUrlFromStringKnownToSatisfyTypeContract;
            ;
        })(uncheckedconversions = html_2.uncheckedconversions || (html_2.uncheckedconversions = {}));
    })(html = goog.html || (goog.html = {}));
})(goog || (goog = {}));
// Copyright 2017 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
goog.provide('goog.dom.asserts');
goog.require('goog.asserts');
var goog;
(function (goog) {
    var dom;
    (function (dom) {
        var asserts;
        (function (asserts) {
            /**
             * @fileoverview Custom assertions to ensure that an element has the appropriate
             * type.
             *
             * Using a goog.dom.safe wrapper on an object on the incorrect type (via an
             * incorrect static type cast) can result in security bugs: For instance,
             * g.d.s.setAnchorHref ensures that the URL assigned to the .href attribute
             * satisfies the SafeUrl contract, i.e., is safe to dereference as a hyperlink.
             * However, the value assigned to a HTMLLinkElement's .href property requires
             * the stronger TrustedResourceUrl contract, since it can refer to a stylesheet.
             * Thus, using g.d.s.setAnchorHref on an (incorrectly statically typed) object
             * of type HTMLLinkElement can result in a security vulnerability.
             * Assertions of the correct run-time type help prevent such incorrect use.
             *
             * In some cases, code using the DOM API is tested using mock objects (e.g., a
             * plain object such as {'href': url} instead of an actual Location object).
             * To allow such mocking, the assertions permit objects of types that are not
             * relevant DOM API objects at all (for instance, not Element or Location).
             *
             * Note that instanceof checks don't work straightforwardly in older versions of
             * IE, or across frames (see,
             * http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object,
             * http://stackoverflow.com/questions/26248599/instanceof-htmlelement-in-iframe-is-not-element-or-object).
             *
             * Hence, these assertions may pass vacuously in such scenarios. The resulting
             * risk of security bugs is limited by the following factors:
             *  - A bug can only arise in scenarios involving incorrect static typing (the
             *    wrapper methods are statically typed to demand objects of the appropriate,
             *    precise type).
             *  - Typically, code is tested and exercised in multiple browsers.
             */
            /**
             * Asserts that a given object is a Location.
             *
             * To permit this assertion to pass in the context of tests where DOM APIs might
             * be mocked, also accepts any other type except for subtypes of {!Element}.
             * This is to ensure that, for instance, HTMLLinkElement is not being used in
             * place of a Location, since this could result in security bugs due to stronger
             * contracts required for assignments to the href property of the latter.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!Location}
             */
            function assertIsLocation(o) {
                if (goog.asserts.ENABLE_ASSERTS) {
                    var win = goog.dom.asserts.getWindow_(o);
                    if (typeof win.Location != 'undefined' &&
                        typeof win.Element != 'undefined') {
                        goog.asserts.assert(o && (o instanceof win.Location || !(o instanceof win.Element)), 'Argument is not a Location (or a non-Element mock); got: %s', goog.dom.asserts.debugStringForType_(o));
                    }
                }
                return /** @type {!Location} */ (o);
            }
            asserts.assertIsLocation = assertIsLocation;
            ;
            /**
             * Asserts that a given object is either the given subtype of Element
             * or a non-Element, non-Location Mock.
             *
             * To permit this assertion to pass in the context of tests where DOM
             * APIs might be mocked, also accepts any other type except for
             * subtypes of {!Element}.  This is to ensure that, for instance,
             * HTMLScriptElement is not being used in place of a HTMLImageElement,
             * since this could result in security bugs due to stronger contracts
             * required for assignments to the src property of the latter.
             *
             * The DOM type is looked up in the window the object belongs to.  In
             * some contexts, this might not be possible (e.g. when running tests
             * outside a browser, cross-domain lookup). In this case, the
             * assertions are skipped.
             *
             * @param {?Object} o The object whose type to assert.
             * @param {string} typename The name of the DOM type.
             * @return {!Element} The object.
             * @private
             */
            // TODO(bangert): Make an analog of goog.dom.TagName to correctly handle casts?
            function assertIsElementType_(o, typename) {
                if (goog.asserts.ENABLE_ASSERTS) {
                    var win = goog.dom.asserts.getWindow_(o);
                    if (typeof win[typename] != 'undefined' &&
                        typeof win.Location != 'undefined' &&
                        typeof win.Element != 'undefined') {
                        goog.asserts.assert(o &&
                            (o instanceof win[typename] ||
                                !((o instanceof win.Location) || (o instanceof win.Element))), 'Argument is not a %s (or a non-Element, non-Location mock); got: %s', typename, goog.dom.asserts.debugStringForType_(o));
                    }
                }
                return /** @type {!Element} */ (o);
            }
            asserts.assertIsElementType_ = assertIsElementType_;
            ;
            /**
             * Asserts that a given object is a HTMLAnchorElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not of type Location nor a subtype
             * of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLAnchorElement}
             */
            function assertIsHTMLAnchorElement(o) {
                return /** @type {!HTMLAnchorElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLAnchorElement'));
            }
            asserts.assertIsHTMLAnchorElement = assertIsHTMLAnchorElement;
            ;
            /**
             * Asserts that a given object is a HTMLButtonElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLButtonElement}
             */
            function assertIsHTMLButtonElement(o) {
                return /** @type {!HTMLButtonElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLButtonElement'));
            }
            asserts.assertIsHTMLButtonElement = assertIsHTMLButtonElement;
            ;
            /**
             * Asserts that a given object is a HTMLLinkElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLLinkElement}
             */
            function assertIsHTMLLinkElement(o) {
                return /** @type {!HTMLLinkElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLLinkElement'));
            }
            asserts.assertIsHTMLLinkElement = assertIsHTMLLinkElement;
            ;
            /**
             * Asserts that a given object is a HTMLImageElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLImageElement}
             */
            function assertIsHTMLImageElement(o) {
                return /** @type {!HTMLImageElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLImageElement'));
            }
            asserts.assertIsHTMLImageElement = assertIsHTMLImageElement;
            ;
            /**
             * Asserts that a given object is a HTMLVideoElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLVideoElement}
             */
            function assertIsHTMLVideoElement(o) {
                return /** @type {!HTMLVideoElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLVideoElement'));
            }
            asserts.assertIsHTMLVideoElement = assertIsHTMLVideoElement;
            ;
            /**
             * Asserts that a given object is a HTMLInputElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLInputElement}
             */
            function assertIsHTMLInputElement(o) {
                return /** @type {!HTMLInputElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLInputElement'));
            }
            asserts.assertIsHTMLInputElement = assertIsHTMLInputElement;
            ;
            /**
             * Asserts that a given object is a HTMLEmbedElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLEmbedElement}
             */
            function assertIsHTMLEmbedElement(o) {
                return /** @type {!HTMLEmbedElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLEmbedElement'));
            }
            asserts.assertIsHTMLEmbedElement = assertIsHTMLEmbedElement;
            ;
            /**
             * Asserts that a given object is a HTMLFormElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLFormElement}
             */
            function assertIsHTMLFormElement(o) {
                return /** @type {!HTMLFormElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLFormElement'));
            }
            asserts.assertIsHTMLFormElement = assertIsHTMLFormElement;
            ;
            /**
             * Asserts that a given object is a HTMLFrameElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLFrameElement}
             */
            function assertIsHTMLFrameElement(o) {
                return /** @type {!HTMLFrameElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLFrameElement'));
            }
            asserts.assertIsHTMLFrameElement = assertIsHTMLFrameElement;
            ;
            /**
             * Asserts that a given object is a HTMLIFrameElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLIFrameElement}
             */
            function assertIsHTMLIFrameElement(o) {
                return /** @type {!HTMLIFrameElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLIFrameElement'));
            }
            asserts.assertIsHTMLIFrameElement = assertIsHTMLIFrameElement;
            ;
            /**
             * Asserts that a given object is a HTMLObjectElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLObjectElement}
             */
            function assertIsHTMLObjectElement(o) {
                return /** @type {!HTMLObjectElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLObjectElement'));
            }
            asserts.assertIsHTMLObjectElement = assertIsHTMLObjectElement;
            ;
            /**
             * Asserts that a given object is a HTMLScriptElement.
             *
             * To permit this assertion to pass in the context of tests where elements might
             * be mocked, also accepts objects that are not a subtype of Element.
             *
             * @param {?Object} o The object whose type to assert.
             * @return {!HTMLScriptElement}
             */
            function assertIsHTMLScriptElement(o) {
                return /** @type {!HTMLScriptElement} */ (goog.dom.asserts.assertIsElementType_(o, 'HTMLScriptElement'));
            }
            asserts.assertIsHTMLScriptElement = assertIsHTMLScriptElement;
            ;
            /**
             * Returns a string representation of a value's type.
             *
             * @param {*} value An object, or primitive.
             * @return {string} The best display name for the value.
             * @private
             */
            function debugStringForType_(value) {
                if (goog.isObject(value)) {
                    return value.constructor.displayName || value.constructor.name ||
                        Object.prototype.toString.call(value);
                }
                else {
                    return value === undefined ? 'undefined' :
                        value === null ? 'null' : typeof value;
                }
            }
            asserts.debugStringForType_ = debugStringForType_;
            ;
            /**
             * Gets window of element.
             * @param {?Object} o
             * @return {!Window}
             * @private
             */
            function getWindow_(o) {
                var doc = o && o.ownerDocument;
                var win = doc && /** @type {?Window} */ (doc.defaultView || doc.parentWindow);
                return win || /** @type {!Window} */ (goog.global);
            }
            asserts.getWindow_ = getWindow_;
            ;
        })(asserts = dom.asserts || (dom.asserts = {}));
    })(dom = goog.dom || (goog.dom = {}));
})(goog || (goog = {}));
/// <reference path="../specialtype.ts" />
/// <reference path="../base.ts" />
/// <reference path="../asserts/asserts.ts" />
/// <reference path="../dom/asserts.ts" />
/// <reference path="../html/safehtml.ts" />
/// <reference path="../html/safescript.ts" />
/// <reference path="../html/safestyle.ts" />
/// <reference path="../html/safeurl.ts" />
/// <reference path="../html/trustedresourceurl.ts" />
/// <reference path="../string/string.ts" />
/// <reference path="../string/const.ts" />
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Type-safe wrappers for unsafe DOM APIs.
 *
 * This file provides type-safe wrappers for DOM APIs that can result in
 * cross-site scripting (XSS) vulnerabilities, if the API is supplied with
 * untrusted (attacker-controlled) input.  Instead of plain strings, the type
 * safe wrappers consume values of types from the goog.html package whose
 * contract promises that values are safe to use in the corresponding context.
 *
 * Hence, a program that exclusively uses the wrappers in this file (i.e., whose
 * only reference to security-sensitive raw DOM APIs are in this file) is
 * guaranteed to be free of XSS due to incorrect use of such DOM APIs (modulo
 * correctness of code that produces values of the respective goog.html types,
 * and absent code that violates type safety).
 *
 * For example, assigning to an element's .innerHTML property a string that is
 * derived (even partially) from untrusted input typically results in an XSS
 * vulnerability. The type-safe wrapper goog.dom.safe.setInnerHtml consumes a
 * value of type goog.html.SafeHtml, whose contract states that using its values
 * in a HTML context will not result in XSS. Hence a program that is free of
 * direct assignments to any element's innerHTML property (with the exception of
 * the assignment to .innerHTML in this file) is guaranteed to be free of XSS
 * due to assignment of untrusted strings to the innerHTML property.
 */
goog.provide('goog.dom.safe');
goog.provide('goog.dom.safe.InsertAdjacentHtmlPosition');
goog.require('goog.asserts');
goog.require('goog.dom.asserts');
goog.require('goog.html.SafeHtml');
goog.require('goog.html.SafeScript');
goog.require('goog.html.SafeStyle');
goog.require('goog.html.SafeUrl');
goog.require('goog.html.TrustedResourceUrl');
goog.require('goog.string');
goog.require('goog.string.Const');
var goog;
(function (goog) {
    var dom;
    (function (dom) {
        var safe;
        (function (safe) {
            /** @enum {string} */
            var InsertAdjacentHtmlPosition;
            (function (InsertAdjacentHtmlPosition) {
                InsertAdjacentHtmlPosition["AFTERBEGIN"] = "afterbegin";
                InsertAdjacentHtmlPosition["AFTEREND"] = "afterend";
                InsertAdjacentHtmlPosition["BEFOREBEGIN"] = "beforebegin";
                InsertAdjacentHtmlPosition["BEFOREEND"] = "beforeend";
            })(InsertAdjacentHtmlPosition = safe.InsertAdjacentHtmlPosition || (safe.InsertAdjacentHtmlPosition = {}));
            ;
            /**
             * Inserts known-safe HTML into a Node, at the specified position.
             * @param {!Node} node The node on which to call insertAdjacentHTML.
             * @param {!goog.dom.safe.InsertAdjacentHtmlPosition} position Position where
             *     to insert the HTML.
             * @param {!goog.html.SafeHtml} html The known-safe HTML to insert.
             */
            function insertAdjacentHtml(node, position, html) {
                node.insertAdjacentHTML(position, goog.html.SafeHtml.unwrap(html));
            }
            safe.insertAdjacentHtml = insertAdjacentHtml;
            ;
            /**
             * Tags not allowed in goog.dom.safe.setInnerHtml.
             * @private @const {!Object<string, boolean>}
             */
            safe.SET_INNER_HTML_DISALLOWED_TAGS_ = {
                'MATH': true,
                'SCRIPT': true,
                'STYLE': true,
                'SVG': true,
                'TEMPLATE': true
            };
            /**
             * Assigns known-safe HTML to an element's innerHTML property.
             * @param {!Element} elem The element whose innerHTML is to be assigned to.
             * @param {!goog.html.SafeHtml} html The known-safe HTML to assign.
             * @throws {Error} If called with one of these tags: math, script, style, svg,
             *     template.
             */
            function setInnerHtml(elem, html) {
                if (goog.asserts.ENABLE_ASSERTS) {
                    var tagName = elem.tagName.toUpperCase();
                    if (goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[tagName]) {
                        throw new Error('goog.dom.safe.setInnerHtml cannot be used to set content of ' +
                            elem.tagName + '.');
                    }
                }
                elem.innerHTML = goog.html.SafeHtml.unwrap(html);
            }
            safe.setInnerHtml = setInnerHtml;
            ;
            /**
             * Assigns known-safe HTML to an element's outerHTML property.
             * @param {!Element} elem The element whose outerHTML is to be assigned to.
             * @param {!goog.html.SafeHtml} html The known-safe HTML to assign.
             */
            function setOuterHtml(elem, html) {
                elem.outerHTML = goog.html.SafeHtml.unwrap(html);
            }
            safe.setOuterHtml = setOuterHtml;
            ;
            /**
             * Safely assigns a URL a form element's action property.
             *
             * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
             * anchor's href property.  If url is of type string however, it is first
             * sanitized using goog.html.SafeUrl.sanitize.
             *
             * Example usage:
             *   goog.dom.safe.setFormElementAction(formEl, url);
             * which is a safe alternative to
             *   formEl.action = url;
             * The latter can result in XSS vulnerabilities if url is a
             * user-/attacker-controlled value.
             *
             * @param {!Element} form The form element whose action property
             *     is to be assigned to.
             * @param {string|!goog.html.SafeUrl} url The URL to assign.
             * @see goog.html.SafeUrl#sanitize
             */
            function setFormElementAction(form, url) {
                /** @type {!goog.html.SafeUrl} */
                var safeUrl;
                if (url instanceof goog.html.SafeUrl) {
                    safeUrl = url;
                }
                else {
                    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
                }
                goog.dom.asserts.assertIsHTMLFormElement(form).action =
                    goog.html.SafeUrl.unwrap(safeUrl);
            }
            safe.setFormElementAction = setFormElementAction;
            ;
            /**
             * Safely assigns a URL to a button element's formaction property.
             *
             * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
             * anchor's href property.  If url is of type string however, it is first
             * sanitized using goog.html.SafeUrl.sanitize.
             *
             * Example usage:
             *   goog.dom.safe.setButtonFormAction(buttonEl, url);
             * which is a safe alternative to
             *   buttonEl.action = url;
             * The latter can result in XSS vulnerabilities if url is a
             * user-/attacker-controlled value.
             *
             * @param {!Element} button The button element whose action property
             *     is to be assigned to.
             * @param {string|!goog.html.SafeUrl} url The URL to assign.
             * @see goog.html.SafeUrl#sanitize
             */
            function setButtonFormAction(button, url) {
                /** @type {!goog.html.SafeUrl} */
                var safeUrl;
                if (url instanceof goog.html.SafeUrl) {
                    safeUrl = url;
                }
                else {
                    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
                }
                goog.dom.asserts.assertIsHTMLButtonElement(button).formaction =
                    goog.html.SafeUrl.unwrap(safeUrl);
            }
            safe.setButtonFormAction = setButtonFormAction;
            ;
            /**
             * Safely assigns a URL to an input element's formaction property.
             *
             * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
             * anchor's href property.  If url is of type string however, it is first
             * sanitized using goog.html.SafeUrl.sanitize.
             *
             * Example usage:
             *   goog.dom.safe.setInputFormAction(inputEl, url);
             * which is a safe alternative to
             *   inputEl.action = url;
             * The latter can result in XSS vulnerabilities if url is a
             * user-/attacker-controlled value.
             *
             * @param {!Element} input The input element whose action property
             *     is to be assigned to.
             * @param {string|!goog.html.SafeUrl} url The URL to assign.
             * @see goog.html.SafeUrl#sanitize
             */
            function setInputFormAction(input, url) {
                /** @type {!goog.html.SafeUrl} */
                var safeUrl;
                if (url instanceof goog.html.SafeUrl) {
                    safeUrl = url;
                }
                else {
                    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
                }
                goog.dom.asserts.assertIsHTMLInputElement(input).formaction =
                    goog.html.SafeUrl.unwrap(safeUrl);
            }
            safe.setInputFormAction = setInputFormAction;
            ;
            /**
             * Sets the given element's style property to the contents of the provided
             * SafeStyle object.
             * @param {!Element} elem
             * @param {!goog.html.SafeStyle} style
             */
            function setStyle(elem, style) {
                elem.style.cssText = goog.html.SafeStyle.unwrap(style);
            }
            safe.setStyle = setStyle;
            ;
            /**
             * Writes known-safe HTML to a document.
             * @param {!Document} doc The document to be written to.
             * @param {!goog.html.SafeHtml} html The known-safe HTML to assign.
             */
            function documentWrite(doc, html) {
                doc.write(goog.html.SafeHtml.unwrap(html));
            }
            safe.documentWrite = documentWrite;
            ;
            /**
             * Safely assigns a URL to an anchor element's href property.
             *
             * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
             * anchor's href property.  If url is of type string however, it is first
             * sanitized using goog.html.SafeUrl.sanitize.
             *
             * Example usage:
             *   goog.dom.safe.setAnchorHref(anchorEl, url);
             * which is a safe alternative to
             *   anchorEl.href = url;
             * The latter can result in XSS vulnerabilities if url is a
             * user-/attacker-controlled value.
             *
             * @param {!HTMLAnchorElement} anchor The anchor element whose href property
             *     is to be assigned to.
             * @param {string|!goog.html.SafeUrl} url The URL to assign.
             * @see goog.html.SafeUrl#sanitize
             */
            function setAnchorHref(anchor, url) {
                goog.dom.asserts.assertIsHTMLAnchorElement(anchor);
                /** @type {!goog.html.SafeUrl} */
                var safeUrl;
                if (url instanceof goog.html.SafeUrl) {
                    safeUrl = url;
                }
                else {
                    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
                }
                anchor.href = goog.html.SafeUrl.unwrap(safeUrl);
            }
            safe.setAnchorHref = setAnchorHref;
            ;
            /**
             * Safely assigns a URL to an image element's src property.
             *
             * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
             * image's src property.  If url is of type string however, it is first
             * sanitized using goog.html.SafeUrl.sanitize.
             *
             * @param {!HTMLImageElement} imageElement The image element whose src property
             *     is to be assigned to.
             * @param {string|!goog.html.SafeUrl} url The URL to assign.
             * @see goog.html.SafeUrl#sanitize
             */
            function setImageSrc(imageElement, url) {
                goog.dom.asserts.assertIsHTMLImageElement(imageElement);
                /** @type {!goog.html.SafeUrl} */
                var safeUrl;
                if (url instanceof goog.html.SafeUrl) {
                    safeUrl = url;
                }
                else {
                    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
                }
                imageElement.src = goog.html.SafeUrl.unwrap(safeUrl);
            }
            safe.setImageSrc = setImageSrc;
            ;
            /**
             * Safely assigns a URL to a video element's src property.
             *
             * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
             * video's src property.  If url is of type string however, it is first
             * sanitized using goog.html.SafeUrl.sanitize.
             *
             * @param {!HTMLVideoElement} videoElement The video element whose src property
             *     is to be assigned to.
             * @param {string|!goog.html.SafeUrl} url The URL to assign.
             * @see goog.html.SafeUrl#sanitize
             */
            function setVideoSrc(videoElement, url) {
                goog.dom.asserts.assertIsHTMLVideoElement(videoElement);
                /** @type {!goog.html.SafeUrl} */
                var safeUrl;
                if (url instanceof goog.html.SafeUrl) {
                    safeUrl = url;
                }
                else {
                    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
                }
                videoElement.src = goog.html.SafeUrl.unwrap(safeUrl);
            }
            safe.setVideoSrc = setVideoSrc;
            ;
            /**
             * Safely assigns a URL to an embed element's src property.
             *
             * Example usage:
             *   goog.dom.safe.setEmbedSrc(embedEl, url);
             * which is a safe alternative to
             *   embedEl.src = url;
             * The latter can result in loading untrusted code unless it is ensured that
             * the URL refers to a trustworthy resource.
             *
             * @param {!HTMLEmbedElement} embed The embed element whose src property
             *     is to be assigned to.
             * @param {!goog.html.TrustedResourceUrl} url The URL to assign.
             */
            function setEmbedSrc(embed, url) {
                goog.dom.asserts.assertIsHTMLEmbedElement(embed);
                embed.src = goog.html.TrustedResourceUrl.unwrap(url);
            }
            safe.setEmbedSrc = setEmbedSrc;
            ;
            /**
             * Safely assigns a URL to a frame element's src property.
             *
             * Example usage:
             *   goog.dom.safe.setFrameSrc(frameEl, url);
             * which is a safe alternative to
             *   frameEl.src = url;
             * The latter can result in loading untrusted code unless it is ensured that
             * the URL refers to a trustworthy resource.
             *
             * @param {!HTMLFrameElement} frame The frame element whose src property
             *     is to be assigned to.
             * @param {!goog.html.TrustedResourceUrl} url The URL to assign.
             */
            function setFrameSrc(frame, url) {
                goog.dom.asserts.assertIsHTMLFrameElement(frame);
                frame.src = goog.html.TrustedResourceUrl.unwrap(url);
            }
            safe.setFrameSrc = setFrameSrc;
            ;
            /**
             * Safely assigns a URL to an iframe element's src property.
             *
             * Example usage:
             *   goog.dom.safe.setIframeSrc(iframeEl, url);
             * which is a safe alternative to
             *   iframeEl.src = url;
             * The latter can result in loading untrusted code unless it is ensured that
             * the URL refers to a trustworthy resource.
             *
             * @param {!HTMLIFrameElement} iframe The iframe element whose src property
             *     is to be assigned to.
             * @param {!goog.html.TrustedResourceUrl} url The URL to assign.
             */
            function setIframeSrc(iframe, url) {
                goog.dom.asserts.assertIsHTMLIFrameElement(iframe);
                iframe.src = goog.html.TrustedResourceUrl.unwrap(url);
            }
            safe.setIframeSrc = setIframeSrc;
            ;
            /**
             * Safely assigns HTML to an iframe element's srcdoc property.
             *
             * Example usage:
             *   goog.dom.safe.setIframeSrcdoc(iframeEl, safeHtml);
             * which is a safe alternative to
             *   iframeEl.srcdoc = html;
             * The latter can result in loading untrusted code.
             *
             * @param {!HTMLIFrameElement} iframe The iframe element whose srcdoc property
             *     is to be assigned to.
             * @param {!goog.html.SafeHtml} html The HTML to assign.
             */
            function setIframeSrcdoc(iframe, html) {
                goog.dom.asserts.assertIsHTMLIFrameElement(iframe);
                iframe.srcdoc = goog.html.SafeHtml.unwrap(html);
            }
            safe.setIframeSrcdoc = setIframeSrcdoc;
            ;
            /**
             * Safely sets a link element's href and rel properties. Whether or not
             * the URL assigned to href has to be a goog.html.TrustedResourceUrl
             * depends on the value of the rel property. If rel contains "stylesheet"
             * then a TrustedResourceUrl is required.
             *
             * Example usage:
             *   goog.dom.safe.setLinkHrefAndRel(linkEl, url, 'stylesheet');
             * which is a safe alternative to
             *   linkEl.rel = 'stylesheet';
             *   linkEl.href = url;
             * The latter can result in loading untrusted code unless it is ensured that
             * the URL refers to a trustworthy resource.
             *
             * @param {!HTMLLinkElement} link The link element whose href property
             *     is to be assigned to.
             * @param {string|!goog.html.SafeUrl|!goog.html.TrustedResourceUrl} url The URL
             *     to assign to the href property. Must be a TrustedResourceUrl if the
             *     value assigned to rel contains "stylesheet". A string value is
             *     sanitized with goog.html.SafeUrl.sanitize.
             * @param {string} rel The value to assign to the rel property.
             * @throws {Error} if rel contains "stylesheet" and url is not a
             *     TrustedResourceUrl
             * @see goog.html.SafeUrl#sanitize
             */
            function setLinkHrefAndRel(link, url, rel) {
                goog.dom.asserts.assertIsHTMLLinkElement(link);
                link.rel = rel;
                if (goog.string.caseInsensitiveContains(rel, 'stylesheet')) {
                    goog.asserts.assert(url instanceof goog.html.TrustedResourceUrl, 'URL must be TrustedResourceUrl because "rel" contains "stylesheet"');
                    link.href = goog.html.TrustedResourceUrl.unwrap(url);
                }
                else if (url instanceof goog.html.TrustedResourceUrl) {
                    link.href = goog.html.TrustedResourceUrl.unwrap(url);
                }
                else if (url instanceof goog.html.SafeUrl) {
                    link.href = goog.html.SafeUrl.unwrap(url);
                }
                else {
                    // SafeUrl.sanitize must return legitimate SafeUrl when passed a string.
                    link.href =
                        goog.html.SafeUrl.sanitizeAssertUnchanged(url).getTypedStringValue();
                }
            }
            safe.setLinkHrefAndRel = setLinkHrefAndRel;
            ;
            /**
             * Safely assigns a URL to an object element's data property.
             *
             * Example usage:
             *   goog.dom.safe.setObjectData(objectEl, url);
             * which is a safe alternative to
             *   objectEl.data = url;
             * The latter can result in loading untrusted code unless setit is ensured that
             * the URL refers to a trustworthy resource.
             *
             * @param {!HTMLObjectElement} object The object element whose data property
             *     is to be assigned to.
             * @param {!goog.html.TrustedResourceUrl} url The URL to assign.
             */
            function setObjectData(object, url) {
                goog.dom.asserts.assertIsHTMLObjectElement(object);
                object.data = goog.html.TrustedResourceUrl.unwrap(url);
            }
            safe.setObjectData = setObjectData;
            ;
            /**
             * Safely assigns a URL to a script element's src property.
             *
             * Example usage:
             *   goog.dom.safe.setScriptSrc(scriptEl, url);
             * which is a safe alternative to
             *   scriptEl.src = url;
             * The latter can result in loading untrusted code unless it is ensured that
             * the URL refers to a trustworthy resource.
             *
             * @param {!HTMLScriptElement} script The script element whose src property
             *     is to be assigned to.
             * @param {!goog.html.TrustedResourceUrl} url The URL to assign.
             */
            function setScriptSrc(script, url) {
                goog.dom.asserts.assertIsHTMLScriptElement(script);
                script.src = goog.html.TrustedResourceUrl.unwrap(url);
            }
            safe.setScriptSrc = setScriptSrc;
            ;
            /**
             * Safely assigns a value to a script element's content.
             *
             * Example usage:
             *   goog.dom.safe.setScriptContent(scriptEl, content);
             * which is a safe alternative to
             *   scriptEl.text = content;
             * The latter can result in executing untrusted code unless it is ensured that
             * the code is loaded from a trustworthy resource.
             *
             * @param {!HTMLScriptElement} script The script element whose content is being
             *     set.
             * @param {!goog.html.SafeScript} content The content to assign.
             */
            function setScriptContent(script, content) {
                goog.dom.asserts.assertIsHTMLScriptElement(script);
                script.text = goog.html.SafeScript.unwrap(content);
            }
            safe.setScriptContent = setScriptContent;
            ;
            /**
             * Safely assigns a URL to a Location object's href property.
             *
             * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
             * loc's href property.  If url is of type string however, it is first sanitized
             * using goog.html.SafeUrl.sanitize.
             *
             * Example usage:
             *   goog.dom.safe.setLocationHref(document.location, redirectUrl);
             * which is a safe alternative to
             *   document.location.href = redirectUrl;
             * The latter can result in XSS vulnerabilities if redirectUrl is a
             * user-/attacker-controlled value.
             *
             * @param {!Location} loc The Location object whose href property is to be
             *     assigned to.
             * @param {string|!goog.html.SafeUrl} url The URL to assign.
             * @see goog.html.SafeUrl#sanitize
             */
            function setLocationHref(loc, url) {
                goog.dom.asserts.assertIsLocation(loc);
                /** @type {!goog.html.SafeUrl} */
                var safeUrl;
                if (url instanceof goog.html.SafeUrl) {
                    safeUrl = url;
                }
                else {
                    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
                }
                loc.href = goog.html.SafeUrl.unwrap(safeUrl);
            }
            safe.setLocationHref = setLocationHref;
            ;
            /**
             * Safely replaces the URL of a Location object.
             *
             * If url is of type goog.html.SafeUrl, its value is unwrapped and
             * passed to Location#replace. If url is of type string however, it is
             * first sanitized using goog.html.SafeUrl.sanitize.
             *
             * Example usage:
             *   goog.dom.safe.replaceHref(document.location, newUrl);
             * which is a safe alternative to
             *   document.location.replace(newUrl);
             * The latter can result in XSS vulnerabilities if newUrl is a
             * user-/attacker-controlled value.
             *
             * @param {!Location} loc The Location object which is to be replaced.
             * @param {string|!goog.html.SafeUrl} url The URL to assign.
             * @see goog.html.SafeUrl#sanitize
             */
            function replaceLocation(loc, url) {
                goog.dom.asserts.assertIsLocation(loc);
                /** @type {!goog.html.SafeUrl} */
                var safeUrl;
                if (url instanceof goog.html.SafeUrl) {
                    safeUrl = url;
                }
                else {
                    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
                }
                loc.replace(goog.html.SafeUrl.unwrap(safeUrl));
            }
            safe.replaceLocation = replaceLocation;
            ;
            /**
             * Safely opens a URL in a new window (via window.open).
             *
             * If url is of type goog.html.SafeUrl, its value is unwrapped and passed in to
             * window.open.  If url is of type string however, it is first sanitized
             * using goog.html.SafeUrl.sanitize.
             *
             * Note that this function does not prevent leakages via the referer that is
             * sent by window.open. It is advised to only use this to open 1st party URLs.
             *
             * Example usage:
             *   goog.dom.safe.openInWindow(url);
             * which is a safe alternative to
             *   window.open(url);
             * The latter can result in XSS vulnerabilities if redirectUrl is a
             * user-/attacker-controlled value.
             *
             * @param {string|!goog.html.SafeUrl} url The URL to open.
             * @param {Window=} opt_openerWin Window of which to call the .open() method.
             *     Defaults to the global window.
             * @param {!goog.string.Const=} opt_name Name of the window to open in. Can be
             *     _top, etc as allowed by window.open().
             * @param {string=} opt_specs Comma-separated list of specifications, same as
             *     in window.open().
             * @param {boolean=} opt_replace Whether to replace the current entry in browser
             *     history, same as in window.open().
             * @return {Window} Window the url was opened in.
             */
            function openInWindow(url, opt_openerWin, opt_name, opt_specs, opt_replace) {
                /** @type {!goog.html.SafeUrl} */
                var safeUrl;
                if (url instanceof goog.html.SafeUrl) {
                    safeUrl = url;
                }
                else {
                    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
                }
                var win = opt_openerWin || window;
                return win.open(goog.html.SafeUrl.unwrap(safeUrl), 
                // If opt_name is undefined, simply passing that in to open() causes IE to
                // reuse the current window instead of opening a new one. Thus we pass ''
                // in instead, which according to spec opens a new window. See
                // https://html.spec.whatwg.org/multipage/browsers.html#dom-open .
                opt_name ? goog.string.Const.unwrap(opt_name) : '', opt_specs, opt_replace);
            }
            safe.openInWindow = openInWindow;
            ;
        })(safe = dom.safe || (dom.safe = {}));
    })(dom = goog.dom || (goog.dom = {}));
})(goog || (goog = {}));
/// <reference path="../specialtype.ts" />
/// <reference path="../base.ts" />
/// <reference path="./tagname.ts" />
/// <reference path="../string/string.ts" />
/// <reference path="../asserts/asserts.ts" />
/// <reference path="../math/coordinate.ts" />
/// <reference path="../math/size.ts" />
/// <reference path="../useragent/useragent.ts" />
/// <reference path="../dom/browserfeature.ts" />
/// <reference path="../string/const.ts" />
/// <reference path="../html/safehtml.ts" />
/// <reference path="../html/uncheckedconversions.ts" />
/// <reference path="../dom/safe.ts" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utilities for manipulating the browser's Document Object Model
 * Inspiration taken *heavily* from mochikit (http://mochikit.com/).
 *
 * You can use {@link goog.dom.DomHelper} to create new dom helpers that refer
 * to a different document object.  This is useful if you are working with
 * frames or multiple windows.
 *
 * @author arv@google.com (Erik Arvidsson)
 */
// TODO(arv): Rename/refactor getTextContent and getRawTextContent. The problem
// is that getTextContent should mimic the DOM3 textContent. We should add a
// getInnerText (or getText) which tries to return the visible text, innerText.
goog.provide('goog.dom');
goog.provide('goog.dom.Appendable');
goog.provide('goog.dom.DomHelper');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom.BrowserFeature');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.safe');
goog.require('goog.html.SafeHtml');
goog.require('goog.html.uncheckedconversions');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Size');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.string.Unicode');
goog.require('goog.userAgent');
/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * quirks mode.
 */
goog.define('goog.dom.ASSUME_QUIRKS_MODE', false);
/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * standards compliance mode.
 */
goog.define('goog.dom.ASSUME_STANDARDS_MODE', false);
/**
 * Whether we know the compatibility mode at compile time.
 * @type {boolean}
 * @private
 */
goog.dom.COMPAT_MODE_KNOWN_ =
    goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;
var goog;
(function (goog) {
    var dom;
    (function (dom) {
        /**
         * Gets the DomHelper object for the document where the element resides.
         * @param {(Node|Window)=} opt_element If present, gets the DomHelper for this
         *     element.
         * @return {!goog.dom.DomHelper} The DomHelper.
         */
        function getDomHelper(opt_element) {
            return opt_element ?
                new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) :
                (goog.dom.defaultDomHelper_ ||
                    (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper()));
        }
        dom.getDomHelper = getDomHelper;
        /**
         * Gets the document object being used by the dom library.
         * @return {!Document} Document object.
         */
        function getDocument() {
            return document;
        }
        dom.getDocument = getDocument;
        ;
        /**
         * Gets an element from the current document by element id.
         *
         * If an Element is passed in, it is returned.
         *
         * @param {string|Element} element Element ID or a DOM node.
         * @return {Element} The element with the given ID, or the node passed in.
         */
        function getElement(element) {
            return goog.dom.getElementHelper_(document, element);
        }
        dom.getElement = getElement;
        ;
        /**
         * Gets an element by id from the given document (if present).
         * If an element is given, it is returned.
         * @param {!Document} doc
         * @param {string|Element} element Element ID or a DOM node.
         * @return {Element} The resulting element.
         * @private
         */
        function getElementHelper_(doc, element) {
            return goog.isString(element) ? doc.getElementById(element) : element;
        }
        dom.getElementHelper_ = getElementHelper_;
        ;
        /**
         * Gets an element by id, asserting that the element is found.
         *
         * This is used when an element is expected to exist, and should fail with
         * an assertion error if it does not (if assertions are enabled).
         *
         * @param {string} id Element ID.
         * @return {!Element} The element with the given ID, if it exists.
         */
        function getRequiredElement(id) {
            return goog.dom.getRequiredElementHelper_(document, id);
        }
        dom.getRequiredElement = getRequiredElement;
        ;
        /**
         * Helper function for getRequiredElementHelper functions, both static and
         * on DomHelper.  Asserts the element with the given id exists.
         * @param {!Document} doc
         * @param {string} id
         * @return {!Element} The element with the given ID, if it exists.
         * @private
         */
        function getRequiredElementHelper_(doc, id) {
            // To prevent users passing in Elements as is permitted in getElement().
            goog.asserts.assertString(id);
            var element = goog.dom.getElementHelper_(doc, id);
            element =
                goog.asserts.assertElement(element, 'No element found with id: ' + id);
            return element;
        }
        dom.getRequiredElementHelper_ = getRequiredElementHelper_;
        ;
        /**
         * Alias for getElement.
         * @param {string|Element} element Element ID or a DOM node.
         * @return {Element} The element with the given ID, or the node passed in.
         * @deprecated Use {@link goog.dom.getElement} instead.
         */
        function $(element) {
            return goog.dom.getElement(element);
        }
        dom.$ = $;
        /**
         * Gets elements by tag name.
         * @param {!goog.dom.TagName<T>} tagName
         * @param {(!Document|!Element)=} opt_parent Parent element or document where to
         *     look for elements. Defaults to document.
         * @return {!NodeList<R>} List of elements. The members of the list are
         *     {!Element} if tagName is not a member of goog.dom.TagName or more
         *     specific types if it is (e.g. {!HTMLAnchorElement} for
         *     goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         */
        function getElementsByTagName(tagName, opt_parent) {
            var parent = opt_parent || document;
            return parent.getElementsByTagName(String(tagName));
        }
        dom.getElementsByTagName = getElementsByTagName;
        ;
        /**
         * Looks up elements by both tag and class name, using browser native functions
         * ({@code querySelectorAll}, {@code getElementsByTagName} or
         * {@code getElementsByClassName}) where possible. This function
         * is a useful, if limited, way of collecting a list of DOM elements
         * with certain characteristics.  {@code goog.dom.query} offers a
         * more powerful and general solution which allows matching on CSS3
         * selector expressions, but at increased cost in code size. If all you
         * need is particular tags belonging to a single class, this function
         * is fast and sleek.
         *
         * Note that tag names are case sensitive in the SVG namespace, and this
         * function converts opt_tag to uppercase for comparisons. For queries in the
         * SVG namespace you should use querySelector or querySelectorAll instead.
         * https://bugzilla.mozilla.org/show_bug.cgi?id=963870
         * https://bugs.webkit.org/show_bug.cgi?id=83438
         *
         * @see {goog.dom.query}
         *
         * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
         * @param {?string=} opt_class Optional class name.
         * @param {(Document|Element)=} opt_el Optional element to look in.
         * @return {!IArrayLike<R>} Array-like list of elements (only a length property
         *     and numerical indices are guaranteed to exist). The members of the array
         *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more
         *     specific types if it is (e.g. {!HTMLAnchorElement} for
         *     goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         */
        function getElementsByTagNameAndClass(opt_tag, opt_class, opt_el) {
            return goog.dom.getElementsByTagNameAndClass_(document, opt_tag, opt_class, opt_el);
        }
        dom.getElementsByTagNameAndClass = getElementsByTagNameAndClass;
        ;
        /**
         * Gets the first element matching the tag and the class.
         *
         * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
         * @param {?string=} opt_class Optional class name.
         * @param {(Document|Element)=} opt_el Optional element to look in.
         * @return {?R} Reference to a DOM node. The return type is {?Element} if
         *     tagName is a string or a more specific type if it is a member of
         *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         */
        function getElementByTagNameAndClass(opt_tag, opt_class, opt_el) {
            return goog.dom.getElementByTagNameAndClass_(document, opt_tag, opt_class, opt_el);
        }
        dom.getElementByTagNameAndClass = getElementByTagNameAndClass;
        ;
        /**
         * Returns a static, array-like list of the elements with the provided
         * className.
         * @see {goog.dom.query}
         * @param {string} className the name of the class to look for.
         * @param {(Document|Element)=} opt_el Optional element to look in.
         * @return {!IArrayLike<!Element>} The items found with the class name provided.
         */
        function getElementsByClass(className, opt_el) {
            var parent = opt_el || document;
            if (goog.dom.canUseQuerySelector_(parent)) {
                return parent.querySelectorAll('.' + className);
            }
            return goog.dom.getElementsByTagNameAndClass_(document, '*', className, opt_el);
        }
        dom.getElementsByClass = getElementsByClass;
        ;
        /**
         * Returns the first element with the provided className.
         * @see {goog.dom.query}
         * @param {string} className the name of the class to look for.
         * @param {Element|Document=} opt_el Optional element to look in.
         * @return {Element} The first item with the class name provided.
         */
        function getElementByClass(className, opt_el) {
            var parent = opt_el || document;
            var retVal = null;
            if (parent.getElementsByClassName) {
                retVal = parent.getElementsByClassName(className)[0];
            }
            else {
                retVal =
                    goog.dom.getElementByTagNameAndClass_(document, '*', className, opt_el);
            }
            return retVal || null;
        }
        dom.getElementByClass = getElementByClass;
        ;
        /**
         * Ensures an element with the given className exists, and then returns the
         * first element with the provided className.
         * @see {goog.dom.query}
         * @param {string} className the name of the class to look for.
         * @param {!Element|!Document=} opt_root Optional element or document to look
         *     in.
         * @return {!Element} The first item with the class name provided.
         * @throws {goog.asserts.AssertionError} Thrown if no element is found.
         */
        function getRequiredElementByClass(className, opt_root) {
            var retValue = goog.dom.getElementByClass(className, opt_root);
            return goog.asserts.assert(retValue, 'No element found with className: ' + className);
        }
        dom.getRequiredElementByClass = getRequiredElementByClass;
        ;
        /**
         * Prefer the standardized (http://www.w3.org/TR/selectors-api/), native and
         * fast W3C Selectors API.
         * @param {!(Element|Document)} parent The parent document object.
         * @return {boolean} whether or not we can use parent.querySelector* APIs.
         * @private
         */
        function canUseQuerySelector_(parent) {
            return !!(parent.querySelectorAll && parent.querySelector);
        }
        dom.canUseQuerySelector_ = canUseQuerySelector_;
        ;
        /**
         * Helper for {@code getElementsByTagNameAndClass}.
         * @param {!Document} doc The document to get the elements in.
         * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
         * @param {?string=} opt_class Optional class name.
         * @param {(Document|Element)=} opt_el Optional element to look in.
         * @return {!IArrayLike<R>} Array-like list of elements (only a length property
         *     and numerical indices are guaranteed to exist). The members of the array
         *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more
         *     specific types if it is (e.g. {!HTMLAnchorElement} for
         *     goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         * @private
         */
        function getElementsByTagNameAndClass_(doc, opt_tag, opt_class, opt_el) {
            var parent = opt_el || doc;
            var tagName = (opt_tag && opt_tag != '*') ? String(opt_tag).toUpperCase() : '';
            if (goog.dom.canUseQuerySelector_(parent) && (tagName || opt_class)) {
                var query = tagName + (opt_class ? '.' + opt_class : '');
                return parent.querySelectorAll(query);
            }
            // Use the native getElementsByClassName if available, under the assumption
            // that even when the tag name is specified, there will be fewer elements to
            // filter through when going by class than by tag name
            if (opt_class && parent.getElementsByClassName) {
                var els = parent.getElementsByClassName(opt_class);
                if (tagName) {
                    var arrayLike = {};
                    var len = 0;
                    // Filter for specific tags if requested.
                    for (var i = 0, el; el = els[i]; i++) {
                        if (tagName == el.nodeName) {
                            arrayLike[len++] = el;
                        }
                    }
                    arrayLike.length = len;
                    return /** @type {!IArrayLike<!Element>} */ (arrayLike);
                }
                else {
                    return els;
                }
            }
            var els = parent.getElementsByTagName(tagName || '*');
            if (opt_class) {
                var arrayLike = {};
                var len = 0;
                for (var i = 0, el; el = els[i]; i++) {
                    var className = el.className;
                    // Check if className has a split function since SVG className does not.
                    if (typeof className.split == 'function' &&
                        goog.array.contains(className.split(/\s+/), opt_class)) {
                        arrayLike[len++] = el;
                    }
                }
                arrayLike.length = len;
                return /** @type {!IArrayLike<!Element>} */ (arrayLike);
            }
            else {
                return els;
            }
        }
        dom.getElementsByTagNameAndClass_ = getElementsByTagNameAndClass_;
        ;
        /**
         * Helper for goog.dom.getElementByTagNameAndClass.
         *
         * @param {!Document} doc The document to get the elements in.
         * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
         * @param {?string=} opt_class Optional class name.
         * @param {(Document|Element)=} opt_el Optional element to look in.
         * @return {?R} Reference to a DOM node. The return type is {?Element} if
         *     tagName is a string or a more specific type if it is a member of
         *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         * @private
         */
        function getElementByTagNameAndClass_(doc, opt_tag, opt_class, opt_el) {
            var parent = opt_el || doc;
            var tag = (opt_tag && opt_tag != '*') ? String(opt_tag).toUpperCase() : '';
            if (goog.dom.canUseQuerySelector_(parent) && (tag || opt_class)) {
                return parent.querySelector(tag + (opt_class ? '.' + opt_class : ''));
            }
            var elements = goog.dom.getElementsByTagNameAndClass_(doc, opt_tag, opt_class, opt_el);
            return elements[0] || null;
        }
        dom.getElementByTagNameAndClass_ = getElementByTagNameAndClass_;
        ;
        /**
         * Alias for {@code getElementsByTagNameAndClass}.
         * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
         * @param {?string=} opt_class Optional class name.
         * @param {Element=} opt_el Optional element to look in.
         * @return {!IArrayLike<R>} Array-like list of elements (only a length property
         *     and numerical indices are guaranteed to exist). The members of the array
         *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more
         *     specific types if it is (e.g. {!HTMLAnchorElement} for
         *     goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         * @deprecated Use {@link goog.dom.getElementsByTagNameAndClass} instead.
         */
        function $$(opt_tag, opt_class, opt_el) {
            return goog.dom.getElementsByTagNameAndClass(opt_tag, opt_class, opt_el);
        }
        dom.$$ = $$;
        /**
         * Sets multiple properties, and sometimes attributes, on an element. Note that
         * properties are simply object properties on the element instance, while
         * attributes are visible in the DOM. Many properties map to attributes with the
         * same names, some with different names, and there are also unmappable cases.
         *
         * This method sets properties by default (which means that custom attributes
         * are not supported). These are the exeptions (some of which is legacy):
         * - "style": Even though this is an attribute name, it is translated to a
         *   property, "style.cssText". Note that this property sanitizes and formats
         *   its value, unlike the attribute.
         * - "class": This is an attribute name, it is translated to the "className"
         *   property.
         * - "for": This is an attribute name, it is translated to the "htmlFor"
         *   property.
         * - Entries in {@see goog.dom.DIRECT_ATTRIBUTE_MAP_} are set as attributes,
         *   this is probably due to browser quirks.
         * - "aria-*", "data-*": Always set as attributes, they have no property
         *   counterparts.
         *
         * @param {Element} element DOM node to set properties on.
         * @param {Object} properties Hash of property:value pairs.
         *     Property values can be strings or goog.string.TypedString values (such as
         *     goog.html.SafeUrl).
         */
        function setProperties(element, properties) {
            goog.object.forEach(properties, function (val, key) {
                if (val && val.implementsGoogStringTypedString) {
                    val = val.getTypedStringValue();
                }
                if (key == 'style') {
                    element.style.cssText = val;
                }
                else if (key == 'class') {
                    element.className = val;
                }
                else if (key == 'for') {
                    element.htmlFor = val;
                }
                else if (goog.dom.DIRECT_ATTRIBUTE_MAP_.hasOwnProperty(key)) {
                    element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);
                }
                else if (goog.string.startsWith(key, 'aria-') ||
                    goog.string.startsWith(key, 'data-')) {
                    element.setAttribute(key, val);
                }
                else {
                    element[key] = val;
                }
            });
        }
        dom.setProperties = setProperties;
        ;
        /**
         * Map of attributes that should be set using
         * element.setAttribute(key, val) instead of element[key] = val.  Used
         * by goog.dom.setProperties.
         *
         * @private {!Object<string, string>}
         * @const
         */
        dom.DIRECT_ATTRIBUTE_MAP_ = {
            'cellpadding': 'cellPadding',
            'cellspacing': 'cellSpacing',
            'colspan': 'colSpan',
            'frameborder': 'frameBorder',
            'height': 'height',
            'maxlength': 'maxLength',
            'nonce': 'nonce',
            'role': 'role',
            'rowspan': 'rowSpan',
            'type': 'type',
            'usemap': 'useMap',
            'valign': 'vAlign',
            'width': 'width'
        };
        /**
         * Gets the dimensions of the viewport.
         *
         * Gecko Standards mode:
         * docEl.clientWidth  Width of viewport excluding scrollbar.
         * win.innerWidth     Width of viewport including scrollbar.
         * body.clientWidth   Width of body element.
         *
         * docEl.clientHeight Height of viewport excluding scrollbar.
         * win.innerHeight    Height of viewport including scrollbar.
         * body.clientHeight  Height of document.
         *
         * Gecko Backwards compatible mode:
         * docEl.clientWidth  Width of viewport excluding scrollbar.
         * win.innerWidth     Width of viewport including scrollbar.
         * body.clientWidth   Width of viewport excluding scrollbar.
         *
         * docEl.clientHeight Height of document.
         * win.innerHeight    Height of viewport including scrollbar.
         * body.clientHeight  Height of viewport excluding scrollbar.
         *
         * IE6/7 Standards mode:
         * docEl.clientWidth  Width of viewport excluding scrollbar.
         * win.innerWidth     Undefined.
         * body.clientWidth   Width of body element.
         *
         * docEl.clientHeight Height of viewport excluding scrollbar.
         * win.innerHeight    Undefined.
         * body.clientHeight  Height of document element.
         *
         * IE5 + IE6/7 Backwards compatible mode:
         * docEl.clientWidth  0.
         * win.innerWidth     Undefined.
         * body.clientWidth   Width of viewport excluding scrollbar.
         *
         * docEl.clientHeight 0.
         * win.innerHeight    Undefined.
         * body.clientHeight  Height of viewport excluding scrollbar.
         *
         * Opera 9 Standards and backwards compatible mode:
         * docEl.clientWidth  Width of viewport excluding scrollbar.
         * win.innerWidth     Width of viewport including scrollbar.
         * body.clientWidth   Width of viewport excluding scrollbar.
         *
         * docEl.clientHeight Height of document.
         * win.innerHeight    Height of viewport including scrollbar.
         * body.clientHeight  Height of viewport excluding scrollbar.
         *
         * WebKit:
         * Safari 2
         * docEl.clientHeight Same as scrollHeight.
         * docEl.clientWidth  Same as innerWidth.
         * win.innerWidth     Width of viewport excluding scrollbar.
         * win.innerHeight    Height of the viewport including scrollbar.
         * frame.innerHeight  Height of the viewport exluding scrollbar.
         *
         * Safari 3 (tested in 522)
         *
         * docEl.clientWidth  Width of viewport excluding scrollbar.
         * docEl.clientHeight Height of viewport excluding scrollbar in strict mode.
         * body.clientHeight  Height of viewport excluding scrollbar in quirks mode.
         *
         * @param {Window=} opt_window Optional window element to test.
         * @return {!goog.math.Size} Object with values 'width' and 'height'.
         */
        function getViewportSize(opt_window) {
            // TODO(arv): This should not take an argument
            return goog.dom.getViewportSize_(opt_window || window);
        }
        dom.getViewportSize = getViewportSize;
        ;
        /**
         * Helper for {@code getViewportSize}.
         * @param {Window} win The window to get the view port size for.
         * @return {!goog.math.Size} Object with values 'width' and 'height'.
         * @private
         */
        function getViewportSize_(win) {
            var doc = win.document;
            var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;
            return new goog.math.Size(el.clientWidth, el.clientHeight);
        }
        dom.getViewportSize_ = getViewportSize_;
        ;
        /**
         * Calculates the height of the document.
         *
         * @return {number} The height of the current document.
         */
        function getDocumentHeight() {
            return goog.dom.getDocumentHeight_(window);
        }
        dom.getDocumentHeight = getDocumentHeight;
        ;
        /**
         * Calculates the height of the document of the given window.
         *
         * @param {!Window} win The window whose document height to retrieve.
         * @return {number} The height of the document of the given window.
         */
        function getDocumentHeightForWindow(win) {
            return goog.dom.getDocumentHeight_(win);
        }
        dom.getDocumentHeightForWindow = getDocumentHeightForWindow;
        ;
        /**
         * Calculates the height of the document of the given window.
         *
         * Function code copied from the opensocial gadget api:
         *   gadgets.window.adjustHeight(opt_height)
         *
         * @private
         * @param {!Window} win The window whose document height to retrieve.
         * @return {number} The height of the document of the given window.
         */
        function getDocumentHeight_(win) {
            // NOTE(eae): This method will return the window size rather than the document
            // size in webkit quirks mode.
            var doc = win.document;
            var height = 0;
            if (doc) {
                // Calculating inner content height is hard and different between
                // browsers rendering in Strict vs. Quirks mode.  We use a combination of
                // three properties within document.body and document.documentElement:
                // - scrollHeight
                // - offsetHeight
                // - clientHeight
                // These values differ significantly between browsers and rendering modes.
                // But there are patterns.  It just takes a lot of time and persistence
                // to figure out.
                var body = doc.body;
                var docEl = (doc.documentElement);
                if (!(docEl && body)) {
                    return 0;
                }
                // Get the height of the viewport
                var vh = goog.dom.getViewportSize_(win).height;
                if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) {
                    // In Strict mode:
                    // The inner content height is contained in either:
                    //    document.documentElement.scrollHeight
                    //    document.documentElement.offsetHeight
                    // Based on studying the values output by different browsers,
                    // use the value that's NOT equal to the viewport height found above.
                    height =
                        docEl.scrollHeight != vh ? docEl.scrollHeight : docEl.offsetHeight;
                }
                else {
                    // In Quirks mode:
                    // documentElement.clientHeight is equal to documentElement.offsetHeight
                    // except in IE.  In most browsers, document.documentElement can be used
                    // to calculate the inner content height.
                    // However, in other browsers (e.g. IE), document.body must be used
                    // instead.  How do we know which one to use?
                    // If document.documentElement.clientHeight does NOT equal
                    // document.documentElement.offsetHeight, then use document.body.
                    var sh = docEl.scrollHeight;
                    var oh = docEl.offsetHeight;
                    if (docEl.clientHeight != oh) {
                        sh = body.scrollHeight;
                        oh = body.offsetHeight;
                    }
                    // Detect whether the inner content height is bigger or smaller
                    // than the bounding box (viewport).  If bigger, take the larger
                    // value.  If smaller, take the smaller value.
                    if (sh > vh) {
                        // Content is larger
                        height = sh > oh ? sh : oh;
                    }
                    else {
                        // Content is smaller
                        height = sh < oh ? sh : oh;
                    }
                }
            }
            return height;
        }
        dom.getDocumentHeight_ = getDocumentHeight_;
        ;
        /**
         * Gets the page scroll distance as a coordinate object.
         *
         * @param {Window=} opt_window Optional window element to test.
         * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
         * @deprecated Use {@link goog.dom.getDocumentScroll} instead.
         */
        function getPageScroll(opt_window) {
            var win = opt_window || goog.global || window;
            return goog.dom.getDomHelper(win.document).getDocumentScroll();
        }
        dom.getPageScroll = getPageScroll;
        ;
        /**
         * Gets the document scroll distance as a coordinate object.
         *
         * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
         */
        function getDocumentScroll() {
            return goog.dom.getDocumentScroll_(document);
        }
        dom.getDocumentScroll = getDocumentScroll;
        ;
        /**
         * Helper for {@code getDocumentScroll}.
         *
         * @param {!Document} doc The document to get the scroll for.
         * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
         * @private
         */
        function getDocumentScroll_(doc) {
            var el = goog.dom.getDocumentScrollElement_(doc);
            var win = goog.dom.getWindow_(doc);
            if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher('10') &&
                win.pageYOffset != el.scrollTop) {
                // The keyboard on IE10 touch devices shifts the page using the pageYOffset
                // without modifying scrollTop. For this case, we want the body scroll
                // offsets.
                return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);
            }
            return new goog.math.Coordinate(win.pageXOffset || el.scrollLeft, win.pageYOffset || el.scrollTop);
        }
        dom.getDocumentScroll_ = getDocumentScroll_;
        ;
        /**
         * Gets the document scroll element.
         * @return {!Element} Scrolling element.
         */
        function getDocumentScrollElement() {
            return goog.dom.getDocumentScrollElement_(document);
        }
        dom.getDocumentScrollElement = getDocumentScrollElement;
        ;
        /**
         * Helper for {@code getDocumentScrollElement}.
         * @param {!Document} doc The document to get the scroll element for.
         * @return {!Element} Scrolling element.
         * @private
         */
        function getDocumentScrollElement_(doc) {
            // Old WebKit needs body.scrollLeft in both quirks mode and strict mode. We
            // also default to the documentElement if the document does not have a body
            // (e.g. a SVG document).
            // Uses http://dev.w3.org/csswg/cssom-view/#dom-document-scrollingelement to
            // avoid trying to guess about browser behavior from the UA string.
            if (doc.scrollingElement) {
                return doc.scrollingElement;
            }
            if (!goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc)) {
                return doc.documentElement;
            }
            return doc.body || doc.documentElement;
        }
        dom.getDocumentScrollElement_ = getDocumentScrollElement_;
        ;
        /**
         * Gets the window object associated with the given document.
         *
         * @param {Document=} opt_doc  Document object to get window for.
         * @return {!Window} The window associated with the given document.
         */
        function getWindow(opt_doc) {
            // TODO(arv): This should not take an argument.
            return opt_doc ? goog.dom.getWindow_(opt_doc) : window;
        }
        dom.getWindow = getWindow;
        ;
        /**
         * Helper for {@code getWindow}.
         *
         * @param {!Document} doc  Document object to get window for.
         * @return {!Window} The window associated with the given document.
         * @private
         */
        function getWindow_(doc) {
            return /** @type {!Window} */ (doc.parentWindow || doc.defaultView);
        }
        dom.getWindow_ = getWindow_;
        ;
        /**
         * Returns a dom node with a set of attributes.  This function accepts varargs
         * for subsequent nodes to be added.  Subsequent nodes will be added to the
         * first node as childNodes.
         *
         * So:
         * <code>createDom(goog.dom.TagName.DIV, null, createDom(goog.dom.TagName.P),
         * createDom(goog.dom.TagName.P));</code> would return a div with two child
         * paragraphs
         *
         * For passing properties, please see {@link goog.dom.setProperties} for more
         * information.
         *
         * @param {string|!goog.dom.TagName<T>} tagName Tag to create.
         * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map
         *     of name-value pairs for attributes. If a string, then this is the
         *     className of the new element. If an array, the elements will be joined
         *     together as the className of the new element.
         * @param {...(Object|string|Array|NodeList)} var_args Further DOM nodes or
         *     strings for text nodes. If one of the var_args is an array or NodeList,
         *     its elements will be added as childNodes instead.
         * @return {R} Reference to a DOM node. The return type is {!Element} if tagName
         *     is a string or a more specific type if it is a member of
         *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         */
        function createDom(tagName, opt_attributes) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            return goog.dom.createDom_(document, arguments);
        }
        dom.createDom = createDom;
        ;
        /**
         * Helper for {@code createDom}.
         * @param {!Document} doc The document to create the DOM in.
         * @param {!Arguments} args Argument object passed from the callers. See
         *     {@code goog.dom.createDom} for details.
         * @return {!Element} Reference to a DOM node.
         * @private
         */
        function createDom_(doc, args) {
            var tagName = String(args[0]);
            var attributes = args[1];
            // Internet Explorer is dumb:
            // name: https://msdn.microsoft.com/en-us/library/ms534184(v=vs.85).aspx
            // type: https://msdn.microsoft.com/en-us/library/ms534700(v=vs.85).aspx
            // Also does not allow setting of 'type' attribute on 'input' or 'button'.
            if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes &&
                (attributes.name || attributes.type)) {
                var tagNameArr = ['<', tagName];
                if (attributes.name) {
                    tagNameArr.push(' name="', goog.string.htmlEscape(attributes.name), '"');
                }
                if (attributes.type) {
                    tagNameArr.push(' type="', goog.string.htmlEscape(attributes.type), '"');
                    // Clone attributes map to remove 'type' without mutating the input.
                    var clone = {};
                    goog.object.extend(clone, attributes);
                    // JSCompiler can't see how goog.object.extend added this property,
                    // because it was essentially added by reflection.
                    // So it needs to be quoted.
                    delete clone['type'];
                    attributes = clone;
                }
                tagNameArr.push('>');
                tagName = tagNameArr.join('');
            }
            var element = doc.createElement(tagName);
            if (attributes) {
                if (goog.isString(attributes)) {
                    element.className = attributes;
                }
                else if (goog.isArray(attributes)) {
                    element.className = attributes.join(' ');
                }
                else {
                    goog.dom.setProperties(element, attributes);
                }
            }
            if (args.length > 2) {
                goog.dom.append_(doc, element, args, 2);
            }
            return element;
        }
        dom.createDom_ = createDom_;
        ;
        /**
         * Appends a node with text or other nodes.
         * @param {!Document} doc The document to create new nodes in.
         * @param {!Node} parent The node to append nodes to.
         * @param {!Arguments} args The values to add. See {@code goog.dom.append}.
         * @param {number} startIndex The index of the array to start from.
         * @private
         */
        function append_(doc, parent, args, startIndex) {
            function childHandler(child) {
                // TODO(user): More coercion, ala MochiKit?
                if (child) {
                    parent.appendChild(goog.isString(child) ? doc.createTextNode(child) : child);
                }
            }
            for (var i = startIndex; i < args.length; i++) {
                var arg = args[i];
                // TODO(attila): Fix isArrayLike to return false for a text node.
                if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {
                    // If the argument is a node list, not a real array, use a clone,
                    // because forEach can't be used to mutate a NodeList.
                    goog.array.forEach(goog.dom.isNodeList(arg) ? goog.array.toArray(arg) : arg, childHandler);
                }
                else {
                    childHandler(arg);
                }
            }
        }
        dom.append_ = append_;
        ;
        /**
         * Alias for {@code createDom}.
         * @param {string|!goog.dom.TagName<T>} tagName Tag to create.
         * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map
         *     of name-value pairs for attributes. If a string, then this is the
         *     className of the new element. If an array, the elements will be joined
         *     together as the className of the new element.
         * @param {...(Object|string|Array|NodeList)} var_args Further DOM nodes or
         *     strings for text nodes. If one of the var_args is an array, its
         *     children will be added as childNodes instead.
         * @return {R} Reference to a DOM node. The return type is {!Element} if tagName
         *     is a string or a more specific type if it is a member of
         *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         * @deprecated Use {@link goog.dom.createDom} instead.
         */
        function $dom(tagName, opt_attributes) {
            var var_args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                var_args[_i - 2] = arguments[_i];
            }
            return goog.dom.createDom(tagName, opt_attributes, var_args);
        }
        dom.$dom = $dom;
        /**
         * Creates a new element.
         * @param {string|!goog.dom.TagName<T>} name Tag to create.
         * @return {R} The new element. The return type is {!Element} if name is
         *     a string or a more specific type if it is a member of goog.dom.TagName
         *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         */
        function createElement(name) {
            return goog.dom.createElement_(document, name);
        }
        dom.createElement = createElement;
        ;
        /**
         * Creates a new element.
         * @param {!Document} doc The document to create the element in.
         * @param {string|!goog.dom.TagName<T>} name Tag to create.
         * @return {R} The new element. The return type is {!Element} if name is
         *     a string or a more specific type if it is a member of goog.dom.TagName
         *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         * @private
         */
        function createElement_(doc, name) {
            return doc.createElement(String(name));
        }
        dom.createElement_ = createElement_;
        ;
        /**
         * Creates a new text node.
         * @param {number|string} content Content.
         * @return {!Text} The new text node.
         */
        function createTextNode(content) {
            return document.createTextNode(String(content));
        }
        dom.createTextNode = createTextNode;
        ;
        /**
         * Create a table.
         * @param {number} rows The number of rows in the table.  Must be >= 1.
         * @param {number} columns The number of columns in the table.  Must be >= 1.
         * @param {boolean=} opt_fillWithNbsp If true, fills table entries with
         *     {@code goog.string.Unicode.NBSP} characters.
         * @return {!Element} The created table.
         */
        function createTable(rows, columns, opt_fillWithNbsp) {
            // TODO(mlourenco): Return HTMLTableElement, also in prototype function.
            // Callers need to be updated to e.g. not assign numbers to table.cellSpacing.
            return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp);
        }
        dom.createTable = createTable;
        ;
        /**
         * Create a table.
         * @param {!Document} doc Document object to use to create the table.
         * @param {number} rows The number of rows in the table.  Must be >= 1.
         * @param {number} columns The number of columns in the table.  Must be >= 1.
         * @param {boolean} fillWithNbsp If true, fills table entries with
         *     {@code goog.string.Unicode.NBSP} characters.
         * @return {!HTMLTableElement} The created table.
         * @private
         */
        function createTable_(doc, rows, columns, fillWithNbsp) {
            var table = goog.dom.createElement_(doc, goog.dom.TagName.TABLE);
            var tbody = table.appendChild(goog.dom.createElement_(doc, goog.dom.TagName.TBODY));
            for (var i = 0; i < rows; i++) {
                var tr = goog.dom.createElement_(doc, goog.dom.TagName.TR);
                for (var j = 0; j < columns; j++) {
                    var td = goog.dom.createElement_(doc, goog.dom.TagName.TD);
                    // IE <= 9 will create a text node if we set text content to the empty
                    // string, so we avoid doing it unless necessary. This ensures that the
                    // same DOM tree is returned on all browsers.
                    if (fillWithNbsp) {
                        goog.dom.setTextContent(td, goog.string.Unicode.NBSP);
                    }
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            }
            return table;
        }
        dom.createTable_ = createTable_;
        ;
        /**
         * Creates a new Node from constant strings of HTML markup.
         * @param {...!goog.string.Const} var_args The HTML strings to concatenate then
         *     convert into a node.
         * @return {!Node}
         */
        function constHtmlToNode(var_args) {
            var stringArray = goog.array.map(arguments, goog.string.Const.unwrap);
            var safeHtml = goog.html.uncheckedconversions
                .safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from('Constant HTML string, that gets turned into a ' +
                'Node later, so it will be automatically balanced.'), stringArray.join(''));
            return goog.dom.safeHtmlToNode(safeHtml);
        }
        dom.constHtmlToNode = constHtmlToNode;
        ;
        /**
         * Converts HTML markup into a node. This is a safe version of
         * {@code goog.dom.htmlToDocumentFragment} which is now deleted.
         * @param {!goog.html.SafeHtml} html The HTML markup to convert.
         * @return {!Node} The resulting node.
         */
        function safeHtmlToNode(html) {
            return goog.dom.safeHtmlToNode_(document, html);
        }
        dom.safeHtmlToNode = safeHtmlToNode;
        ;
        /**
         * Helper for {@code safeHtmlToNode}.
         * @param {!Document} doc The document.
         * @param {!goog.html.SafeHtml} html The HTML markup to convert.
         * @return {!Node} The resulting node.
         * @private
         */
        function safeHtmlToNode_(doc, html) {
            var tempDiv = goog.dom.createElement_(doc, goog.dom.TagName.DIV);
            if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {
                goog.dom.safe.setInnerHtml(tempDiv, goog.html.SafeHtml.concat(goog.html.SafeHtml.BR, html));
                tempDiv.removeChild(tempDiv.firstChild);
            }
            else {
                goog.dom.safe.setInnerHtml(tempDiv, html);
            }
            return goog.dom.childrenToNode_(doc, tempDiv);
        }
        dom.safeHtmlToNode_ = safeHtmlToNode_;
        ;
        /**
         * Helper for {@code safeHtmlToNode_}.
         * @param {!Document} doc The document.
         * @param {!Node} tempDiv The input node.
         * @return {!Node} The resulting node.
         * @private
         */
        function childrenToNode_(doc, tempDiv) {
            if (tempDiv.childNodes.length == 1) {
                return tempDiv.removeChild(tempDiv.firstChild);
            }
            else {
                var fragment = doc.createDocumentFragment();
                while (tempDiv.firstChild) {
                    fragment.appendChild(tempDiv.firstChild);
                }
                return fragment;
            }
        }
        dom.childrenToNode_ = childrenToNode_;
        ;
        /**
         * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
         * mode, false otherwise.
         * @return {boolean} True if in CSS1-compatible mode.
         */
        function isCss1CompatMode() {
            return goog.dom.isCss1CompatMode_(document);
        }
        dom.isCss1CompatMode = isCss1CompatMode;
        ;
        /**
         * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
         * mode, false otherwise.
         * @param {!Document} doc The document to check.
         * @return {boolean} True if in CSS1-compatible mode.
         * @private
         */
        function isCss1CompatMode_(doc) {
            if (goog.dom.COMPAT_MODE_KNOWN_) {
                return goog.dom.ASSUME_STANDARDS_MODE;
            }
            return doc.compatMode == 'CSS1Compat';
        }
        dom.isCss1CompatMode_ = isCss1CompatMode_;
        ;
        /**
         * Determines if the given node can contain children, intended to be used for
         * HTML generation.
         *
         * IE natively supports node.canHaveChildren but has inconsistent behavior.
         * Prior to IE8 the base tag allows children and in IE9 all nodes return true
         * for canHaveChildren.
         *
         * In practice all non-IE browsers allow you to add children to any node, but
         * the behavior is inconsistent:
         *
         * <pre>
         *   var a = goog.dom.createElement(goog.dom.TagName.BR);
         *   a.appendChild(document.createTextNode('foo'));
         *   a.appendChild(document.createTextNode('bar'));
         *   console.log(a.childNodes.length);  // 2
         *   console.log(a.innerHTML);  // Chrome: "", IE9: "foobar", FF3.5: "foobar"
         * </pre>
         *
         * For more information, see:
         * http://dev.w3.org/html5/markup/syntax.html#syntax-elements
         *
         * TODO(user): Rename shouldAllowChildren() ?
         *
         * @param {Node} node The node to check.
         * @return {boolean} Whether the node can contain children.
         */
        function canHaveChildren(node) {
            if (node.nodeType != goog.dom.NodeType.ELEMENT) {
                return false;
            }
            switch (node.tagName) {
                case String(goog.dom.TagName.APPLET):
                case String(goog.dom.TagName.AREA):
                case String(goog.dom.TagName.BASE):
                case String(goog.dom.TagName.BR):
                case String(goog.dom.TagName.COL):
                case String(goog.dom.TagName.COMMAND):
                case String(goog.dom.TagName.EMBED):
                case String(goog.dom.TagName.FRAME):
                case String(goog.dom.TagName.HR):
                case String(goog.dom.TagName.IMG):
                case String(goog.dom.TagName.INPUT):
                case String(goog.dom.TagName.IFRAME):
                case String(goog.dom.TagName.ISINDEX):
                case String(goog.dom.TagName.KEYGEN):
                case String(goog.dom.TagName.LINK):
                case String(goog.dom.TagName.NOFRAMES):
                case String(goog.dom.TagName.NOSCRIPT):
                case String(goog.dom.TagName.META):
                case String(goog.dom.TagName.OBJECT):
                case String(goog.dom.TagName.PARAM):
                case String(goog.dom.TagName.SCRIPT):
                case String(goog.dom.TagName.SOURCE):
                case String(goog.dom.TagName.STYLE):
                case String(goog.dom.TagName.TRACK):
                case String(goog.dom.TagName.WBR):
                    return false;
            }
            return true;
        }
        dom.canHaveChildren = canHaveChildren;
        ;
        /**
         * Appends a child to a node.
         * @param {Node} parent Parent.
         * @param {Node} child Child.
         */
        function appendChild(parent, child) {
            parent.appendChild(child);
        }
        dom.appendChild = appendChild;
        ;
        /**
         * Appends a node with text or other nodes.
         * @param {!Node} parent The node to append nodes to.
         * @param {...goog.dom.Appendable} var_args The things to append to the node.
         *     If this is a Node it is appended as is.
         *     If this is a string then a text node is appended.
         *     If this is an array like object then fields 0 to length - 1 are appended.
         */
        function append(parent, var_args) {
            goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);
        }
        dom.append = append;
        ;
        /**
         * Removes all the child nodes on a DOM node.
         * @param {Node} node Node to remove children from.
         */
        function removeChildren(node) {
            // Note: Iterations over live collections can be slow, this is the fastest
            // we could find. The double parenthesis are used to prevent JsCompiler and
            // strict warnings.
            var child;
            while ((child = node.firstChild)) {
                node.removeChild(child);
            }
        }
        dom.removeChildren = removeChildren;
        ;
        /**
         * Inserts a new node before an existing reference node (i.e. as the previous
         * sibling). If the reference node has no parent, then does nothing.
         * @param {Node} newNode Node to insert.
         * @param {Node} refNode Reference node to insert before.
         */
        function insertSiblingBefore(newNode, refNode) {
            if (refNode.parentNode) {
                refNode.parentNode.insertBefore(newNode, refNode);
            }
        }
        dom.insertSiblingBefore = insertSiblingBefore;
        ;
        /**
         * Inserts a new node after an existing reference node (i.e. as the next
         * sibling). If the reference node has no parent, then does nothing.
         * @param {Node} newNode Node to insert.
         * @param {Node} refNode Reference node to insert after.
         */
        function insertSiblingAfter(newNode, refNode) {
            if (refNode.parentNode) {
                refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
            }
        }
        dom.insertSiblingAfter = insertSiblingAfter;
        ;
        /**
         * Insert a child at a given index. If index is larger than the number of child
         * nodes that the parent currently has, the node is inserted as the last child
         * node.
         * @param {Element} parent The element into which to insert the child.
         * @param {Node} child The element to insert.
         * @param {number} index The index at which to insert the new child node. Must
         *     not be negative.
         */
        function insertChildAt(parent, child, index) {
            // Note that if the second argument is null, insertBefore
            // will append the child at the end of the list of children.
            parent.insertBefore(child, parent.childNodes[index] || null);
        }
        dom.insertChildAt = insertChildAt;
        ;
        /**
         * Removes a node from its parent.
         * @param {Node} node The node to remove.
         * @return {Node} The node removed if removed; else, null.
         */
        function removeNode(node) {
            return node && node.parentNode ? node.parentNode.removeChild(node) : null;
        }
        dom.removeNode = removeNode;
        ;
        /**
         * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
         * parent.
         * @param {Node} newNode Node to insert.
         * @param {Node} oldNode Node to replace.
         */
        function replaceNode(newNode, oldNode) {
            var parent = oldNode.parentNode;
            if (parent) {
                parent.replaceChild(newNode, oldNode);
            }
        }
        dom.replaceNode = replaceNode;
        ;
        /**
         * Flattens an element. That is, removes it and replace it with its children.
         * Does nothing if the element is not in the document.
         * @param {Element} element The element to flatten.
         * @return {Element|undefined} The original element, detached from the document
         *     tree, sans children; or undefined, if the element was not in the document
         *     to begin with.
         */
        function flattenElement(element) {
            var child, parent = element.parentNode;
            if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {
                // Use IE DOM method (supported by Opera too) if available
                if (element.removeNode) {
                    return /** @type {Element} */ (element.removeNode(false));
                }
                else {
                    // Move all children of the original node up one level.
                    while ((child = element.firstChild)) {
                        parent.insertBefore(child, element);
                    }
                    // Detach the original element.
                    return /** @type {Element} */ (goog.dom.removeNode(element));
                }
            }
        }
        dom.flattenElement = flattenElement;
        ;
        /**
         * Returns an array containing just the element children of the given element.
         * @param {Element} element The element whose element children we want.
         * @return {!(Array<!Element>|NodeList<!Element>)} An array or array-like list
         *     of just the element children of the given element.
         */
        function getChildren(element) {
            // We check if the children attribute is supported for child elements
            // since IE8 misuses the attribute by also including comments.
            if (goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE &&
                element.children != undefined) {
                return element.children;
            }
            // Fall back to manually filtering the element's child nodes.
            return goog.array.filter(element.childNodes, function (node) {
                return node.nodeType == goog.dom.NodeType.ELEMENT;
            });
        }
        dom.getChildren = getChildren;
        ;
        /**
         * Returns the first child node that is an element.
         * @param {Node} node The node to get the first child element of.
         * @return {Element} The first child node of {@code node} that is an element.
         */
        function getFirstElementChild(node) {
            if (goog.isDef(node.firstElementChild)) {
                return /** @type {!Element} */ node.firstElementChild;
            }
            return goog.dom.getNextElementNode_(node.firstChild, true);
        }
        dom.getFirstElementChild = getFirstElementChild;
        ;
        /**
         * Returns the last child node that is an element.
         * @param {Node} node The node to get the last child element of.
         * @return {Element} The last child node of {@code node} that is an element.
         */
        function getLastElementChild(node) {
            if (goog.isDef(node.lastElementChild)) {
                return /** @type {!Element} */ node.lastElementChild;
            }
            return goog.dom.getNextElementNode_(node.lastChild, false);
        }
        dom.getLastElementChild = getLastElementChild;
        ;
        /**
         * Returns the first next sibling that is an element.
         * @param {Node} node The node to get the next sibling element of.
         * @return {Element} The next sibling of {@code node} that is an element.
         */
        function getNextElementSibling(node) {
            if (goog.isDef(node.nextElementSibling)) {
                return /** @type {!Element} */ node.nextElementSibling;
            }
            return goog.dom.getNextElementNode_(node.nextSibling, true);
        }
        dom.getNextElementSibling = getNextElementSibling;
        ;
        /**
         * Returns the first previous sibling that is an element.
         * @param {Node} node The node to get the previous sibling element of.
         * @return {Element} The first previous sibling of {@code node} that is
         *     an element.
         */
        function getPreviousElementSibling(node) {
            if (goog.isDef(node.previousElementSibling)) {
                return /** @type {!Element} */ node.previousElementSibling;
            }
            return goog.dom.getNextElementNode_(node.previousSibling, false);
        }
        dom.getPreviousElementSibling = getPreviousElementSibling;
        ;
        /**
         * Returns the first node that is an element in the specified direction,
         * starting with {@code node}.
         * @param {Node} node The node to get the next element from.
         * @param {boolean} forward Whether to look forwards or backwards.
         * @return {Element} The first element.
         * @private
         */
        function getNextElementNode_(node, forward) {
            while (node && node.nodeType != goog.dom.NodeType.ELEMENT) {
                node = forward ? node.nextSibling : node.previousSibling;
            }
            return /** @type {Element} */ node;
        }
        dom.getNextElementNode_ = getNextElementNode_;
        ;
        /**
         * Returns the next node in source order from the given node.
         * @param {Node} node The node.
         * @return {Node} The next node in the DOM tree, or null if this was the last
         *     node.
         */
        function getNextNode(node) {
            if (!node) {
                return null;
            }
            if (node.firstChild) {
                return node.firstChild;
            }
            while (node && !node.nextSibling) {
                node = node.parentNode;
            }
            return node ? node.nextSibling : null;
        }
        dom.getNextNode = getNextNode;
        ;
        /**
         * Returns the previous node in source order from the given node.
         * @param {Node} node The node.
         * @return {Node} The previous node in the DOM tree, or null if this was the
         *     first node.
         */
        function getPreviousNode(node) {
            if (!node) {
                return null;
            }
            if (!node.previousSibling) {
                return node.parentNode;
            }
            node = node.previousSibling;
            while (node && node.lastChild) {
                node = node.lastChild;
            }
            return node;
        }
        dom.getPreviousNode = getPreviousNode;
        ;
        /**
         * Whether the object looks like a DOM node.
         * @param {?} obj The object being tested for node likeness.
         * @return {boolean} Whether the object looks like a DOM node.
         */
        function isNodeLike(obj) {
            return goog.isObject(obj) && obj.nodeType > 0;
        }
        dom.isNodeLike = isNodeLike;
        ;
        /**
         * Whether the object looks like an Element.
         * @param {?} obj The object being tested for Element likeness.
         * @return {boolean} Whether the object looks like an Element.
         */
        function isElement(obj) {
            return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT;
        }
        dom.isElement = isElement;
        ;
        /**
         * Returns true if the specified value is a Window object. This includes the
         * global window for HTML pages, and iframe windows.
         * @param {?} obj Variable to test.
         * @return {boolean} Whether the variable is a window.
         */
        function isWindow(obj) {
            return goog.isObject(obj) && obj['window'] == obj;
        }
        dom.isWindow = isWindow;
        ;
        /**
         * Returns an element's parent, if it's an Element.
         * @param {Element} element The DOM element.
         * @return {Element} The parent, or null if not an Element.
         */
        function getParentElement(element) {
            var parent;
            if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {
                var isIe9 = goog.userAgent.IE && goog.userAgent.isVersionOrHigher('9') &&
                    !goog.userAgent.isVersionOrHigher('10');
                // SVG elements in IE9 can't use the parentElement property.
                // goog.global['SVGElement'] is not defined in IE9 quirks mode.
                if (!(isIe9 && goog.global['SVGElement'] &&
                    element instanceof goog.global['SVGElement'])) {
                    parent = element.parentElement;
                    if (parent) {
                        return parent;
                    }
                }
            }
            parent = element.parentNode;
            return goog.dom.isElement(parent) ? /** @type {!Element} */ (parent) : null;
        }
        dom.getParentElement = getParentElement;
        ;
        /**
         * Whether a node contains another node.
         * @param {?Node|undefined} parent The node that should contain the other node.
         * @param {?Node|undefined} descendant The node to test presence of.
         * @return {boolean} Whether the parent node contains the descendent node.
         */
        function contains(parent, descendant) {
            if (!parent || !descendant) {
                return false;
            }
            // We use browser specific methods for this if available since it is faster
            // that way.
            // IE DOM
            if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {
                return parent == descendant || parent.contains(descendant);
            }
            // W3C DOM Level 3
            if (typeof parent.compareDocumentPosition != 'undefined') {
                return parent == descendant ||
                    Boolean(parent.compareDocumentPosition(descendant) & 16);
            }
            // W3C DOM Level 1
            while (descendant && parent != descendant) {
                descendant = descendant.parentNode;
            }
            return descendant == parent;
        }
        dom.contains = contains;
        ;
        /**
         * Compares the document order of two nodes, returning 0 if they are the same
         * node, a negative number if node1 is before node2, and a positive number if
         * node2 is before node1.  Note that we compare the order the tags appear in the
         * document so in the tree <b><i>text</i></b> the B node is considered to be
         * before the I node.
         *
         * @param {Node} node1 The first node to compare.
         * @param {Node} node2 The second node to compare.
         * @return {number} 0 if the nodes are the same node, a negative number if node1
         *     is before node2, and a positive number if node2 is before node1.
         */
        function compareNodeOrder(node1, node2) {
            // Fall out quickly for equality.
            if (node1 == node2) {
                return 0;
            }
            // Use compareDocumentPosition where available
            if (node1.compareDocumentPosition) {
                // 4 is the bitmask for FOLLOWS.
                return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;
            }
            // Special case for document nodes on IE 7 and 8.
            if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
                if (node1.nodeType == goog.dom.NodeType.DOCUMENT) {
                    return -1;
                }
                if (node2.nodeType == goog.dom.NodeType.DOCUMENT) {
                    return 1;
                }
            }
            // Process in IE using sourceIndex - we check to see if the first node has
            // a source index or if its parent has one.
            if ('sourceIndex' in node1 ||
                (node1.parentNode && 'sourceIndex' in node1.parentNode)) {
                var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;
                var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;
                if (isElement1 && isElement2) {
                    return node1.sourceIndex - node2.sourceIndex;
                }
                else {
                    var parent1 = node1.parentNode;
                    var parent2 = node2.parentNode;
                    if (parent1 == parent2) {
                        return goog.dom.compareSiblingOrder_(node1, node2);
                    }
                    if (!isElement1 && goog.dom.contains(parent1, node2)) {
                        return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);
                    }
                    if (!isElement2 && goog.dom.contains(parent2, node1)) {
                        return goog.dom.compareParentsDescendantNodeIe_(node2, node1);
                    }
                    return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) -
                        (isElement2 ? node2.sourceIndex : parent2.sourceIndex);
                }
            }
            // For Safari, we compare ranges.
            var doc = goog.dom.getOwnerDocument(node1);
            var range1, range2;
            range1 = doc.createRange();
            range1.selectNode(node1);
            range1.collapse(true);
            range2 = doc.createRange();
            range2.selectNode(node2);
            range2.collapse(true);
            return range1.compareBoundaryPoints(goog.global['Range'].START_TO_END, range2);
        }
        dom.compareNodeOrder = compareNodeOrder;
        ;
        /**
         * Utility function to compare the position of two nodes, when
         * {@code textNode}'s parent is an ancestor of {@code node}.  If this entry
         * condition is not met, this function will attempt to reference a null object.
         * @param {!Node} textNode The textNode to compare.
         * @param {Node} node The node to compare.
         * @return {number} -1 if node is before textNode, +1 otherwise.
         * @private
         */
        function compareParentsDescendantNodeIe_(textNode, node) {
            var parent = textNode.parentNode;
            if (parent == node) {
                // If textNode is a child of node, then node comes first.
                return -1;
            }
            var sibling = node;
            while (sibling.parentNode != parent) {
                sibling = sibling.parentNode;
            }
            return goog.dom.compareSiblingOrder_(sibling, textNode);
        }
        dom.compareParentsDescendantNodeIe_ = compareParentsDescendantNodeIe_;
        ;
        /**
         * Utility function to compare the position of two nodes known to be non-equal
         * siblings.
         * @param {Node} node1 The first node to compare.
         * @param {!Node} node2 The second node to compare.
         * @return {number} -1 if node1 is before node2, +1 otherwise.
         * @private
         */
        function compareSiblingOrder_(node1, node2) {
            var s = node2;
            while ((s = s.previousSibling)) {
                if (s == node1) {
                    // We just found node1 before node2.
                    return -1;
                }
            }
            // Since we didn't find it, node1 must be after node2.
            return 1;
        }
        dom.compareSiblingOrder_ = compareSiblingOrder_;
        ;
        /**
         * Find the deepest common ancestor of the given nodes.
         * @param {...Node} var_args The nodes to find a common ancestor of.
         * @return {Node} The common ancestor of the nodes, or null if there is none.
         *     null will only be returned if two or more of the nodes are from different
         *     documents.
         */
        function findCommonAncestor(var_args) {
            var i, count = arguments.length;
            if (!count) {
                return null;
            }
            else if (count == 1) {
                return arguments[0];
            }
            var paths = [];
            var minLength = Infinity;
            for (i = 0; i < count; i++) {
                // Compute the list of ancestors.
                var ancestors = [];
                var node = arguments[i];
                while (node) {
                    ancestors.unshift(node);
                    node = node.parentNode;
                }
                // Save the list for comparison.
                paths.push(ancestors);
                minLength = Math.min(minLength, ancestors.length);
            }
            var output = null;
            for (i = 0; i < minLength; i++) {
                var first = paths[0][i];
                for (var j = 1; j < count; j++) {
                    if (first != paths[j][i]) {
                        return output;
                    }
                }
                output = first;
            }
            return output;
        }
        dom.findCommonAncestor = findCommonAncestor;
        ;
        /**
         * Returns the owner document for a node.
         * @param {Node|Window} node The node to get the document for.
         * @return {!Document} The document owning the node.
         */
        function getOwnerDocument(node) {
            // TODO(nnaze): Update param signature to be non-nullable.
            goog.asserts.assert(node, 'Node cannot be null or undefined.');
            return /** @type {!Document} */ (node.nodeType == goog.dom.NodeType.DOCUMENT ? node : node.ownerDocument ||
                node.document);
        }
        dom.getOwnerDocument = getOwnerDocument;
        ;
        /**
         * Cross-browser function for getting the document element of a frame or iframe.
         * @param {Element} frame Frame element.
         * @return {!Document} The frame content document.
         */
        function getFrameContentDocument(frame) {
            return frame.contentDocument ||
                /** @type {!HTMLFrameElement} */ (frame).contentWindow.document;
        }
        dom.getFrameContentDocument = getFrameContentDocument;
        ;
        /**
         * Cross-browser function for getting the window of a frame or iframe.
         * @param {Element} frame Frame element.
         * @return {Window} The window associated with the given frame, or null if none
         *     exists.
         */
        function getFrameContentWindow(frame) {
            try {
                return frame.contentWindow ||
                    (frame.contentDocument ? goog.dom.getWindow(frame.contentDocument) :
                        null);
            }
            catch (e) {
                // NOTE(user): In IE8, checking the contentWindow or contentDocument
                // properties will throw a "Unspecified Error" exception if the iframe is
                // not inserted in the DOM. If we get this we can be sure that no window
                // exists, so return null.
            }
            return null;
        }
        dom.getFrameContentWindow = getFrameContentWindow;
        ;
        /**
         * Sets the text content of a node, with cross-browser support.
         * @param {Node} node The node to change the text content of.
         * @param {string|number} text The value that should replace the node's content.
         */
        function setTextContent(node, text) {
            goog.asserts.assert(node != null, 'goog.dom.setTextContent expects a non-null value for node');
            if ('textContent' in node) {
                node.textContent = text;
            }
            else if (node.nodeType == goog.dom.NodeType.TEXT) {
                /** @type {!Text} */ node.data = String(text);
            }
            else if (node.firstChild && node.firstChild.nodeType == goog.dom.NodeType.TEXT) {
                // If the first child is a text node we just change its data and remove the
                // rest of the children.
                while (node.lastChild != node.firstChild) {
                    node.removeChild(node.lastChild);
                }
                /** @type {!Text} */ (node.firstChild).data = String(text);
            }
            else {
                goog.dom.removeChildren(node);
                var doc = goog.dom.getOwnerDocument(node);
                node.appendChild(doc.createTextNode(String(text)));
            }
        }
        dom.setTextContent = setTextContent;
        ;
        /**
         * Gets the outerHTML of a node, which islike innerHTML, except that it
         * actually contains the HTML of the node itself.
         * @param {Element} element The element to get the HTML of.
         * @return {string} The outerHTML of the given element.
         */
        function getOuterHtml(element) {
            goog.asserts.assert(element !== null, 'goog.dom.getOuterHtml expects a non-null value for element');
            // IE, Opera and WebKit all have outerHTML.
            if ('outerHTML' in element) {
                return element.outerHTML;
            }
            else {
                var doc = goog.dom.getOwnerDocument(element);
                var div = goog.dom.createElement_(doc, goog.dom.TagName.DIV);
                div.appendChild(element.cloneNode(true));
                return div.innerHTML;
            }
        }
        dom.getOuterHtml = getOuterHtml;
        ;
        /**
         * Finds the first descendant node that matches the filter function, using
         * a depth first search. This function offers the most general purpose way
         * of finding a matching element. You may also wish to consider
         * {@code goog.dom.query} which can express many matching criteria using
         * CSS selector expressions. These expressions often result in a more
         * compact representation of the desired result.
         * @see goog.dom.query
         *
         * @param {Node} root The root of the tree to search.
         * @param {function(Node) : boolean} p The filter function.
         * @return {Node|undefined} The found node or undefined if none is found.
         */
        function findNode(root, p) {
            var rv = [];
            var found = goog.dom.findNodes_(root, p, rv, true);
            return found ? rv[0] : undefined;
        }
        dom.findNode = findNode;
        ;
        /**
         * Finds all the descendant nodes that match the filter function, using a
         * a depth first search. This function offers the most general-purpose way
         * of finding a set of matching elements. You may also wish to consider
         * {@code goog.dom.query} which can express many matching criteria using
         * CSS selector expressions. These expressions often result in a more
         * compact representation of the desired result.
    
        * @param {Node} root The root of the tree to search.
        * @param {function(Node) : boolean} p The filter function.
        * @return {!Array<!Node>} The found nodes or an empty array if none are found.
        */
        function findNodes(root, p) {
            var rv = [];
            goog.dom.findNodes_(root, p, rv, false);
            return rv;
        }
        dom.findNodes = findNodes;
        ;
        /**
         * Finds the first or all the descendant nodes that match the filter function,
         * using a depth first search.
         * @param {Node} root The root of the tree to search.
         * @param {function(Node) : boolean} p The filter function.
         * @param {!Array<!Node>} rv The found nodes are added to this array.
         * @param {boolean} findOne If true we exit after the first found node.
         * @return {boolean} Whether the search is complete or not. True in case findOne
         *     is true and the node is found. False otherwise.
         * @private
         */
        function findNodes_(root, p, rv, findOne) {
            if (root != null) {
                var child = root.firstChild;
                while (child) {
                    if (p(child)) {
                        rv.push(child);
                        if (findOne) {
                            return true;
                        }
                    }
                    if (goog.dom.findNodes_(child, p, rv, findOne)) {
                        return true;
                    }
                    child = child.nextSibling;
                }
            }
            return false;
        }
        dom.findNodes_ = findNodes_;
        ;
        /**
         * Map of tags whose content to ignore when calculating text length.
         * @private {!Object<string, number>}
         * @const
         */
        dom.TAGS_TO_IGNORE_ = {
            'SCRIPT': 1,
            'STYLE': 1,
            'HEAD': 1,
            'IFRAME': 1,
            'OBJECT': 1
        };
        /**
         * Map of tags which have predefined values with regard to whitespace.
         * @private {!Object<string, string>}
         * @const
         */
        dom.PREDEFINED_TAG_VALUES_ = {
            'IMG': ' ',
            'BR': '\n'
        };
        /**
         * Returns true if the element has a tab index that allows it to receive
         * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements
         * natively support keyboard focus, even if they have no tab index.
         * @param {!Element} element Element to check.
         * @return {boolean} Whether the element has a tab index that allows keyboard
         *     focus.
         */
        function isFocusableTabIndex(element) {
            return goog.dom.hasSpecifiedTabIndex_(element) &&
                goog.dom.isTabIndexFocusable_(element);
        }
        dom.isFocusableTabIndex = isFocusableTabIndex;
        ;
        /**
         * Enables or disables keyboard focus support on the element via its tab index.
         * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
         * (or elements that natively support keyboard focus, like form elements) can
         * receive keyboard focus.  See http://go/tabindex for more info.
         * @param {Element} element Element whose tab index is to be changed.
         * @param {boolean} enable Whether to set or remove a tab index on the element
         *     that supports keyboard focus.
         */
        function setFocusableTabIndex(element, enable) {
            if (enable) {
                element.tabIndex = 0;
            }
            else {
                // Set tabIndex to -1 first, then remove it. This is a workaround for
                // Safari (confirmed in version 4 on Windows). When removing the attribute
                // without setting it to -1 first, the element remains keyboard focusable
                // despite not having a tabIndex attribute anymore.
                element.tabIndex = -1;
                element.removeAttribute('tabIndex');
            }
        }
        dom.setFocusableTabIndex = setFocusableTabIndex;
        ;
        /**
         * Returns true if the element can be focused, i.e. it has a tab index that
         * allows it to receive keyboard focus (tabIndex >= 0), or it is an element
         * that natively supports keyboard focus.
         * @param {!Element} element Element to check.
         * @return {boolean} Whether the element allows keyboard focus.
         */
        function isFocusable(element) {
            var focusable;
            // Some elements can have unspecified tab index and still receive focus.
            if (goog.dom.nativelySupportsFocus_(element)) {
                // Make sure the element is not disabled ...
                focusable = !element.disabled &&
                    // ... and if a tab index is specified, it allows focus.
                    (!goog.dom.hasSpecifiedTabIndex_(element) ||
                        goog.dom.isTabIndexFocusable_(element));
            }
            else {
                focusable = goog.dom.isFocusableTabIndex(element);
            }
            // IE requires elements to be visible in order to focus them.
            return focusable && goog.userAgent.IE ?
                goog.dom.hasNonZeroBoundingRect_(/** @type {!HTMLElement} */ element) :
                focusable;
        }
        dom.isFocusable = isFocusable;
        ;
        /**
         * Returns true if the element has a specified tab index.
         * @param {!Element} element Element to check.
         * @return {boolean} Whether the element has a specified tab index.
         * @private
         */
        function hasSpecifiedTabIndex_(element) {
            // IE8 and below don't support hasAttribute(), instead check whether the
            // 'tabindex' attributeNode is specified. Otherwise check hasAttribute().
            if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9')) {
                var attrNode = element.getAttributeNode('tabindex'); // Must be lowercase!
                return goog.isDefAndNotNull(attrNode) && attrNode.specified;
            }
            else {
                return element.hasAttribute('tabindex');
            }
        }
        dom.hasSpecifiedTabIndex_ = hasSpecifiedTabIndex_;
        ;
        /**
         * Returns true if the element's tab index allows the element to be focused.
         * @param {!Element} element Element to check.
         * @return {boolean} Whether the element's tab index allows focus.
         * @private
         */
        function isTabIndexFocusable_(element) {
            var index = element.tabIndex;
            // NOTE: IE9 puts tabIndex in 16-bit int, e.g. -2 is 65534.
            return goog.isNumber(index) && index >= 0 && index < 32768;
        }
        dom.isTabIndexFocusable_ = isTabIndexFocusable_;
        ;
        /**
         * Returns true if the element is focusable even when tabIndex is not set.
         * @param {!Element} element Element to check.
         * @return {boolean} Whether the element natively supports focus.
         * @private
         */
        function nativelySupportsFocus_(element) {
            return element.tagName == goog.dom.TagName.A ||
                element.tagName == goog.dom.TagName.INPUT ||
                element.tagName == goog.dom.TagName.TEXTAREA ||
                element.tagName == goog.dom.TagName.SELECT ||
                element.tagName == goog.dom.TagName.BUTTON;
        }
        dom.nativelySupportsFocus_ = nativelySupportsFocus_;
        ;
        /**
         * Returns true if the element has a bounding rectangle that would be visible
         * (i.e. its width and height are greater than zero).
         * @param {!HTMLElement} element Element to check.
         * @return {boolean} Whether the element has a non-zero bounding rectangle.
         * @private
         */
        function hasNonZeroBoundingRect_(element) {
            var rect;
            if (!goog.isFunction(element['getBoundingClientRect']) ||
                // In IE, getBoundingClientRect throws on detached nodes.
                (goog.userAgent.IE && element.parentElement == null)) {
                rect = { 'height': element.offsetHeight, 'width': element.offsetWidth };
            }
            else {
                rect = element.getBoundingClientRect();
            }
            return goog.isDefAndNotNull(rect) && rect.height > 0 && rect.width > 0;
        }
        dom.hasNonZeroBoundingRect_ = hasNonZeroBoundingRect_;
        ;
        /**
         * Returns the text content of the current node, without markup and invisible
         * symbols. New lines are stripped and whitespace is collapsed,
         * such that each character would be visible.
         *
         * In browsers that support it, innerText is used.  Other browsers attempt to
         * simulate it via node traversal.  Line breaks are canonicalized in IE.
         *
         * @param {Node} node The node from which we are getting content.
         * @return {string} The text content.
         */
        function getTextContent(node) {
            var textContent;
            // Note(arv): IE9, Opera, and Safari 3 support innerText but they include
            // text nodes in script tags. So we revert to use a user agent test here.
            if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && node !== null &&
                ('innerText' in node)) {
                textContent = goog.string.canonicalizeNewlines(node.innerText);
                // Unfortunately .innerText() returns text with &shy; symbols
                // We need to filter it out and then remove duplicate whitespaces
            }
            else {
                var buf = [];
                goog.dom.getTextContent_(node, buf, true);
                textContent = buf.join('');
            }
            // Strip &shy; entities. goog.format.insertWordBreaks inserts them in Opera.
            textContent = textContent.replace(/ \xAD /g, ' ').replace(/\xAD/g, '');
            // Strip &#8203; entities. goog.format.insertWordBreaks inserts them in IE8.
            textContent = textContent.replace(/\u200B/g, '');
            // Skip this replacement on old browsers with working innerText, which
            // automatically turns &nbsp; into ' ' and / +/ into ' ' when reading
            // innerText.
            if (!goog.dom.BrowserFeature.CAN_USE_INNER_TEXT) {
                textContent = textContent.replace(/ +/g, ' ');
            }
            if (textContent != ' ') {
                textContent = textContent.replace(/^\s*/, '');
            }
            return textContent;
        }
        dom.getTextContent = getTextContent;
        ;
        /**
         * Returns the text content of the current node, without markup.
         *
         * Unlike {@code getTextContent} this method does not collapse whitespaces
         * or normalize lines breaks.
         *
         * @param {Node} node The node from which we are getting content.
         * @return {string} The raw text content.
         */
        function getRawTextContent(node) {
            var buf = [];
            goog.dom.getTextContent_(node, buf, false);
            return buf.join('');
        }
        dom.getRawTextContent = getRawTextContent;
        ;
        /**
         * Recursive support function for text content retrieval.
         *
         * @param {Node} node The node from which we are getting content.
         * @param {Array<string>} buf string buffer.
         * @param {boolean} normalizeWhitespace Whether to normalize whitespace.
         * @private
         */
        function getTextContent_(node, buf, normalizeWhitespace) {
            if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {
                // ignore certain tags
            }
            else if (node.nodeType == goog.dom.NodeType.TEXT) {
                if (normalizeWhitespace) {
                    buf.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
                }
                else {
                    buf.push(node.nodeValue);
                }
            }
            else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
                buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);
            }
            else {
                var child = node.firstChild;
                while (child) {
                    goog.dom.getTextContent_(child, buf, normalizeWhitespace);
                    child = child.nextSibling;
                }
            }
        }
        dom.getTextContent_ = getTextContent_;
        ;
        /**
         * Returns the text length of the text contained in a node, without markup. This
         * is equivalent to the selection length if the node was selected, or the number
         * of cursor movements to traverse the node. Images & BRs take one space.  New
         * lines are ignored.
         *
         * @param {Node} node The node whose text content length is being calculated.
         * @return {number} The length of {@code node}'s text content.
         */
        function getNodeTextLength(node) {
            return goog.dom.getTextContent(node).length;
        }
        dom.getNodeTextLength = getNodeTextLength;
        ;
        /**
         * Returns the text offset of a node relative to one of its ancestors. The text
         * length is the same as the length calculated by goog.dom.getNodeTextLength.
         *
         * @param {Node} node The node whose offset is being calculated.
         * @param {Node=} opt_offsetParent The node relative to which the offset will
         *     be calculated. Defaults to the node's owner document's body.
         * @return {number} The text offset.
         */
        function getNodeTextOffset(node, opt_offsetParent) {
            var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;
            var buf = [];
            while (node && node != root) {
                var cur = node;
                while ((cur = cur.previousSibling)) {
                    buf.unshift(goog.dom.getTextContent(cur));
                }
                node = node.parentNode;
            }
            // Trim left to deal with FF cases when there might be line breaks and empty
            // nodes at the front of the text
            return goog.string.trimLeft(buf.join('')).replace(/ +/g, ' ').length;
        }
        dom.getNodeTextOffset = getNodeTextOffset;
        ;
        /**
         * Returns the node at a given offset in a parent node.  If an object is
         * provided for the optional third parameter, the node and the remainder of the
         * offset will stored as properties of this object.
         * @param {Node} parent The parent node.
         * @param {number} offset The offset into the parent node.
         * @param {Object=} opt_result Object to be used to store the return value. The
         *     return value will be stored in the form {node: Node, remainder: number}
         *     if this object is provided.
         * @return {Node} The node at the given offset.
         */
        function getNodeAtOffset(parent, offset, opt_result) {
            var stack = [parent], pos = 0, cur = null;
            while (stack.length > 0 && pos < offset) {
                cur = stack.pop();
                if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_) {
                    // ignore certain tags
                }
                else if (cur.nodeType == goog.dom.NodeType.TEXT) {
                    var text = cur.nodeValue.replace(/(\r\n|\r|\n)/g, '').replace(/ +/g, ' ');
                    pos += text.length;
                }
                else if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
                    pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;
                }
                else {
                    for (var i = cur.childNodes.length - 1; i >= 0; i--) {
                        stack.push(cur.childNodes[i]);
                    }
                }
            }
            if (goog.isObject(opt_result)) {
                opt_result.remainder = cur ? cur.nodeValue.length + offset - pos - 1 : 0;
                opt_result.node = cur;
            }
            return cur;
        }
        dom.getNodeAtOffset = getNodeAtOffset;
        ;
        /**
         * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
         * the object must have a numeric length property and an item function (which
         * has type 'string' on IE for some reason).
         * @param {Object} val Object to test.
         * @return {boolean} Whether the object is a NodeList.
         */
        function isNodeList(val) {
            // TODO(attila): Now the isNodeList is part of goog.dom we can use
            // goog.userAgent to make this simpler.
            // A NodeList must have a length property of type 'number' on all platforms.
            if (val && typeof val.length == 'number') {
                // A NodeList is an object everywhere except Safari, where it's a function.
                if (goog.isObject(val)) {
                    // A NodeList must have an item function (on non-IE platforms) or an item
                    // property of type 'string' (on IE).
                    return typeof val.item == 'function' || typeof val.item == 'string';
                }
                else if (goog.isFunction(val)) {
                    // On Safari, a NodeList is a function with an item property that is also
                    // a function.
                    return typeof val.item == 'function';
                }
            }
            // Not a NodeList.
            return false;
        }
        dom.isNodeList = isNodeList;
        ;
        /**
         * Walks up the DOM hierarchy returning the first ancestor that has the passed
         * tag name and/or class name. If the passed element matches the specified
         * criteria, the element itself is returned.
         * @param {Node} element The DOM node to start with.
         * @param {?(goog.dom.TagName<T>|string)=} opt_tag The tag name to match (or
         *     null/undefined to match only based on class name).
         * @param {?string=} opt_class The class name to match (or null/undefined to
         *     match only based on tag name).
         * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
         *     dom.
         * @return {?R} The first ancestor that matches the passed criteria, or
         *     null if no match is found. The return type is {?Element} if opt_tag is
         *     not a member of goog.dom.TagName or a more specific type if it is (e.g.
         *     {?HTMLAnchorElement} for goog.dom.TagName.A).
         * @template T
         * @template R := cond(isUnknown(T), 'Element', T) =:
         */
        function getAncestorByTagNameAndClass(element, opt_tag, opt_class, opt_maxSearchSteps) {
            if (!opt_tag && !opt_class) {
                return null;
            }
            var tagName = opt_tag ? String(opt_tag).toUpperCase() : null;
            return /** @type {Element} */ (goog.dom.getAncestor(element, function (node) {
                return (!tagName || node.nodeName == tagName) &&
                    (!opt_class ||
                        goog.isString(node.className) &&
                            goog.array.contains(node.className.split(/\s+/), opt_class));
            }, true, opt_maxSearchSteps));
        }
        dom.getAncestorByTagNameAndClass = getAncestorByTagNameAndClass;
        ;
        /**
         * Walks up the DOM hierarchy returning the first ancestor that has the passed
         * class name. If the passed element matches the specified criteria, the
         * element itself is returned.
         * @param {Node} element The DOM node to start with.
         * @param {string} className The class name to match.
         * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
         *     dom.
         * @return {Element} The first ancestor that matches the passed criteria, or
         *     null if none match.
         */
        function getAncestorByClass(element, className, opt_maxSearchSteps) {
            return goog.dom.getAncestorByTagNameAndClass(element, null, className, opt_maxSearchSteps);
        }
        dom.getAncestorByClass = getAncestorByClass;
        ;
        /**
         * Walks up the DOM hierarchy returning the first ancestor that passes the
         * matcher function.
         * @param {Node} element The DOM node to start with.
         * @param {function(Node) : boolean} matcher A function that returns true if the
         *     passed node matches the desired criteria.
         * @param {boolean=} opt_includeNode If true, the node itself is included in
         *     the search (the first call to the matcher will pass startElement as
         *     the node to test).
         * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
         *     dom.
         * @return {Node} DOM node that matched the matcher, or null if there was
         *     no match.
         */
        function getAncestor(element, matcher, opt_includeNode, opt_maxSearchSteps) {
            if (element && !opt_includeNode) {
                element = element.parentNode;
            }
            var steps = 0;
            while (element &&
                (opt_maxSearchSteps == null || steps <= opt_maxSearchSteps)) {
                goog.asserts.assert(element.name != 'parentNode');
                if (matcher(element)) {
                    return element;
                }
                element = element.parentNode;
                steps++;
            }
            // Reached the root of the DOM without a match
            return null;
        }
        dom.getAncestor = getAncestor;
        ;
        /**
         * Determines the active element in the given document.
         * @param {Document} doc The document to look in.
         * @return {Element} The active element.
         */
        function getActiveElement(doc) {
            try {
                return doc && doc.activeElement;
            }
            catch (e) {
                // NOTE(nicksantos): Sometimes, evaluating document.activeElement in IE
                // throws an exception. I'm not 100% sure why, but I suspect it chokes
                // on document.activeElement if the activeElement has been recently
                // removed from the DOM by a JS operation.
                //
                // We assume that an exception here simply means
                // "there is no active element."
            }
            return null;
        }
        dom.getActiveElement = getActiveElement;
        ;
        /**
         * Gives the current devicePixelRatio.
         *
         * By default, this is the value of window.devicePixelRatio (which should be
         * preferred if present).
         *
         * If window.devicePixelRatio is not present, the ratio is calculated with
         * window.matchMedia, if present. Otherwise, gives 1.0.
         *
         * Some browsers (including Chrome) consider the browser zoom level in the pixel
         * ratio, so the value may change across multiple calls.
         *
         * @return {number} The number of actual pixels per virtual pixel.
         */
        function getPixelRatio() {
            var win = goog.dom.getWindow();
            if (goog.isDef(win.devicePixelRatio)) {
                return win.devicePixelRatio;
            }
            else if (win.matchMedia) {
                // Should be for IE10 and FF6-17 (this basically clamps to lower)
                // Note that the order of these statements is important
                return goog.dom.matchesPixelRatio_(3) || goog.dom.matchesPixelRatio_(2) ||
                    goog.dom.matchesPixelRatio_(1.5) || goog.dom.matchesPixelRatio_(1) ||
                    .75;
            }
            return 1;
        }
        dom.getPixelRatio = getPixelRatio;
        ;
        /**
         * Calculates a mediaQuery to check if the current device supports the
         * given actual to virtual pixel ratio.
         * @param {number} pixelRatio The ratio of actual pixels to virtual pixels.
         * @return {number} pixelRatio if applicable, otherwise 0.
         * @private
         */
        function matchesPixelRatio_(pixelRatio) {
            var win = goog.dom.getWindow();
            /**
             * Due to the 1:96 fixed ratio of CSS in to CSS px, 1dppx is equivalent to
             * 96dpi.
             * @const {number}
             */
            var dpiPerDppx = 96;
            var query = 
            // FF16-17
            '(min-resolution: ' + pixelRatio + 'dppx),' +
                // FF6-15
                '(min--moz-device-pixel-ratio: ' + pixelRatio + '),' +
                // IE10 (this works for the two browsers above too but I don't want to
                // trust the 1:96 fixed ratio magic)
                '(min-resolution: ' + (pixelRatio * dpiPerDppx) + 'dpi)';
            return win.matchMedia(query).matches ? pixelRatio : 0;
        }
        dom.matchesPixelRatio_ = matchesPixelRatio_;
        ;
        /**
         * Gets '2d' context of a canvas. Shortcut for canvas.getContext('2d') with a
         * type information.
         * @param {!HTMLCanvasElement} canvas
         * @return {!CanvasRenderingContext2D}
         */
        function getCanvasContext2D(canvas) {
            return /** @type {!CanvasRenderingContext2D} */ (canvas.getContext('2d'));
        }
        dom.getCanvasContext2D = getCanvasContext2D;
        ;
        var DomHelper = /** @class */ (function () {
            /**
             * Create an instance of a DOM helper with a new document object.
             * @param {Document=} opt_document Document object to associate with this
             *     DOM helper.
             * @constructor
             */
            function DomHelper(opt_document) {
                /**
                 * Cross browser function for getting the document element of an iframe.
                 * @param {Element} iframe Iframe element.
                 * @return {!Document} The frame content document.
                 */
                this.getFrameContentDocument = goog.dom.getFrameContentDocument;
                /**
                 * Cross browser function for getting the window of a frame or iframe.
                 * @param {Element} frame Frame element.
                 * @return {Window} The window associated with the given frame.
                 */
                this.getFrameContentWindow = goog.dom.getFrameContentWindow;
                /**
                 * Enables or disables keyboard focus support on the element via its tab index.
                 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
                 * (or elements that natively support keyboard focus, like form elements) can
                 * receive keyboard focus.  See http://go/tabindex for more info.
                 * @param {Element} element Element whose tab index is to be changed.
                 * @param {boolean} enable Whether to set or remove a tab index on the element
                 *     that supports keyboard focus.
                 */
                this.setFocusableTabIndex = goog.dom.setFocusableTabIndex;
                /**
                 * Walks up the DOM hierarchy returning the first ancestor that has the passed
                 * tag name and/or class name. If the passed element matches the specified
                 * criteria, the element itself is returned.
                 * @param {Node} element The DOM node to start with.
                 * @param {?(goog.dom.TagName<T>|string)=} opt_tag The tag name to match (or
                 *     null/undefined to match only based on class name).
                 * @param {?string=} opt_class The class name to match (or null/undefined to
                 *     match only based on tag name).
                 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
                 *     dom.
                 * @return {?R} The first ancestor that matches the passed criteria, or
                 *     null if no match is found. The return type is {?Element} if opt_tag is
                 *     not a member of goog.dom.TagName or a more specific type if it is (e.g.
                 *     {?HTMLAnchorElement} for goog.dom.TagName.A).
                 * @template T
                 * @template R := cond(isUnknown(T), 'Element', T) =:
                 */
                this.getAncestorByTagNameAndClass = goog.dom.getAncestorByTagNameAndClass;
                /**
                 * Reference to the document object to use
                 * @type {!Document}
                 * @private
                 */
                this.document_ = opt_document || goog.global.document || document;
            }
            /**
             * Gets the dom helper object for the document where the element resides.
             * @param {Node=} opt_node If present, gets the DomHelper for this node.
             * @return {!goog.dom.DomHelper} The DomHelper.
             */
            DomHelper.prototype.getDomHelper = function (opt_element) {
                return goog.dom.getDomHelper(opt_element);
            };
            /**
             * Sets the document object.
             * @param {!Document} document Document object.
             */
            DomHelper.prototype.setDocument = function (document) {
                this.document_ = document;
            };
            ;
            /**
             * Gets the document object being used by the dom library.
             * @return {!Document} Document object.
             */
            DomHelper.prototype.getDocument = function () {
                return this.document_;
            };
            ;
            /**
             * Alias for {@code getElementById}. If a DOM node is passed in then we just
             * return that.
             * @param {string|Element} element Element ID or a DOM node.
             * @return {Element} The element with the given ID, or the node passed in.
             */
            DomHelper.prototype.getElement = function (element) {
                return goog.dom.getElementHelper_(this.document_, element);
            };
            ;
            /**
             * Gets an element by id, asserting that the element is found.
             *
             * This is used when an element is expected to exist, and should fail with
             * an assertion error if it does not (if assertions are enabled).
             *
             * @param {string} id Element ID.
             * @return {!Element} The element with the given ID, if it exists.
             */
            DomHelper.prototype.getRequiredElement = function (id) {
                return goog.dom.getRequiredElementHelper_(this.document_, id);
            };
            ;
            /**
             * Alias for {@code getElement}.
             * @param {string|Element} element Element ID or a DOM node.
             * @return {Element} The element with the given ID, or the node passed in.
             * @deprecated Use {@link goog.dom.DomHelper.prototype.getElement} instead.
             */
            DomHelper.prototype.$ = function (element) {
                return this.getElement(element);
            };
            /**
             * Gets elements by tag name.
             * @param {!goog.dom.TagName<T>} tagName
             * @param {(!Document|!Element)=} opt_parent Parent element or document where to
             *     look for elements. Defaults to document of this DomHelper.
             * @return {!NodeList<R>} List of elements. The members of the list are
             *     {!Element} if tagName is not a member of goog.dom.TagName or more
             *     specific types if it is (e.g. {!HTMLAnchorElement} for
             *     goog.dom.TagName.A).
             * @template T
             * @template R := cond(isUnknown(T), 'Element', T) =:
             */
            DomHelper.prototype.getElementsByTagName = function (tagName, opt_parent) {
                var parent = opt_parent || this.document_;
                return parent.getElementsByTagName(String(tagName));
            };
            ;
            /**
            * Looks up elements by both tag and class name, using browser native functions
            * ({@code querySelectorAll}, {@code getElementsByTagName} or
            * {@code getElementsByClassName}) where possible. The returned array is a live
            * NodeList or a static list depending on the code path taken.
            *
            * @see goog.dom.query
            *
            * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name or * for all
            *     tags.
            * @param {?string=} opt_class Optional class name.
            * @param {(Document|Element)=} opt_el Optional element to look in.
            * @return {!IArrayLike<R>} Array-like list of elements (only a length property
            *     and numerical indices are guaranteed to exist). The members of the array
            *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more
            *     specific types if it is (e.g. {!HTMLAnchorElement} for
            *     goog.dom.TagName.A).
            * @template T
            * @template R := cond(isUnknown(T), 'Element', T) =:
            */
            DomHelper.prototype.getElementsByTagNameAndClass = function (opt_tag, opt_class, opt_el) {
                return goog.dom.getElementsByTagNameAndClass_(this.document_, opt_tag, opt_class, opt_el);
            };
            ;
            /**
            * Gets the first element matching the tag and the class.
            *
            * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
            * @param {?string=} opt_class Optional class name.
            * @param {(Document|Element)=} opt_el Optional element to look in.
            * @return {?R} Reference to a DOM node. The return type is {?Element} if
            *     tagName is a string or a more specific type if it is a member of
            *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).
            * @template T
            * @template R := cond(isUnknown(T), 'Element', T) =:
            */
            DomHelper.prototype.getElementByTagNameAndClass = function (opt_tag, opt_class, opt_el) {
                return goog.dom.getElementByTagNameAndClass_(this.document_, opt_tag, opt_class, opt_el);
            };
            ;
            /**
            * Returns an array of all the elements with the provided className.
            * @see {goog.dom.query}
            * @param {string} className the name of the class to look for.
            * @param {Element|Document=} opt_el Optional element to look in.
            * @return {!IArrayLike<!Element>} The items found with the class name provided.
            */
            DomHelper.prototype.getElementsByClass = function (className, opt_el) {
                var doc = opt_el || this.document_;
                return goog.dom.getElementsByClass(className, doc);
            };
            ;
            /**
            * Returns the first element we find matching the provided class name.
            * @see {goog.dom.query}
            * @param {string} className the name of the class to look for.
            * @param {(Element|Document)=} opt_el Optional element to look in.
            * @return {Element} The first item found with the class name provided.
            */
            DomHelper.prototype.getElementByClass = function (className, opt_el) {
                var doc = opt_el || this.document_;
                return goog.dom.getElementByClass(className, doc);
            };
            ;
            /**
            * Ensures an element with the given className exists, and then returns the
            * first element with the provided className.
            * @see {goog.dom.query}
            * @param {string} className the name of the class to look for.
            * @param {(!Element|!Document)=} opt_root Optional element or document to look
            *     in.
            * @return {!Element} The first item found with the class name provided.
            * @throws {goog.asserts.AssertionError} Thrown if no element is found.
            */
            DomHelper.prototype.getRequiredElementByClass = function (className, opt_root) {
                var root = opt_root || this.document_;
                return goog.dom.getRequiredElementByClass(className, root);
            };
            ;
            /**
             * Alias for {@code getElementsByTagNameAndClass}.
             * @deprecated Use DomHelper getElementsByTagNameAndClass.
             * @see goog.dom.query
             *
             * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
             * @param {?string=} opt_class Optional class name.
             * @param {Element=} opt_el Optional element to look in.
             * @return {!IArrayLike<R>} Array-like list of elements (only a length property
             *     and numerical indices are guaranteed to exist). The members of the array
             *     are {!Element} if opt_tag is a string or more specific types if it is
             *     a member of goog.dom.TagName (e.g. {!HTMLAnchorElement} for
             *     goog.dom.TagName.A).
             * @template T
             * @template R := cond(isUnknown(T), 'Element', T) =:
             */
            DomHelper.prototype.$$ = function (opt_tag, opt_class, opt_el) {
                return this.getElementByTagNameAndClass(opt_tag, opt_class, opt_el);
            };
            /**
             * Sets a number of properties on a node.
             * @param {Element} element DOM node to set properties on.
             * @param {Object} properties Hash of property:value pairs.
             */
            DomHelper.prototype.setProperties = function (element, properties) {
                return goog.dom.setProperties(element, properties);
            };
            /**
             * Gets the dimensions of the viewport.
             * @param {Window=} opt_window Optional window element to test. Defaults to
             *     the window of the Dom Helper.
             * @return {!goog.math.Size} Object with values 'width' and 'height'.
             */
            DomHelper.prototype.getViewportSize = function (opt_window) {
                // TODO(arv): This should not take an argument. That breaks the rule of a
                // a DomHelper representing a single frame/window/document.
                return goog.dom.getViewportSize(opt_window || this.getWindow());
            };
            ;
            /**
             * Calculates the height of the document.
             *
             * @return {number} The height of the document.
             */
            DomHelper.prototype.getDocumentHeight = function () {
                return goog.dom.getDocumentHeight_(this.getWindow());
            };
            ;
            /**
             * Returns a dom node with a set of attributes.  This function accepts varargs
             * for subsequent nodes to be added.  Subsequent nodes will be added to the
             * first node as childNodes.
             *
             * So:
             * <code>createDom(goog.dom.TagName.DIV, null, createDom(goog.dom.TagName.P),
             * createDom(goog.dom.TagName.P));</code> would return a div with two child
             * paragraphs
             *
             * An easy way to move all child nodes of an existing element to a new parent
             * element is:
             * <code>createDom(goog.dom.TagName.DIV, null, oldElement.childNodes);</code>
             * which will remove all child nodes from the old element and add them as
             * child nodes of the new DIV.
             *
             * @param {string|!goog.dom.TagName<T>} tagName Tag to create.
             * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map
             *     of name-value pairs for attributes. If a string, then this is the
             *     className of the new element. If an array, the elements will be joined
             *     together as the className of the new element.
             * @param {...goog.dom.Appendable} var_args Further DOM nodes or
             *     strings for text nodes. If one of the var_args is an array or
             *     NodeList, its elements will be added as childNodes instead.
             * @return {R} Reference to a DOM node. The return type is {!Element} if tagName
             *     is a string or a more specific type if it is a member of
             *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
             * @template T
             * @template R := cond(isUnknown(T), 'Element', T) =:
             */
            DomHelper.prototype.createDom = function (tagName, opt_attributes) {
                var var_args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    var_args[_i - 2] = arguments[_i];
                }
                return goog.dom.createDom_(this.document_, arguments);
            };
            ;
            /**
             * Alias for {@code createDom}.
             * @param {string|!goog.dom.TagName<T>} tagName Tag to create.
             * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map
             *     of name-value pairs for attributes. If a string, then this is the
             *     className of the new element. If an array, the elements will be joined
             *     together as the className of the new element.
             * @param {...goog.dom.Appendable} var_args Further DOM nodes or strings for
             *     text nodes.  If one of the var_args is an array, its children will be
             *     added as childNodes instead.
             * @return {R} Reference to a DOM node. The return type is {!Element} if tagName
             *     is a string or a more specific type if it is a member of
             *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
             * @template T
             * @template R := cond(isUnknown(T), 'Element', T) =:
             * @deprecated Use {@link goog.dom.DomHelper.prototype.createDom} instead.
             */
            DomHelper.prototype.$dom = function (tagName, opt_attributes) {
                var var_args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    var_args[_i - 2] = arguments[_i];
                }
                return this.createDom(tagName, opt_attributes, var_args);
            };
            ;
            /**
             * Creates a new element.
             * @param {string|!goog.dom.TagName<T>} name Tag to create.
             * @return {R} The new element. The return type is {!Element} if name is
             *     a string or a more specific type if it is a member of goog.dom.TagName
             *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
             * @template T
             * @template R := cond(isUnknown(T), 'Element', T) =:
             */
            DomHelper.prototype.createElement = function (name) {
                return goog.dom.createElement_(this.document_, name);
            };
            ;
            /**
             * Creates a new text node.
             * @param {number|string} content Content.
             * @return {!Text} The new text node.
             */
            DomHelper.prototype.createTextNode = function (content) {
                return this.document_.createTextNode(String(content));
            };
            ;
            /**
             * Create a table.
             * @param {number} rows The number of rows in the table.  Must be >= 1.
             * @param {number} columns The number of columns in the table.  Must be >= 1.
             * @param {boolean=} opt_fillWithNbsp If true, fills table entries with
             *     {@code goog.string.Unicode.NBSP} characters.
             * @return {!HTMLElement} The created table.
             */
            DomHelper.prototype.createTable = function (rows, columns, opt_fillWithNbsp) {
                return goog.dom.createTable_(this.document_, rows, columns, !!opt_fillWithNbsp);
            };
            ;
            /**
             * Converts an HTML into a node or a document fragment. A single Node is used if
             * {@code html} only generates a single node. If {@code html} generates multiple
             * nodes then these are put inside a {@code DocumentFragment}. This is a safe
             * version of {@code goog.dom.DomHelper#htmlToDocumentFragment} which is now
             * deleted.
             * @param {!goog.html.SafeHtml} html The HTML markup to convert.
             * @return {!Node} The resulting node.
             */
            DomHelper.prototype.safeHtmlToNode = function (html) {
                return goog.dom.safeHtmlToNode_(this.document_, html);
            };
            ;
            /**
             * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
             * mode, false otherwise.
             * @return {boolean} True if in CSS1-compatible mode.
             */
            DomHelper.prototype.isCss1CompatMode = function () {
                return goog.dom.isCss1CompatMode_(this.document_);
            };
            ;
            /**
             * Gets the window object associated with the document.
             * @return {!Window} The window associated with the given document.
             */
            DomHelper.prototype.getWindow = function () {
                return goog.dom.getWindow_(this.document_);
            };
            ;
            /**
             * Gets the document scroll element.
             * @return {!Element} Scrolling element.
             */
            DomHelper.prototype.getDocumentScrollElement = function () {
                return goog.dom.getDocumentScrollElement_(this.document_);
            };
            ;
            /**
             * Gets the document scroll distance as a coordinate object.
             * @return {!goog.math.Coordinate} Object with properties 'x' and 'y'.
             */
            DomHelper.prototype.getDocumentScroll = function () {
                return goog.dom.getDocumentScroll_(this.document_);
            };
            ;
            /**
             * Determines the active element in the given document.
             * @param {Document=} opt_doc The document to look in.
             * @return {Element} The active element.
             */
            DomHelper.prototype.getActiveElement = function (opt_doc) {
                return goog.dom.getActiveElement(opt_doc || this.document_);
            };
            ;
            /**
             * Appends a child to a node.
             * @param {Node} parent Parent.
             * @param {Node} child Child.
             */
            DomHelper.prototype.appendChild = function (parent, child) {
                return goog.dom.appendChild(parent, child);
            };
            ;
            /**
             * Appends a node with text or other nodes.
             * @param {!Node} parent The node to append nodes to.
             * @param {...goog.dom.Appendable} var_args The things to append to the node.
             *     If this is a Node it is appended as is.
             *     If this is a string then a text node is appended.
             *     If this is an array like object then fields 0 to length - 1 are appended.
             */
            DomHelper.prototype.append = function (parent, var_args) {
                goog.dom.append(parent, var_args);
            };
            /**
             * Determines if the given node can contain children, intended to be used for
             * HTML generation.
             *
             * @param {Node} node The node to check.
             * @return {boolean} Whether the node can contain children.
             */
            DomHelper.prototype.canHaveChildren = function (node) {
                return goog.dom.canHaveChildren(node);
            };
            ;
            /**
             * Removes all the child nodes on a DOM node.
             * @param {Node} node Node to remove children from.
             */
            DomHelper.prototype.removeChildren = function (node) {
                return goog.dom.removeChildren(node);
            };
            ;
            /**
             * Inserts a new node before an existing reference node (i.e., as the previous
             * sibling). If the reference node has no parent, then does nothing.
             * @param {Node} newNode Node to insert.
             * @param {Node} refNode Reference node to insert before.
             */
            DomHelper.prototype.insertSiblingBefore = function (newNode, refNode) {
                return goog.dom.insertSiblingBefore(newNode, refNode);
            };
            /**
             * Inserts a new node after an existing reference node (i.e., as the next
             * sibling). If the reference node has no parent, then does nothing.
             * @param {Node} newNode Node to insert.
             * @param {Node} refNode Reference node to insert after.
             */
            DomHelper.prototype.insertSiblingAfter = function (newNode, refNode) {
                return goog.dom.insertSiblingAfter(newNode, refNode);
            };
            /**
             * Insert a child at a given index. If index is larger than the number of child
             * nodes that the parent currently has, the node is inserted as the last child
             * node.
             * @param {Element} parent The element into which to insert the child.
             * @param {Node} child The element to insert.
             * @param {number} index The index at which to insert the new child node. Must
             *     not be negative.
             */
            DomHelper.prototype.insertChildAt = function (parent, child, index) {
                return goog.dom.insertChildAt(parent, child, index);
            };
            /**
             * Removes a node from its parent.
             * @param {Node} node The node to remove.
             * @return {Node} The node removed if removed; else, null.
             */
            DomHelper.prototype.removeNode = function (node) {
                return goog.dom.removeNode(node);
            };
            /**
             * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
             * parent.
             * @param {Node} newNode Node to insert.
             * @param {Node} oldNode Node to replace.
             */
            DomHelper.prototype.replaceNode = function (newNode, oldNode) {
                return goog.dom.replaceNode(newNode, oldNode);
            };
            /**
             * Flattens an element. That is, removes it and replace it with its children.
             * @param {Element} element The element to flatten.
             * @return {Element|undefined} The original element, detached from the document
             *     tree, sans children, or undefined if the element was already not in the
             *     document.
             */
            DomHelper.prototype.flattenElement = function (element) {
                return goog.dom.flattenElement(element);
            };
            /**
             * Returns an array containing just the element children of the given element.
             * @param {Element} element The element whose element children we want.
             * @return {!(Array<!Element>|NodeList<!Element>)} An array or array-like list
             *     of just the element children of the given element.
             */
            DomHelper.prototype.getChildren = function (element) {
                return goog.dom.getChildren(element);
            };
            /**
             * Returns the first child node that is an element.
             * @param {Node} node The node to get the first child element of.
             * @return {Element} The first child node of {@code node} that is an element.
             */
            DomHelper.prototype.getFirstElementChild = function (node) {
                return goog.dom.getFirstElementChild(node);
            };
            /**
             * Returns the last child node that is an element.
             * @param {Node} node The node to get the last child element of.
             * @return {Element} The last child node of {@code node} that is an element.
             */
            DomHelper.prototype.getLastElementChild = function (node) {
                return goog.dom.getLastElementChild(node);
            };
            /**
             * Returns the first next sibling that is an element.
             * @param {Node} node The node to get the next sibling element of.
             * @return {Element} The next sibling of {@code node} that is an element.
             */
            DomHelper.prototype.getNextElementSibling = function (node) {
                return goog.dom.getNextElementSibling(node);
            };
            /**
             * Returns the first previous sibling that is an element.
             * @param {Node} node The node to get the previous sibling element of.
             * @return {Element} The first previous sibling of {@code node} that is
             *     an element.
             */
            DomHelper.prototype.getPreviousElementSibling = function (node) {
                return goog.dom.getPreviousElementSibling(node);
            };
            /**
             * Returns the next node in source order from the given node.
             * @param {Node} node The node.
             * @return {Node} The next node in the DOM tree, or null if this was the last
             *     node.
             */
            DomHelper.prototype.getNextNode = function (node) {
                return goog.dom.getNextNode(node);
            };
            /**
             * Returns the previous node in source order from the given node.
             * @param {Node} node The node.
             * @return {Node} The previous node in the DOM tree, or null if this was the
             *     first node.
             */
            DomHelper.prototype.getPreviousNode = function () {
                return goog.dom.getPreviousNode;
            };
            /**
             * Whether the object looks like a DOM node.
             * @param {?} obj The object being tested for node likeness.
             * @return {boolean} Whether the object looks like a DOM node.
             */
            DomHelper.prototype.isNodeLike = function () {
                return goog.dom.isNodeLike;
            };
            /**
             * Whether the object looks like an Element.
             * @param {?} obj The object being tested for Element likeness.
             * @return {boolean} Whether the object looks like an Element.
             */
            DomHelper.prototype.isElement = function () {
                return goog.dom.isElement;
            };
            /**
             * Returns true if the specified value is a Window object. This includes the
             * global window for HTML pages, and iframe windows.
             * @param {?} obj Variable to test.
             * @return {boolean} Whether the variable is a window.
             */
            DomHelper.prototype.isWindow = function () {
                return goog.dom.isWindow;
            };
            /**
             * Returns an element's parent, if it's an Element.
             * @param {Element} element The DOM element.
             * @return {Element} The parent, or null if not an Element.
             */
            DomHelper.prototype.getParentElement = function () {
                return goog.dom.getParentElement;
            };
            /**
             * Whether a node contains another node.
             * @param {Node} parent The node that should contain the other node.
             * @param {Node} descendant The node to test presence of.
             * @return {boolean} Whether the parent node contains the descendent node.
             */
            DomHelper.prototype.contains = function () {
                return goog.dom.contains;
            };
            /**
             * Compares the document order of two nodes, returning 0 if they are the same
             * node, a negative number if node1 is before node2, and a positive number if
             * node2 is before node1.  Note that we compare the order the tags appear in the
             * document so in the tree <b><i>text</i></b> the B node is considered to be
             * before the I node.
             *
             * @param {Node} node1 The first node to compare.
             * @param {Node} node2 The second node to compare.
             * @return {number} 0 if the nodes are the same node, a negative number if node1
             *     is before node2, and a positive number if node2 is before node1.
             */
            DomHelper.prototype.compareNodeOrder = function () {
                return goog.dom.compareNodeOrder;
            };
            /**
             * Find the deepest common ancestor of the given nodes.
             * @param {...Node} var_args The nodes to find a common ancestor of.
             * @return {Node} The common ancestor of the nodes, or null if there is none.
             *     null will only be returned if two or more of the nodes are from different
             *     documents.
             */
            DomHelper.prototype.findCommonAncestor = function () {
                return goog.dom.findCommonAncestor;
            };
            /**
             * Returns the owner document for a node.
             * @param {Node} node The node to get the document for.
             * @return {!Document} The document owning the node.
             */
            DomHelper.prototype.getOwnerDocument = function () {
                return goog.dom.getOwnerDocument;
            };
            /**
             * Sets the text content of a node, with cross-browser support.
             * @param {Node} node The node to change the text content of.
             * @param {string|number} text The value that should replace the node's content.
             */
            DomHelper.prototype.setTextContent = function () {
                return goog.dom.setTextContent;
            };
            /**
             * Gets the outerHTML of a node, which islike innerHTML, except that it
             * actually contains the HTML of the node itself.
             * @param {Element} element The element to get the HTML of.
             * @return {string} The outerHTML of the given element.
             */
            DomHelper.prototype.getOuterHtml = function () {
                return goog.dom.getOuterHtml;
            };
            /**
             * Finds the first descendant node that matches the filter function. This does
             * a depth first search.
             * @param {Node} root The root of the tree to search.
             * @param {function(Node) : boolean} p The filter function.
             * @return {Node|undefined} The found node or undefined if none is found.
             */
            DomHelper.prototype.findNode = function () {
                return goog.dom.findNode;
            };
            /**
             * Finds all the descendant nodes that matches the filter function. This does a
             * depth first search.
             * @param {Node} root The root of the tree to search.
             * @param {function(Node) : boolean} p The filter function.
             * @return {Array<Node>} The found nodes or an empty array if none are found.
             */
            DomHelper.prototype.findNodes = function () {
                return goog.dom.findNodes;
            };
            /**
             * Returns true if the element has a tab index that allows it to receive
             * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements
             * natively support keyboard focus, even if they have no tab index.
             * @param {!Element} element Element to check.
             * @return {boolean} Whether the element has a tab index that allows keyboard
             *     focus.
             */
            DomHelper.prototype.isFocusableTabIndex = function () {
                return goog.dom.isFocusableTabIndex;
            };
            /**
             * Returns true if the element can be focused, i.e. it has a tab index that
             * allows it to receive keyboard focus (tabIndex >= 0), or it is an element
             * that natively supports keyboard focus.
             * @param {!Element} element Element to check.
             * @return {boolean} Whether the element allows keyboard focus.
             */
            DomHelper.prototype.isFocusable = function () {
                return goog.dom.isFocusable;
            };
            /**
             * Returns the text contents of the current node, without markup. New lines are
             * stripped and whitespace is collapsed, such that each character would be
             * visible.
             *
             * In browsers that support it, innerText is used.  Other browsers attempt to
             * simulate it via node traversal.  Line breaks are canonicalized in IE.
             *
             * @param {Node} node The node from which we are getting content.
             * @return {string} The text content.
             */
            DomHelper.prototype.getTextContent = function () {
                return goog.dom.getTextContent;
            };
            /**
             * Returns the text length of the text contained in a node, without markup. This
             * is equivalent to the selection length if the node was selected, or the number
             * of cursor movements to traverse the node. Images & BRs take one space.  New
             * lines are ignored.
             *
             * @param {Node} node The node whose text content length is being calculated.
             * @return {number} The length of {@code node}'s text content.
             */
            DomHelper.prototype.getNodeTextLength = function () {
                return goog.dom.getNodeTextLength;
            };
            /**
             * Returns the text offset of a node relative to one of its ancestors. The text
             * length is the same as the length calculated by
             * {@code goog.dom.getNodeTextLength}.
             *
             * @param {Node} node The node whose offset is being calculated.
             * @param {Node=} opt_offsetParent Defaults to the node's owner document's body.
             * @return {number} The text offset.
             */
            DomHelper.prototype.getNodeTextOffset = function () {
                return goog.dom.getNodeTextOffset;
            };
            /**
             * Returns the node at a given offset in a parent node.  If an object is
             * provided for the optional third parameter, the node and the remainder of the
             * offset will stored as properties of this object.
             * @param {Node} parent The parent node.
             * @param {number} offset The offset into the parent node.
             * @param {Object=} opt_result Object to be used to store the return value. The
             *     return value will be stored in the form {node: Node, remainder: number}
             *     if this object is provided.
             * @return {Node} The node at the given offset.
             */
            DomHelper.prototype.getNodeAtOffset = function () {
                return goog.dom.getNodeAtOffset;
            };
            /**
             * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
             * the object must have a numeric length property and an item function (which
             * has type 'string' on IE for some reason).
             * @param {Object} val Object to test.
             * @return {boolean} Whether the object is a NodeList.
             */
            DomHelper.prototype.isNodeList = function () {
                return goog.dom.isNodeList;
            };
            /**
             * Walks up the DOM hierarchy returning the first ancestor that has the passed
             * class name. If the passed element matches the specified criteria, the
             * element itself is returned.
             * @param {Node} element The DOM node to start with.
             * @param {string} class The class name to match.
             * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
             *     dom.
             * @return {Element} The first ancestor that matches the passed criteria, or
             *     null if none match.
             */
            DomHelper.prototype.getAncestorByClass = function () {
                return goog.dom.getAncestorByClass;
            };
            /**
             * Walks up the DOM hierarchy returning the first ancestor that passes the
             * matcher function.
             * @param {Node} element The DOM node to start with.
             * @param {function(Node) : boolean} matcher A function that returns true if the
             *     passed node matches the desired criteria.
             * @param {boolean=} opt_includeNode If true, the node itself is included in
             *     the search (the first call to the matcher will pass startElement as
             *     the node to test).
             * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
             *     dom.
             * @return {Node} DOM node that matched the matcher, or null if there was
             *     no match.
             */
            DomHelper.prototype.getAncestor = function () {
                return goog.dom.getAncestor;
            };
            /**
             * Gets '2d' context of a canvas. Shortcut for canvas.getContext('2d') with a
             * type information.
             * @param {!HTMLCanvasElement} canvas
             * @return {!CanvasRenderingContext2D}
             */
            DomHelper.prototype.getCanvasContext2D = function () {
                return goog.dom.getCanvasContext2D;
            };
            return DomHelper;
        }());
        dom.DomHelper = DomHelper;
    })(dom = goog.dom || (goog.dom = {}));
})(goog || (goog = {}));
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Definition of the disposable interface.  A disposable object
 * has a dispose method to to clean up references and resources.
 * @author nnaze@google.com (Nathan Naze)
 */
goog.provide('goog.disposable.IDisposable');
/// <reference path="./idisposable" />
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Implements the disposable interface. The dispose method is used
 * to clean up references and resources.
 * @author arv@google.com (Erik Arvidsson)
 */
goog.provide('goog.Disposable');
goog.provide('goog.dispose');
goog.provide('goog.disposeAll');
goog.require('goog.disposable.IDisposable');
var goog;
(function (goog) {
    var Disposable = /** @class */ (function () {
        /**
         * Class that provides the basic implementation for disposable objects. If your
         * class holds one or more references to COM objects, DOM nodes, or other
         * disposable objects, it should extend this class or implement the disposable
         * interface (defined in goog.disposable.IDisposable).
         * @constructor
         * @implements {goog.disposable.IDisposable}
         */
        function Disposable() {
            /**
             * Whether the object has been disposed of.
             * @type {boolean}
             * @private
             */
            this.disposed_ = false;
            /**
             * If monitoring the goog.Disposable instances is enabled, stores the creation
             * stack trace of the Disposable instance.
             * @type {string|undefined}
             */
            this.creationStack;
            if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
                if (goog.Disposable.INCLUDE_STACK_ON_CREATION) {
                    this.creationStack = new Error().stack;
                }
                goog.Disposable.instances_[goog.getUid(this)] = this;
            }
            // Support sealing
            this.disposed_ = this.disposed_;
            this.onDisposeCallbacks_ = this.onDisposeCallbacks_;
        }
        /**
         * @return {boolean} Whether the object has been disposed of.
         * @override
         */
        Disposable.prototype.isDisposed = function () {
            return this.disposed_;
        };
        ;
        /**
         * @return {boolean} Whether the object has been disposed of.
         * @deprecated Use {@link #isDisposed} instead.
         */
        Disposable.prototype.getDisposed = function () {
            return this.isDisposed();
        };
        /**
         * Disposes of the object. If the object hasn't already been disposed of, calls
         * {@link #disposeInternal}. Classes that extend {@code goog.Disposable} should
         * override {@link #disposeInternal} in order to delete references to COM
         * objects, DOM nodes, and other disposable objects. Reentrant.
         *
         * @return {void} Nothing.
         * @override
         */
        Disposable.prototype.dispose = function () {
            if (!this.disposed_) {
                // Set disposed_ to true first, in case during the chain of disposal this
                // gets disposed recursively.
                this.disposed_ = true;
                this.disposeInternal();
                if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
                    var uid = goog.getUid(this);
                    if (goog.Disposable.MONITORING_MODE ==
                        goog.Disposable.MonitoringMode.PERMANENT &&
                        !goog.Disposable.instances_.hasOwnProperty(uid)) {
                        throw new Error(this + ' did not call the goog.Disposable base ' +
                            'constructor or was disposed of after a clearUndisposedObjects ' +
                            'call');
                    }
                    delete goog.Disposable.instances_[uid];
                }
            }
        };
        ;
        /**
         * Associates a disposable object with this object so that they will be disposed
         * together.
         * @param {goog.disposable.IDisposable} disposable that will be disposed when
         *     this object is disposed.
         */
        Disposable.prototype.registerDisposable = function (disposable) {
            this.addOnDisposeCallback(goog.partial(goog.dispose, disposable));
        };
        ;
        /**
         * Invokes a callback function when this object is disposed. Callbacks are
         * invoked in the order in which they were added. If a callback is added to
         * an already disposed Disposable, it will be called immediately.
         * @param {function(this:T):?} callback The callback function.
         * @param {T=} opt_scope An optional scope to call the callback in.
         * @template T
         */
        Disposable.prototype.addOnDisposeCallback = function (callback, opt_scope) {
            if (this.disposed_) {
                goog.isDef(opt_scope) ? callback.call(opt_scope) : callback();
                return;
            }
            if (!this.onDisposeCallbacks_) {
                this.onDisposeCallbacks_ = [];
            }
            this.onDisposeCallbacks_.push(goog.isDef(opt_scope) ? goog.bind(callback, opt_scope) : callback);
        };
        ;
        /**
         * Deletes or nulls out any references to COM objects, DOM nodes, or other
         * disposable objects. Classes that extend {@code goog.Disposable} should
         * override this method.
         * Not reentrant. To avoid calling it twice, it must only be called from the
         * subclass' {@code disposeInternal} method. Everywhere else the public
         * {@code dispose} method must be used.
         * For example:
         * <pre>
         *   mypackage.MyClass = function() {
         *     mypackage.MyClass.base(this, 'constructor');
         *     // Constructor logic specific to MyClass.
         *     ...
         *   };
         *   goog.inherits(mypackage.MyClass, goog.Disposable);
         *
         *   mypackage.MyClass.prototype.disposeInternal = function() {
         *     // Dispose logic specific to MyClass.
         *     ...
         *     // Call superclass's disposeInternal at the end of the subclass's, like
         *     // in C++, to avoid hard-to-catch issues.
         *     mypackage.MyClass.base(this, 'disposeInternal');
         *   };
         * </pre>
         * @protected
         */
        Disposable.prototype.disposeInternal = function () {
            if (this.onDisposeCallbacks_) {
                while (this.onDisposeCallbacks_.length) {
                    this.onDisposeCallbacks_.shift()();
                }
            }
        };
        ;
        return Disposable;
    }());
    goog.Disposable = Disposable;
})(goog || (goog = {}));
(function (goog) {
    var Disposable;
    (function (Disposable) {
        /**
         * @enum {number} Different monitoring modes for Disposable.
         */
        var MonitoringMode;
        (function (MonitoringMode) {
            /**
             * No monitoring.
             */
            MonitoringMode[MonitoringMode["OFF"] = 0] = "OFF";
            /**
             * Creating and disposing the goog.Disposable instances is monitored. All
             * disposable objects need to call the {@code goog.Disposable} base
             * constructor. The PERMANENT mode must be switched on before creating any
             * goog.Disposable instances.
             */
            MonitoringMode[MonitoringMode["PERMANENT"] = 1] = "PERMANENT";
            /**
             * INTERACTIVE mode can be switched on and off on the fly without producing
             * errors. It also doesn't warn if the disposable objects don't call the
             * {@code goog.Disposable} base constructor.
             */
            MonitoringMode[MonitoringMode["INTERACTIVE"] = 2] = "INTERACTIVE";
        })(MonitoringMode = Disposable.MonitoringMode || (Disposable.MonitoringMode = {}));
        ;
        Disposable.MONITORING_MODE = 0;
        Disposable.INCLUDE_STACK_ON_CREATION = true;
        /**
         * Maps the unique ID of every undisposed {@code goog.Disposable} object to
         * the object itself.
         * @type {!Object<number, !goog.Disposable>}
         * @private
         */
        Disposable.instances_ = {};
        /**
         * @return {!Array<!goog.Disposable>} All {@code goog.Disposable} objects that
         *     haven't been disposed of.
         */
        function getUndisposedObjects() {
            var ret = [];
            for (var id in goog.Disposable.instances_) {
                if (goog.Disposable.instances_.hasOwnProperty(id)) {
                    ret.push(goog.Disposable.instances_[Number(id)]);
                }
            }
            return ret;
        }
        Disposable.getUndisposedObjects = getUndisposedObjects;
        ;
        /**
         * Clears the registry of undisposed objects but doesn't dispose of them.
         */
        function clearUndisposedObjects() {
            goog.Disposable.instances_ = {};
        }
        Disposable.clearUndisposedObjects = clearUndisposedObjects;
        ;
        /**
         * Returns True if we can verify the object is disposed.
         * Calls {@code isDisposed} on the argument if it supports it.  If obj
         * is not an object with an isDisposed() method, return false.
         * @param {*} obj The object to investigate.
         * @return {boolean} True if we can verify the object is disposed.
         */
        function isDisposed(obj) {
            if (obj && typeof obj.isDisposed == 'function') {
                return obj.isDisposed();
            }
            return false;
        }
        Disposable.isDisposed = isDisposed;
        ;
    })(Disposable = goog.Disposable || (goog.Disposable = {}));
})(goog || (goog = {}));
/**
 * @define {number} The monitoring mode of the goog.Disposable
 *     instances. Default is OFF. Switching on the monitoring is only
 *     recommended for debugging because it has a significant impact on
 *     performance and memory usage. If switched off, the monitoring code
 *     compiles down to 0 bytes.
 */
goog.define('goog.Disposable.MONITORING_MODE', 0);
/**
 * @define {boolean} Whether to attach creation stack to each created disposable
 *     instance; This is only relevant for when MonitoringMode != OFF.
 */
goog.define('goog.Disposable.INCLUDE_STACK_ON_CREATION', true);
(function (goog) {
    /**
     * Calls {@code dispose} on the argument if it supports it. If obj is not an
     *     object with a dispose() method, this is a no-op.
     * @param {*} obj The object to dispose of.
     */
    function dispose(obj) {
        if (obj && typeof obj.dispose == 'function') {
            obj.dispose();
        }
    }
    goog.dispose = dispose;
    ;
    /**
     * Calls {@code dispose} on each member of the list that supports it. (If the
     * member is an ArrayLike, then {@code goog.disposeAll()} will be called
     * recursively on each of its members.) If the member is not an object with a
     * {@code dispose()} method, then it is ignored.
     * @param {...*} var_args The list.
     */
    function disposeAll() {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            var_args[_i] = arguments[_i];
        }
        for (var i = 0, len = arguments.length; i < len; ++i) {
            var disposable = arguments[i];
            if (goog.isArrayLike(disposable)) {
                goog.disposeAll.apply(null, disposable);
            }
            else {
                goog.dispose(disposable);
            }
        }
    }
    goog.disposeAll = disposeAll;
    ;
})(goog || (goog = {}));
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A global registry for entry points into a program,
 * so that they can be instrumented. Each module should register their
 * entry points with this registry. Designed to be compiled out
 * if no instrumentation is requested.
 *
 * Entry points may be registered before or after a call to
 * goog.debug.entryPointRegistry.monitorAll. If an entry point is registered
 * later, the existing monitor will instrument the new entry point.
 *
 * @author nicksantos@google.com (Nick Santos)
 */
goog.provide('goog.debug.EntryPointMonitor');
goog.provide('goog.debug.entryPointRegistry');
goog.require('goog.asserts');
var goog;
(function (goog) {
    var debug;
    (function (debug) {
        var entryPointRegistry;
        (function (entryPointRegistry) {
            /**
             * An array of entry point callbacks.
             * @type {!Array<function(!Function)>}
             * @private
             */
            entryPointRegistry.refList_ = [];
            /**
             * Monitors that should wrap all the entry points.
             * @type {!Array<!goog.debug.EntryPointMonitor>}
             * @private
             */
            entryPointRegistry.monitors_ = [];
            /**
             * Whether goog.debug.entryPointRegistry.monitorAll has ever been called.
             * Checking this allows the compiler to optimize out the registrations.
             * @type {boolean}
             * @private
             */
            entryPointRegistry.monitorsMayExist_ = false;
            /**
             * Register an entry point with this module.
             *
             * The entry point will be instrumented when a monitor is passed to
             * goog.debug.entryPointRegistry.monitorAll. If this has already occurred, the
             * entry point is instrumented immediately.
             *
             * @param {function(!Function)} callback A callback function which is called
             *     with a transforming function to instrument the entry point. The callback
             *     is responsible for wrapping the relevant entry point with the
             *     transforming function.
             */
            function register(callback) {
                // Don't use push(), so that this can be compiled out.
                goog.debug.entryPointRegistry
                    .refList_[goog.debug.entryPointRegistry.refList_.length] = callback;
                // If no one calls monitorAll, this can be compiled out.
                if (goog.debug.entryPointRegistry.monitorsMayExist_) {
                    var monitors = goog.debug.entryPointRegistry.monitors_;
                    for (var i = 0; i < monitors.length; i++) {
                        callback(goog.bind(monitors[i].wrap, monitors[i]));
                    }
                }
            }
            entryPointRegistry.register = register;
            ;
            /**
             * Configures a monitor to wrap all entry points.
             *
             * Entry points that have already been registered are immediately wrapped by
             * the monitor. When an entry point is registered in the future, it will also
             * be wrapped by the monitor when it is registered.
             *
             * @param {!goog.debug.EntryPointMonitor} monitor An entry point monitor.
             */
            function monitorAll(monitor) {
                goog.debug.entryPointRegistry.monitorsMayExist_ = true;
                var transformer = goog.bind(monitor.wrap, monitor);
                for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) {
                    goog.debug.entryPointRegistry.refList_[i](transformer);
                }
                goog.debug.entryPointRegistry.monitors_.push(monitor);
            }
            entryPointRegistry.monitorAll = monitorAll;
            ;
            /**
             * Try to unmonitor all the entry points that have already been registered. If
             * an entry point is registered in the future, it will not be wrapped by the
             * monitor when it is registered. Note that this may fail if the entry points
             * have additional wrapping.
             *
             * @param {!goog.debug.EntryPointMonitor} monitor The last monitor to wrap
             *     the entry points.
             * @throws {Error} If the monitor is not the most recently configured monitor.
             */
            function unmonitorAllIfPossible(monitor) {
                var monitors = goog.debug.entryPointRegistry.monitors_;
                goog.asserts.assert(monitor == monitors[monitors.length - 1], 'Only the most recent monitor can be unwrapped.');
                var transformer = goog.bind(monitor.unwrap, monitor);
                for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) {
                    goog.debug.entryPointRegistry.refList_[i](transformer);
                }
                monitors.length--;
            }
            entryPointRegistry.unmonitorAllIfPossible = unmonitorAllIfPossible;
            ;
        })(entryPointRegistry = debug.entryPointRegistry || (debug.entryPointRegistry = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
goog.provide('goog.events.EventId');
var goog;
(function (goog) {
    var events;
    (function (events) {
        var EventId = /** @class */ (function () {
            /**
             * A templated class that is used when registering for events. Typical usage:
             *
             *    /** @type {goog.events.EventId<MyEventObj>} *\
             *    var myEventId = new goog.events.EventId(
             *        goog.events.getUniqueId(('someEvent'));
             *
             *    // No need to cast or declare here since the compiler knows the
             *    // correct type of 'evt' (MyEventObj).
             *    something.listen(myEventId, function(evt) {});
             *
             * @param {string} eventId
             * @template T
             * @constructor
             * @struct
             * @final
             */
            function EventId(eventId) {
                /** @const */ this.id = eventId;
            }
            /**
             * @override
             */
            EventId.prototype.toString = function () {
                return this.id;
            };
            return EventId;
        }());
        events.EventId = EventId;
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
/// <reference path="../disposable/Disposable" />
/// <reference path="../events/EventId" />
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A base class for event objects.
 *
 */
goog.provide('goog.events.Event');
goog.provide('goog.events.EventLike');
/**
 * goog.events.Event no longer depends on goog.Disposable. Keep requiring
 * goog.Disposable here to not break projects which assume this dependency.
 * @suppress {extraRequire}
 */
goog.require('goog.Disposable');
goog.require('goog.events.EventId');
var goog;
(function (goog) {
    var events;
    (function (events) {
        var Event = /** @class */ (function () {
            /**
             * A base class for event objects, so that they can support preventDefault and
             * stopPropagation.
             *
             * @suppress {underscore} Several properties on this class are technically
             *     public, but referencing these properties outside this package is strongly
             *     discouraged.
             *
             * @param {string|!goog.events.EventId} type Event Type.
             * @param {Object=} opt_target Reference to the object that is the target of
             *     this event. It has to implement the {@code EventTarget} interface
             *     declared at {@link http://developer.mozilla.org/en/DOM/EventTarget}.
             * @constructor
             */
            function Event(type, opt_target) {
                /**
                 * Event type.
                 * @type {string}
                 */
                this.type = type instanceof goog.events.EventId ? String(type) : type;
                /**
                 * TODO(tbreisacher): The type should probably be
                 * EventTarget|goog.events.EventTarget.
                 *
                 * Target of the event.
                 * @type {Object|undefined}
                 */
                this.target = opt_target;
                /**
                 * Object that had the listener attached.
                 * @type {Object|undefined}
                 */
                this.currentTarget = this.target;
                /**
                 * Whether to cancel the event in internal capture/bubble processing for IE.
                 * @type {boolean}
                 * @public
                 */
                this.propagationStopped_ = false;
                /**
                 * Whether the default action has been prevented.
                 * This is a property to match the W3C specification at
                 * {@link http://www.w3.org/TR/DOM-Level-3-Events/
                 * #events-event-type-defaultPrevented}.
                 * Must be treated as read-only outside the class.
                 * @type {boolean}
                 */
                this.defaultPrevented = false;
                /**
                 * Return value for in internal capture/bubble processing for IE.
                 * @type {boolean}
                 * @public
                 */
                this.returnValue_ = true;
            }
            /**
             * Stops event propagation.
             */
            Event.prototype.stopPropagation = function () {
                this.propagationStopped_ = true;
            };
            ;
            /**
             * Prevents the default action, for example a link redirecting to a url.
             */
            Event.prototype.preventDefault = function () {
                this.defaultPrevented = true;
                this.returnValue_ = false;
            };
            ;
            return Event;
        }());
        events.Event = Event;
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
(function (goog) {
    var events;
    (function (events) {
        /**
         * Stops the propagation of the event. It is equivalent to
         * {@code e.stopPropagation()}, but can be used as the callback argument of
         * {@link goog.events.listen} without declaring another function.
         * @param {!goog.events.Event} e An event.
         */
        function stopPropagation(e) {
            e.stopPropagation();
        }
        events.stopPropagation = stopPropagation;
        ;
        /**
         * Prevents the default action. It is equivalent to
         * {@code e.preventDefault()}, but can be used as the callback argument of
         * {@link goog.events.listen} without declaring another function.
         * @param {!goog.events.Event} e An event.
         */
        function preventDefault(e) {
            e.preventDefault();
        }
        events.preventDefault = preventDefault;
        ;
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
// Copyright 2017 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Provides methods dealing with context on error objects.
 */
goog.provide('goog.debug.errorcontext');
var goog;
(function (goog) {
    var debug;
    (function (debug) {
        var errorcontext;
        (function (errorcontext) {
            /**
             * Adds key-value context to the error.
             * @param {!Error} err The error to add context to.
             * @param {string} contextKey Key for the context to be added.
             * @param {string} contextValue Value for the context to be added.
             */
            function addErrorContext(err, contextKey, contextValue) {
                if (!err[goog.debug.errorcontext.CONTEXT_KEY_]) {
                    err[goog.debug.errorcontext.CONTEXT_KEY_] = {};
                }
                err[goog.debug.errorcontext.CONTEXT_KEY_][contextKey] = contextValue;
            }
            errorcontext.addErrorContext = addErrorContext;
            ;
            /**
             * @param {!Error} err The error to get context from.
             * @return {!Object<string, string>} The context of the provided error.
             */
            function getErrorContext(err) {
                return err[goog.debug.errorcontext.CONTEXT_KEY_] || {};
            }
            errorcontext.getErrorContext = getErrorContext;
            ;
            // TODO(user): convert this to a Symbol once goog.debug.ErrorReporter is
            // able to use ES6.
            /** @private @const {string} */
            errorcontext.CONTEXT_KEY_ = '__closure__error__context__984382';
        })(errorcontext = debug.errorcontext || (debug.errorcontext = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
/// <reference path="../array/array" />
/// <reference path="../debug/errorcontext" />
/// <reference path="../useragent/userAgent" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Logging and debugging utilities.
 *
 * @see ../demos/debug.html
 */
goog.provide('goog.debug');
goog.require('goog.array');
goog.require('goog.debug.errorcontext');
goog.require('goog.userAgent');
/** @define {boolean} Whether logging should be enabled. */
goog.define('goog.debug.LOGGING_ENABLED', goog.DEBUG);
/** @define {boolean} Whether to force "sloppy" stack building. */
goog.define('goog.debug.FORCE_SLOPPY_STACKS', false);
var goog;
(function (goog) {
    var debug;
    (function (debug) {
        debug.LOGGING_ENABLED = goog.DEBUG;
        debug.FORCE_SLOPPY_STACKS = false;
        /**
         * Catches onerror events fired by windows and similar objects.
         * @param {function(Object)} logFunc The function to call with the error
         *    information.
         * @param {boolean=} opt_cancel Whether to stop the error from reaching the
         *    browser.
         * @param {Object=} opt_target Object that fires onerror events.
         */
        function catchErrors(logFunc, opt_cancel, opt_target) {
            var target = opt_target || goog.global;
            var oldErrorHandler = target.onerror;
            var retVal = !!opt_cancel;
            // Chrome interprets onerror return value backwards (http://crbug.com/92062)
            // until it was fixed in webkit revision r94061 (Webkit 535.3). This
            // workaround still needs to be skipped in Safari after the webkit change
            // gets pushed out in Safari.
            // See https://bugs.webkit.org/show_bug.cgi?id=67119
            if (goog.userAgent.WEBKIT && !goog.userAgent.isVersionOrHigher('535.3')) {
                retVal = !retVal;
            }
            /**
             * New onerror handler for this target. This onerror handler follows the spec
             * according to
             * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors
             * The spec was changed in August 2013 to support receiving column information
             * and an error object for all scripts on the same origin or cross origin
             * scripts with the proper headers. See
             * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
             *
             * @param {string} message The error message. For cross-origin errors, this
             *     will be scrubbed to just "Script error.". For new browsers that have
             *     updated to follow the latest spec, errors that come from origins that
             *     have proper cross origin headers will not be scrubbed.
             * @param {string} url The URL of the script that caused the error. The URL
             *     will be scrubbed to "" for cross origin scripts unless the script has
             *     proper cross origin headers and the browser has updated to the latest
             *     spec.
             * @param {number} line The line number in the script that the error
             *     occurred on.
             * @param {number=} opt_col The optional column number that the error
             *     occurred on. Only browsers that have updated to the latest spec will
             *     include this.
             * @param {Error=} opt_error The optional actual error object for this
             *     error that should include the stack. Only browsers that have updated
             *     to the latest spec will inlude this parameter.
             * @return {boolean} Whether to prevent the error from reaching the browser.
             */
            target.onerror = function (message, url, line, opt_col, opt_error) {
                if (oldErrorHandler) {
                    oldErrorHandler(message, url, line, opt_col, opt_error);
                }
                logFunc({
                    message: message,
                    fileName: url,
                    line: line,
                    lineNumber: line,
                    col: opt_col,
                    error: opt_error
                });
                return retVal;
            };
        }
        debug.catchErrors = catchErrors;
        ;
        /**
         * Creates a string representing an object and all its properties.
         * @param {Object|null|undefined} obj Object to expose.
         * @param {boolean=} opt_showFn Show the functions as well as the properties,
         *     default is false.
         * @return {string} The string representation of {@code obj}.
         */
        function expose(obj, opt_showFn) {
            if (typeof obj == 'undefined') {
                return 'undefined';
            }
            if (obj == null) {
                return 'NULL';
            }
            var str = [];
            for (var x in obj) {
                if (!opt_showFn && goog.isFunction(obj[x])) {
                    continue;
                }
                var s = x + ' = ';
                try {
                    s += obj[x];
                }
                catch (e) {
                    s += '*** ' + e + ' ***';
                }
                str.push(s);
            }
            return str.join('\n');
        }
        debug.expose = expose;
        ;
        /**
         * Creates a string representing a given primitive or object, and for an
         * object, all its properties and nested objects. NOTE: The output will include
         * Uids on all objects that were exposed. Any added Uids will be removed before
         * returning.
         * @param {*} obj Object to expose.
         * @param {boolean=} opt_showFn Also show properties that are functions (by
         *     default, functions are omitted).
         * @return {string} A string representation of {@code obj}.
         */
        function deepExpose(obj, opt_showFn) {
            var str = [];
            // Track any objects where deepExpose added a Uid, so they can be cleaned up
            // before return. We do this globally, rather than only on ancestors so that
            // if the same object appears in the output, you can see it.
            var uidsToCleanup = [];
            var ancestorUids = {};
            var helper = function (obj, space) {
                var nestspace = space + '  ';
                var indentMultiline = function (str) {
                    return str.replace(/\n/g, '\n' + space);
                };
                try {
                    if (!goog.isDef(obj)) {
                        str.push('undefined');
                    }
                    else if (goog.isNull(obj)) {
                        str.push('NULL');
                    }
                    else if (goog.isString(obj)) {
                        str.push('"' + indentMultiline(obj) + '"');
                    }
                    else if (goog.isFunction(obj)) {
                        str.push(indentMultiline(String(obj)));
                    }
                    else if (goog.isObject(obj)) {
                        // Add a Uid if needed. The struct calls implicitly adds them.
                        if (!goog.hasUid(obj)) {
                            uidsToCleanup.push(obj);
                        }
                        var uid = goog.getUid(obj);
                        if (ancestorUids[uid]) {
                            str.push('*** reference loop detected (id=' + uid + ') ***');
                        }
                        else {
                            ancestorUids[uid] = true;
                            str.push('{');
                            for (var x in obj) {
                                if (!opt_showFn && goog.isFunction(obj[x])) {
                                    continue;
                                }
                                str.push('\n');
                                str.push(nestspace);
                                str.push(x + ' = ');
                                helper(obj[x], nestspace);
                            }
                            str.push('\n' + space + '}');
                            delete ancestorUids[uid];
                        }
                    }
                    else {
                        str.push(obj);
                    }
                }
                catch (e) {
                    str.push('*** ' + e + ' ***');
                }
            };
            helper(obj, '');
            // Cleanup any Uids that were added by the deepExpose.
            for (var i = 0; i < uidsToCleanup.length; i++) {
                goog.removeUid(uidsToCleanup[i]);
            }
            return str.join('');
        }
        debug.deepExpose = deepExpose;
        ;
        /**
         * Recursively outputs a nested array as a string.
         * @param {Array<?>} arr The array.
         * @return {string} String representing nested array.
         */
        function exposeArray(arr) {
            var str = [];
            for (var i = 0; i < arr.length; i++) {
                if (goog.isArray(arr[i])) {
                    str.push(goog.debug.exposeArray(arr[i]));
                }
                else {
                    str.push(arr[i]);
                }
            }
            return '[ ' + str.join(', ') + ' ]';
        }
        debug.exposeArray = exposeArray;
        ;
        /**
         * Normalizes the error/exception object between browsers.
         * @param {*} err Raw error object.
         * @return {!{
         *    message: (?|undefined),
         *    name: (?|undefined),
         *    lineNumber: (?|undefined),
         *    fileName: (?|undefined),
         *    stack: (?|undefined)
         * }} Normalized error object.
         */
        function normalizeErrorObject(err) {
            var href = goog.getObjectByName('window.location.href');
            if (goog.isString(err)) {
                return {
                    'message': err,
                    'name': 'Unknown error',
                    'lineNumber': 'Not available',
                    'fileName': href,
                    'stack': 'Not available'
                };
            }
            var lineNumber, fileName;
            var threwError = false;
            try {
                lineNumber = err.lineNumber || err.line || 'Not available';
            }
            catch (e) {
                // Firefox 2 sometimes throws an error when accessing 'lineNumber':
                // Message: Permission denied to get property UnnamedClass.lineNumber
                lineNumber = 'Not available';
                threwError = true;
            }
            try {
                fileName = err.fileName || err.filename || err.sourceURL ||
                    // $googDebugFname may be set before a call to eval to set the filename
                    // that the eval is supposed to present.
                    goog.global['$googDebugFname'] || href;
            }
            catch (e) {
                // Firefox 2 may also throw an error when accessing 'filename'.
                fileName = 'Not available';
                threwError = true;
            }
            // The IE Error object contains only the name and the message.
            // The Safari Error object uses the line and sourceURL fields.
            if (threwError || !err.lineNumber || !err.fileName || !err.stack ||
                !err.message || !err.name) {
                return {
                    'message': err.message || 'Not available',
                    'name': err.name || 'UnknownError',
                    'lineNumber': lineNumber,
                    'fileName': fileName,
                    'stack': err.stack || 'Not available'
                };
            }
            // Standards error object
            // Typed !Object. Should be a subtype of the return type, but it's not.
            return /** @type {?} */ (err);
        }
        debug.normalizeErrorObject = normalizeErrorObject;
        ;
        /**
         * Converts an object to an Error using the object's toString if it's not
         * already an Error, adds a stacktrace if there isn't one, and optionally adds
         * an extra message.
         * @param {*} err The original thrown error, object, or string.
         * @param {string=} opt_message  optional additional message to add to the
         *     error.
         * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,
         *     it is converted to an Error which is enhanced and returned.
         */
        function enhanceError(err, opt_message) {
            var error;
            if (!(err instanceof debug.Error)) {
                // will invoke wrong Error class
                // error = Error(err);
                // if (Error.captureStackTrace) {
                // Trim this function off the call stack, if we can.
                // Error.captureStackTrace(error, goog.debug.enhanceError);
                // }
            }
            else {
                error = err;
            }
            if (!error.stack) {
                error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);
            }
            if (opt_message) {
                // find the first unoccupied 'messageX' property
                var x = 0;
                while (error['message' + x]) {
                    ++x;
                }
                error['message' + x] = String(opt_message);
            }
            return error;
        }
        debug.enhanceError = enhanceError;
        ;
        /**
         * Converts an object to an Error using the object's toString if it's not
         * already an Error, adds a stacktrace if there isn't one, and optionally adds
         * context to the Error, which is reported by the closure error reporter.
         * @param {*} err The original thrown error, object, or string.
         * @param {!Object<string, string>=} opt_context Key-value context to add to the
         *     Error.
         * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,
         *     it is converted to an Error which is enhanced and returned.
         */
        function enhanceErrorWithContext(err, opt_context) {
            var error = goog.debug.enhanceError(err);
            if (opt_context) {
                for (var key in opt_context) {
                    goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);
                }
            }
            return error;
        }
        debug.enhanceErrorWithContext = enhanceErrorWithContext;
        ;
        /**
         * Gets the current stack trace. Simple and iterative - doesn't worry about
         * catching circular references or getting the args.
         * @param {number=} opt_depth Optional maximum depth to trace back to.
         * @return {string} A string with the function names of all functions in the
         *     stack, separated by \n.
         * @suppress {es5Strict}
         */
        function getStacktraceSimple(opt_depth) {
            if (!goog.debug.FORCE_SLOPPY_STACKS) {
                var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);
                if (stack) {
                    return stack;
                }
                // NOTE: browsers that have strict mode support also have native "stack"
                // properties.  Fall-through for legacy browser support.
            }
            var sb = [];
            var fn = arguments.callee.caller;
            var depth = 0;
            while (fn && (!opt_depth || depth < opt_depth)) {
                sb.push(goog.debug.getFunctionName(fn));
                sb.push('()\n');
                try {
                    fn = fn.caller;
                }
                catch (e) {
                    sb.push('[exception trying to get caller]\n');
                    break;
                }
                depth++;
                if (depth >= goog.debug.MAX_STACK_DEPTH) {
                    sb.push('[...long stack...]');
                    break;
                }
            }
            if (opt_depth && depth >= opt_depth) {
                sb.push('[...reached max depth limit...]');
            }
            else {
                sb.push('[end]');
            }
            return sb.join('');
        }
        debug.getStacktraceSimple = getStacktraceSimple;
        ;
        /**
         * Max length of stack to try and output
         * @type {number}
         */
        debug.MAX_STACK_DEPTH = 50;
        /**
         * @param {Function} fn The function to start getting the trace from.
         * @return {?string}
         * @private
         */
        function getNativeStackTrace_(fn) {
            var tempErr = new debug.Error();
            // Will invoke wrong Error;
            // if (Error.captureStackTrace) {
            //   Error.captureStackTrace(tempErr, fn);
            //   return String(tempErr.stack);
            // }
            // else {
            //   // IE10, only adds stack traces when an exception is thrown.
            //   try {
            //     throw tempErr;
            //   }
            //   catch (e) {
            //     tempErr = e;
            //   }
            //   var stack = tempErr.stack;
            //   if (stack) {
            //     return String(stack);
            //   }
            // }
            return null;
        }
        debug.getNativeStackTrace_ = getNativeStackTrace_;
        ;
        /**
         * Gets the current stack trace, either starting from the caller or starting
         * from a specified function that's currently on the call stack.
         * @param {?Function=} fn If provided, when collecting the stack trace all
         *     frames above the topmost call to this function, including that call,
         *     will be left out of the stack trace.
         * @return {string} Stack trace.
         * @suppress {es5Strict}
         */
        function getStacktrace(fn) {
            var stack;
            if (!goog.debug.FORCE_SLOPPY_STACKS) {
                // Try to get the stack trace from the environment if it is available.
                var contextFn = fn || goog.debug.getStacktrace;
                stack = goog.debug.getNativeStackTrace_(contextFn);
            }
            if (!stack) {
                // NOTE: browsers that have strict mode support also have native "stack"
                // properties. This function will throw in strict mode.
                stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);
            }
            return stack;
        }
        debug.getStacktrace = getStacktrace;
        ;
        /**
         * Private helper for getStacktrace().
         * @param {?Function} fn If provided, when collecting the stack trace all
         *     frames above the topmost call to this function, including that call,
         *     will be left out of the stack trace.
         * @param {Array<!Function>} visited List of functions visited so far.
         * @return {string} Stack trace starting from function fn.
         * @suppress {es5Strict}
         * @private
         */
        function getStacktraceHelper_(fn, visited) {
            var sb = [];
            // Circular reference, certain functions like bind seem to cause a recursive
            // loop so we need to catch circular references
            if (goog.array.contains(visited, fn)) {
                sb.push('[...circular reference...]');
                // Traverse the call stack until function not found or max depth is reached
            }
            else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {
                sb.push(goog.debug.getFunctionName(fn) + '(');
                var args = fn.arguments;
                // Args may be null for some special functions such as host objects or eval.
                for (var i = 0; args && i < args.length; i++) {
                    if (i > 0) {
                        sb.push(', ');
                    }
                    var argDesc;
                    var arg = args[i];
                    switch (typeof arg) {
                        case 'object':
                            argDesc = arg ? 'object' : 'null';
                            break;
                        case 'string':
                            argDesc = arg;
                            break;
                        case 'number':
                            argDesc = String(arg);
                            break;
                        case 'boolean':
                            argDesc = arg ? 'true' : 'false';
                            break;
                        case 'function':
                            argDesc = goog.debug.getFunctionName(arg);
                            argDesc = argDesc ? argDesc : '[fn]';
                            break;
                        case 'undefined':
                        default:
                            argDesc = typeof arg;
                            break;
                    }
                    if (argDesc.length > 40) {
                        argDesc = argDesc.substr(0, 40) + '...';
                    }
                    sb.push(argDesc);
                }
                visited.push(fn);
                sb.push(')\n');
                try {
                    sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));
                }
                catch (e) {
                    sb.push('[exception trying to get caller]\n');
                }
            }
            else if (fn) {
                sb.push('[...long stack...]');
            }
            else {
                sb.push('[end]');
            }
            return sb.join('');
        }
        debug.getStacktraceHelper_ = getStacktraceHelper_;
        ;
        /**
         * Set a custom function name resolver.
         * @param {function(Function): string} resolver Resolves functions to their
         *     names.
         */
        function setFunctionResolver(resolver) {
            goog.debug.fnNameResolver_ = resolver;
        }
        debug.setFunctionResolver = setFunctionResolver;
        ;
        /**
         * Gets a function name
         * @param {Function} fn Function to get name of.
         * @return {string} Function's name.
         */
        function getFunctionName(fn) {
            if (goog.debug.fnNameCache_[fn]) {
                return goog.debug.fnNameCache_[fn];
            }
            if (goog.debug.fnNameResolver_) {
                var name = goog.debug.fnNameResolver_(fn);
                if (name) {
                    goog.debug.fnNameCache_[fn] = name;
                    return name;
                }
            }
            // Heuristically determine function name based on code.
            var functionSource = String(fn);
            if (!goog.debug.fnNameCache_[functionSource]) {
                var matches = /function ([^\(]+)/.exec(functionSource);
                if (matches) {
                    var method = matches[1];
                    goog.debug.fnNameCache_[functionSource] = method;
                }
                else {
                    goog.debug.fnNameCache_[functionSource] = '[Anonymous]';
                }
            }
            return goog.debug.fnNameCache_[functionSource];
        }
        debug.getFunctionName = getFunctionName;
        ;
        /**
         * Makes whitespace visible by replacing it with printable characters.
         * This is useful in finding diffrences between the expected and the actual
         * output strings of a testcase.
         * @param {string} string whose whitespace needs to be made visible.
         * @return {string} string whose whitespace is made visible.
         */
        function makeWhitespaceVisible(string) {
            return string.replace(/ /g, '[_]')
                .replace(/\f/g, '[f]')
                .replace(/\n/g, '[n]\n')
                .replace(/\r/g, '[r]')
                .replace(/\t/g, '[t]');
        }
        debug.makeWhitespaceVisible = makeWhitespaceVisible;
        ;
        /**
         * Returns the type of a value. If a constructor is passed, and a suitable
         * string cannot be found, 'unknown type name' will be returned.
         *
         * <p>Forked rather than moved from {@link goog.asserts.getType_}
         * to avoid adding a dependency to goog.asserts.
         * @param {*} value A constructor, object, or primitive.
         * @return {string} The best display name for the value, or 'unknown type name'.
         */
        function runtimeType(value) {
            if (value instanceof Function) {
                return value.displayName || value.name || 'unknown type name';
            }
            else if (value instanceof Object) {
                return value.constructor.displayName || value.constructor.name ||
                    Object.prototype.toString.call(value);
            }
            else {
                return value === null ? 'null' : typeof value;
            }
        }
        debug.runtimeType = runtimeType;
        ;
        /**
         * Hash map for storing function names that have already been looked up.
         * @type {Object}
         * @private
         */
        debug.fnNameCache_ = {};
        /**
         * Private internal function to support goog.debug.freeze.
         * @param {T} arg
         * @return {T}
         * @template T
         * @private
         */
        function freezeInternal_(arg) {
            if (goog.DEBUG) {
                return Object.freeze(arg);
            }
            else {
                return arg;
            }
        }
        debug.freezeInternal_ = freezeInternal_;
        /**
         * Freezes the given object, but only in debug mode (and in browsers that
         * support it).  Note that this is a shallow freeze, so for deeply nested
         * objects it must be called at every level to ensure deep immutability.
         * @param {T} arg
         * @return {T}
         * @template T
         */
        function freeze(arg) {
            // NOTE: this compiles to nothing, but hides the possible side effect of
            // freezeInternal_ from the compiler so that the entire call can be
            // removed if the result is not used.
            return {
                valueOf: function () {
                    return goog.debug.freezeInternal_(arg);
                }
            }.valueOf();
        }
        debug.freeze = freeze;
        ;
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Browser capability checks for the events package.
 *
 */
goog.provide('goog.events.BrowserFeature');
goog.require('goog.userAgent');
var goog;
(function (goog) {
    var events;
    (function (events) {
        /**
         * Enum of browser capabilities.
         * @enum {boolean}
         */
        events.BrowserFeature = {
            /**
             * Whether the button attribute of the event is W3C compliant.  False in
             * Internet Explorer prior to version 9; document-version dependent.
             */
            HAS_W3C_BUTTON: !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9),
            /**
             * Whether the browser supports full W3C event model.
             */
            HAS_W3C_EVENT_SUPPORT: !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9),
            /**
             * To prevent default in IE7-8 for certain keydown events we need set the
             * keyCode to -1.
             */
            SET_KEY_CODE_TO_PREVENT_DEFAULT: goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9'),
            /**
             * Whether the {@code navigator.onLine} property is supported.
             */
            HAS_NAVIGATOR_ONLINE_PROPERTY: !goog.userAgent.WEBKIT || goog.userAgent.isVersionOrHigher('528'),
            /**
             * Whether HTML5 network online/offline events are supported.
             */
            HAS_HTML5_NETWORK_EVENT_SUPPORT: goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9b') ||
                goog.userAgent.IE && goog.userAgent.isVersionOrHigher('8') ||
                goog.userAgent.OPERA && goog.userAgent.isVersionOrHigher('9.5') ||
                goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher('528'),
            /**
             * Whether HTML5 network events fire on document.body, or otherwise the
             * window.
             */
            HTML5_NETWORK_EVENTS_FIRE_ON_BODY: goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher('8') ||
                goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9'),
            /**
             * Whether touch is enabled in the browser.
             */
            TOUCH_ENABLED: ('ontouchstart' in goog.global ||
                !!(goog.global['document'] && document.documentElement &&
                    'ontouchstart' in document.documentElement) ||
                // IE10 uses non-standard touch events, so it has a different check.
                !!(goog.global['navigator'] &&
                    (goog.global['navigator']['maxTouchPoints'] ||
                        goog.global['navigator']['msMaxTouchPoints']))),
            /**
             * Whether addEventListener supports W3C standard pointer events.
             * http://www.w3.org/TR/pointerevents/
             */
            POINTER_EVENTS: ('PointerEvent' in goog.global),
            /**
             * Whether addEventListener supports MSPointer events (only used in IE10).
             * http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx
             * http://msdn.microsoft.com/library/hh673557(v=vs.85).aspx
             */
            MSPOINTER_EVENTS: ('MSPointerEvent' in goog.global &&
                !!(goog.global['navigator'] &&
                    goog.global['navigator']['msPointerEnabled'])),
            /**
             * Whether addEventListener supports {passive: true}.
             * https://developers.google.com/web/updates/2016/06/passive-event-listeners
             */
            PASSIVE_EVENTS: purify(function () {
                // If we're in a web worker or other custom environment, we can't tell.
                if (!goog.global.addEventListener || !Object.defineProperty) {
                    return false;
                }
                var passive = false;
                var options = Object.defineProperty({}, 'passive', {
                    get: function () {
                        passive = true;
                    }
                });
                goog.global.addEventListener('test', goog.nullFunction, options);
                goog.global.removeEventListener('test', goog.nullFunction, options);
                return passive;
            })
        };
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
/**
 * Tricks Closure Compiler into believing that a function is pure.  The compiler
 * assumes that any `valueOf` function is pure, without analyzing its contents.
 *
 * @param {function(): T} fn
 * @return {T}
 * @template T
 */
function purify(fn) {
    return ({ valueOf: fn }).valueOf();
}
/**
 * The content of this class should be put in goog.scope
 */
goog.scope(function () {
}); // goog.scope
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Event Types.
 *
 * @author arv@google.com (Erik Arvidsson)
 */
goog.provide('goog.events.EventType');
goog.provide('goog.events.PointerFallbackEventType');
goog.require('goog.events.BrowserFeature');
goog.require('goog.userAgent');
var goog;
(function (goog) {
    var events;
    (function (events) {
        /**
         * Returns a prefixed event name for the current browser.
         * @param {string} eventName The name of the event.
         * @return {string} The prefixed event name.
         * @suppress {missingRequire|missingProvide}
         * @private
         */
        function getVendorPrefixedName_(eventName) {
            return goog.userAgent.WEBKIT ?
                'webkit' + eventName :
                (goog.userAgent.OPERA ? 'o' + eventName.toLowerCase() :
                    eventName.toLowerCase());
        }
        events.getVendorPrefixedName_ = getVendorPrefixedName_;
        ;
        /**
         * Constants for event names.
         * @enum {string}
         */
        events.EventType = {
            // Mouse events
            CLICK: 'click',
            RIGHTCLICK: 'rightclick',
            DBLCLICK: 'dblclick',
            MOUSEDOWN: 'mousedown',
            MOUSEUP: 'mouseup',
            MOUSEOVER: 'mouseover',
            MOUSEOUT: 'mouseout',
            MOUSEMOVE: 'mousemove',
            MOUSEENTER: 'mouseenter',
            MOUSELEAVE: 'mouseleave',
            // Selection events.
            // https://www.w3.org/TR/selection-api/
            SELECTIONCHANGE: 'selectionchange',
            SELECTSTART: 'selectstart',
            // Wheel events
            // http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
            WHEEL: 'wheel',
            // Key events
            KEYPRESS: 'keypress',
            KEYDOWN: 'keydown',
            KEYUP: 'keyup',
            // Focus
            BLUR: 'blur',
            FOCUS: 'focus',
            DEACTIVATE: 'deactivate',
            FOCUSIN: 'focusin',
            FOCUSOUT: 'focusout',
            // Forms
            CHANGE: 'change',
            RESET: 'reset',
            SELECT: 'select',
            SUBMIT: 'submit',
            INPUT: 'input',
            PROPERTYCHANGE: 'propertychange',
            // Drag and drop
            DRAGSTART: 'dragstart',
            DRAG: 'drag',
            DRAGENTER: 'dragenter',
            DRAGOVER: 'dragover',
            DRAGLEAVE: 'dragleave',
            DROP: 'drop',
            DRAGEND: 'dragend',
            // Touch events
            // Note that other touch events exist, but we should follow the W3C list here.
            // http://www.w3.org/TR/touch-events/#list-of-touchevent-types
            TOUCHSTART: 'touchstart',
            TOUCHMOVE: 'touchmove',
            TOUCHEND: 'touchend',
            TOUCHCANCEL: 'touchcancel',
            // Misc
            BEFOREUNLOAD: 'beforeunload',
            CONSOLEMESSAGE: 'consolemessage',
            CONTEXTMENU: 'contextmenu',
            DEVICEMOTION: 'devicemotion',
            DEVICEORIENTATION: 'deviceorientation',
            DOMCONTENTLOADED: 'DOMContentLoaded',
            ERROR: 'error',
            HELP: 'help',
            LOAD: 'load',
            LOSECAPTURE: 'losecapture',
            ORIENTATIONCHANGE: 'orientationchange',
            READYSTATECHANGE: 'readystatechange',
            RESIZE: 'resize',
            SCROLL: 'scroll',
            UNLOAD: 'unload',
            // Media events
            CANPLAY: 'canplay',
            CANPLAYTHROUGH: 'canplaythrough',
            DURATIONCHANGE: 'durationchange',
            EMPTIED: 'emptied',
            ENDED: 'ended',
            LOADEDDATA: 'loadeddata',
            LOADEDMETADATA: 'loadedmetadata',
            PAUSE: 'pause',
            PLAY: 'play',
            PLAYING: 'playing',
            RATECHANGE: 'ratechange',
            SEEKED: 'seeked',
            SEEKING: 'seeking',
            STALLED: 'stalled',
            SUSPEND: 'suspend',
            TIMEUPDATE: 'timeupdate',
            VOLUMECHANGE: 'volumechange',
            WAITING: 'waiting',
            // Media Source Extensions events
            // https://www.w3.org/TR/media-source/#mediasource-events
            SOURCEOPEN: 'sourceopen',
            SOURCEENDED: 'sourceended',
            SOURCECLOSED: 'sourceclosed',
            // https://www.w3.org/TR/media-source/#sourcebuffer-events
            ABORT: 'abort',
            UPDATE: 'update',
            UPDATESTART: 'updatestart',
            UPDATEEND: 'updateend',
            // HTML 5 History events
            // See http://www.w3.org/TR/html5/browsers.html#event-definitions-0
            HASHCHANGE: 'hashchange',
            PAGEHIDE: 'pagehide',
            PAGESHOW: 'pageshow',
            POPSTATE: 'popstate',
            // Copy and Paste
            // Support is limited. Make sure it works on your favorite browser
            // before using.
            // http://www.quirksmode.org/dom/events/cutcopypaste.html
            COPY: 'copy',
            PASTE: 'paste',
            CUT: 'cut',
            BEFORECOPY: 'beforecopy',
            BEFORECUT: 'beforecut',
            BEFOREPASTE: 'beforepaste',
            // HTML5 online/offline events.
            // http://www.w3.org/TR/offline-webapps/#related
            ONLINE: 'online',
            OFFLINE: 'offline',
            // HTML 5 worker events
            MESSAGE: 'message',
            CONNECT: 'connect',
            // Service Worker Events - ServiceWorkerGlobalScope context
            // See https://w3c.github.io/ServiceWorker/#execution-context-events
            // Note: message event defined in worker events section
            INSTALL: 'install',
            ACTIVATE: 'activate',
            FETCH: 'fetch',
            FOREIGNFETCH: 'foreignfetch',
            MESSAGEERROR: 'messageerror',
            // Service Worker Events - Document context
            // See https://w3c.github.io/ServiceWorker/#document-context-events
            STATECHANGE: 'statechange',
            UPDATEFOUND: 'updatefound',
            CONTROLLERCHANGE: 'controllerchange',
            // CSS animation events.
            /** @suppress {missingRequire} */
            ANIMATIONSTART: goog.events.getVendorPrefixedName_('AnimationStart'),
            /** @suppress {missingRequire} */
            ANIMATIONEND: goog.events.getVendorPrefixedName_('AnimationEnd'),
            /** @suppress {missingRequire} */
            ANIMATIONITERATION: goog.events.getVendorPrefixedName_('AnimationIteration'),
            // CSS transition events. Based on the browser support described at:
            // https://developer.mozilla.org/en/css/css_transitions#Browser_compatibility
            /** @suppress {missingRequire} */
            TRANSITIONEND: goog.events.getVendorPrefixedName_('TransitionEnd'),
            // W3C Pointer Events
            // http://www.w3.org/TR/pointerevents/
            POINTERDOWN: 'pointerdown',
            POINTERUP: 'pointerup',
            POINTERCANCEL: 'pointercancel',
            POINTERMOVE: 'pointermove',
            POINTEROVER: 'pointerover',
            POINTEROUT: 'pointerout',
            POINTERENTER: 'pointerenter',
            POINTERLEAVE: 'pointerleave',
            GOTPOINTERCAPTURE: 'gotpointercapture',
            LOSTPOINTERCAPTURE: 'lostpointercapture',
            // IE specific events.
            // See http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx
            // Note: these events will be supplanted in IE11.
            MSGESTURECHANGE: 'MSGestureChange',
            MSGESTUREEND: 'MSGestureEnd',
            MSGESTUREHOLD: 'MSGestureHold',
            MSGESTURESTART: 'MSGestureStart',
            MSGESTURETAP: 'MSGestureTap',
            MSGOTPOINTERCAPTURE: 'MSGotPointerCapture',
            MSINERTIASTART: 'MSInertiaStart',
            MSLOSTPOINTERCAPTURE: 'MSLostPointerCapture',
            MSPOINTERCANCEL: 'MSPointerCancel',
            MSPOINTERDOWN: 'MSPointerDown',
            MSPOINTERENTER: 'MSPointerEnter',
            MSPOINTERHOVER: 'MSPointerHover',
            MSPOINTERLEAVE: 'MSPointerLeave',
            MSPOINTERMOVE: 'MSPointerMove',
            MSPOINTEROUT: 'MSPointerOut',
            MSPOINTEROVER: 'MSPointerOver',
            MSPOINTERUP: 'MSPointerUp',
            // Native IMEs/input tools events.
            TEXT: 'text',
            // The textInput event is supported in IE9+, but only in lower case. All other
            // browsers use the camel-case event name.
            TEXTINPUT: goog.userAgent.IE ? 'textinput' : 'textInput',
            COMPOSITIONSTART: 'compositionstart',
            COMPOSITIONUPDATE: 'compositionupdate',
            COMPOSITIONEND: 'compositionend',
            // The beforeinput event is initially only supported in Safari. See
            // https://bugs.chromium.org/p/chromium/issues/detail?id=342670 for Chrome
            // implementation tracking.
            BEFOREINPUT: 'beforeinput',
            // Webview tag events
            // See http://developer.chrome.com/dev/apps/webview_tag.html
            EXIT: 'exit',
            LOADABORT: 'loadabort',
            LOADCOMMIT: 'loadcommit',
            LOADREDIRECT: 'loadredirect',
            LOADSTART: 'loadstart',
            LOADSTOP: 'loadstop',
            RESPONSIVE: 'responsive',
            SIZECHANGED: 'sizechanged',
            UNRESPONSIVE: 'unresponsive',
            // HTML5 Page Visibility API.  See details at
            // {@code goog.labs.dom.PageVisibilityMonitor}.
            VISIBILITYCHANGE: 'visibilitychange',
            // LocalStorage event.
            STORAGE: 'storage',
            // DOM Level 2 mutation events (deprecated).
            DOMSUBTREEMODIFIED: 'DOMSubtreeModified',
            DOMNODEINSERTED: 'DOMNodeInserted',
            DOMNODEREMOVED: 'DOMNodeRemoved',
            DOMNODEREMOVEDFROMDOCUMENT: 'DOMNodeRemovedFromDocument',
            DOMNODEINSERTEDINTODOCUMENT: 'DOMNodeInsertedIntoDocument',
            DOMATTRMODIFIED: 'DOMAttrModified',
            DOMCHARACTERDATAMODIFIED: 'DOMCharacterDataModified',
            // Print events.
            BEFOREPRINT: 'beforeprint',
            AFTERPRINT: 'afterprint',
            // Web app manifest events.
            BEFOREINSTALLPROMPT: 'beforeinstallprompt',
            APPINSTALLED: 'appinstalled'
        };
        /**
         * Returns one of the given pointer fallback event names in order of preference:
         *   1. pointerEventName
         *   2. msPointerEventName
         *   3. mouseEventName
         * @param {string} pointerEventName
         * @param {string} msPointerEventName
         * @param {string} mouseEventName
         * @return {string} The supported pointer or mouse event name.
         * @private
         */
        function getPointerFallbackEventName_(pointerEventName, msPointerEventName, mouseEventName) {
            if (goog.events.BrowserFeature.POINTER_EVENTS) {
                return pointerEventName;
            }
            if (goog.events.BrowserFeature.MSPOINTER_EVENTS) {
                return msPointerEventName;
            }
            return mouseEventName;
        }
        events.getPointerFallbackEventName_ = getPointerFallbackEventName_;
        ;
        /**
         * Constants for pointer event names that fall back to corresponding mouse event
         * names on unsupported platforms. These are intended to be drop-in replacements
         * for corresponding values in {@code goog.events.EventType}.
         * @enum {string}
         */
        events.PointerFallbackEventType = {
            POINTERDOWN: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERDOWN, goog.events.EventType.MSPOINTERDOWN, goog.events.EventType.MOUSEDOWN),
            POINTERUP: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERUP, goog.events.EventType.MSPOINTERUP, goog.events.EventType.MOUSEUP),
            POINTERCANCEL: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERCANCEL, goog.events.EventType.MSPOINTERCANCEL, 
            // When falling back to mouse events, there is no MOUSECANCEL equivalent
            // of POINTERCANCEL. In this case POINTERUP already falls back to MOUSEUP
            // which represents both UP and CANCEL. POINTERCANCEL does not fall back
            // to MOUSEUP to prevent listening twice on the same event.
            'mousecancel'),
            POINTERMOVE: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERMOVE, goog.events.EventType.MSPOINTERMOVE, goog.events.EventType.MOUSEMOVE),
            POINTEROVER: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTEROVER, goog.events.EventType.MSPOINTEROVER, goog.events.EventType.MOUSEOVER),
            POINTEROUT: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTEROUT, goog.events.EventType.MSPOINTEROUT, goog.events.EventType.MOUSEOUT),
            POINTERENTER: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERENTER, goog.events.EventType.MSPOINTERENTER, goog.events.EventType.MOUSEENTER),
            POINTERLEAVE: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERLEAVE, goog.events.EventType.MSPOINTERLEAVE, goog.events.EventType.MOUSELEAVE)
        };
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
/// <reference path="./event.ts" />
/// <reference path="../debug/debug" />
/// <reference path="../events/BrowserFeature" />
/// <reference path="../events/Event" />
/// <reference path="../events/EventType" />
/// <reference path="../reflect/reflect" />
/// <reference path="../userAgent/useragent" />
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A patched, standardized event object for browser events.
 *
 * <pre>
 * The patched event object contains the following members:
 * - type           {string}    Event type, e.g. 'click'
 * - target         {Object}    The element that actually triggered the event
 * - currentTarget  {Object}    The element the listener is attached to
 * - relatedTarget  {Object}    For mouseover and mouseout, the previous object
 * - offsetX        {number}    X-coordinate relative to target
 * - offsetY        {number}    Y-coordinate relative to target
 * - clientX        {number}    X-coordinate relative to viewport
 * - clientY        {number}    Y-coordinate relative to viewport
 * - screenX        {number}    X-coordinate relative to the edge of the screen
 * - screenY        {number}    Y-coordinate relative to the edge of the screen
 * - button         {number}    Mouse button. Use isButton() to test.
 * - keyCode        {number}    Key-code
 * - ctrlKey        {boolean}   Was ctrl key depressed
 * - altKey         {boolean}   Was alt key depressed
 * - shiftKey       {boolean}   Was shift key depressed
 * - metaKey        {boolean}   Was meta key depressed
 * - pointerId      {number}    Pointer ID
 * - pointerType    {string}    Pointer type, e.g. 'mouse', 'pen', or 'touch'
 * - defaultPrevented {boolean} Whether the default action has been prevented
 * - state          {Object}    History state object
 *
 * NOTE: The keyCode member contains the raw browser keyCode. For normalized
 * key and character code use {@link goog.events.KeyHandler}.
 * </pre>
 *
 * @author arv@google.com (Erik Arvidsson)
 */
goog.provide('goog.events.BrowserEvent');
goog.provide('goog.events.BrowserEvent.MouseButton');
goog.provide('goog.events.BrowserEvent.PointerType');
goog.require('goog.debug');
goog.require('goog.events.BrowserFeature');
goog.require('goog.events.Event');
goog.require('goog.events.EventType');
goog.require('goog.reflect');
goog.require('goog.userAgent');
var goog;
(function (goog) {
    var events;
    (function (events) {
        var BrowserEvent = /** @class */ (function (_super) {
            __extends(BrowserEvent, _super);
            /**
             * Accepts a browser event object and creates a patched, cross browser event
             * object.
             * The content of this object will not be initialized if no event object is
             * provided. If this is the case, init() needs to be invoked separately.
             * @param {Event=} opt_e Browser event object.
             * @param {EventTarget=} opt_currentTarget Current target for event.
             * @constructor
             * @extends {goog.events.Event}
             */
            function BrowserEvent(opt_e, opt_currentTarget) {
                var _this = _super.call(this, opt_e ? opt_e.type : '') || this;
                // goog.events.BrowserEvent.base(this, 'constructor', opt_e ? opt_e.type : '');
                /**
                 * Target that fired the event.
                 * @override
                 * @type {Node}
                 */
                _this.target = null;
                /**
                 * Node that had the listener attached.
                 * @override
                 * @type {Node|undefined}
                 */
                _this.currentTarget = null;
                /**
                 * For mouseover and mouseout events, the related object for the event.
                 * @type {Node}
                 */
                _this.relatedTarget = null;
                /**
                 * X-coordinate relative to target.
                 * @type {number}
                 */
                _this.offsetX = 0;
                /**
                 * Y-coordinate relative to target.
                 * @type {number}
                 */
                _this.offsetY = 0;
                /**
                 * X-coordinate relative to the window.
                 * @type {number}
                 */
                _this.clientX = 0;
                /**
                 * Y-coordinate relative to the window.
                 * @type {number}
                 */
                _this.clientY = 0;
                /**
                 * X-coordinate relative to the monitor.
                 * @type {number}
                 */
                _this.screenX = 0;
                /**
                 * Y-coordinate relative to the monitor.
                 * @type {number}
                 */
                _this.screenY = 0;
                /**
                 * Which mouse button was pressed.
                 * @type {number}
                 */
                _this.button = 0;
                /**
                 * Key of key press.
                 * @type {string}
                 */
                _this.key = '';
                /**
                 * Keycode of key press.
                 * @type {number}
                 */
                _this.keyCode = 0;
                /**
                 * Keycode of key press.
                 * @type {number}
                 */
                _this.charCode = 0;
                /**
                 * Whether control was pressed at time of event.
                 * @type {boolean}
                 */
                _this.ctrlKey = false;
                /**
                 * Whether alt was pressed at time of event.
                 * @type {boolean}
                 */
                _this.altKey = false;
                /**
                 * Whether shift was pressed at time of event.
                 * @type {boolean}
                 */
                _this.shiftKey = false;
                /**
                 * Whether the meta key was pressed at time of event.
                 * @type {boolean}
                 */
                _this.metaKey = false;
                /**
                 * History state object, only set for PopState events where it's a copy of the
                 * state object provided to pushState or replaceState.
                 * @type {Object}
                 */
                _this.state = null;
                /**
                 * Whether the default platform modifier key was pressed at time of event.
                 * (This is control for all platforms except Mac, where it's Meta.)
                 * @type {boolean}
                 */
                _this.platformModifierKey = false;
                /**
                 * @type {number}
                 */
                _this.pointerId = 0;
                /**
                 * @type {string}
                 */
                _this.pointerType = '';
                /**
                 * The browser event object.
                 * @private {Event}
                 */
                _this.event_ = null;
                if (opt_e) {
                    _this.init(opt_e, opt_currentTarget);
                }
                return _this;
            }
            /**
             * Accepts a browser event object and creates a patched, cross browser event
             * object.
             * @param {Event} e Browser event object.
             * @param {EventTarget=} opt_currentTarget Current target for event.
             */
            BrowserEvent.prototype.init = function (e, opt_currentTarget) {
                var type = this.type = e.type;
                /**
                 * On touch devices use the first "changed touch" as the relevant touch.
                 * @type {Touch}
                 */
                var relevantTouch = e.changedTouches ? e.changedTouches[0] : null;
                // TODO(nicksantos): Change this.target to type EventTarget.
                this.target = /** @type {Node} */ (e.target) || e.srcElement;
                // TODO(nicksantos): Change this.currentTarget to type EventTarget.
                this.currentTarget = /** @type {Node} */ (opt_currentTarget);
                var relatedTarget = (e.relatedTarget);
                if (relatedTarget) {
                    // There's a bug in FireFox where sometimes, relatedTarget will be a
                    // chrome element, and accessing any property of it will get a permission
                    // denied exception. See:
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=497780
                    if (goog.userAgent.GECKO) {
                        if (!goog.reflect.canAccessProperty(relatedTarget, 'nodeName')) {
                            relatedTarget = null;
                        }
                    }
                }
                else if (type == goog.events.EventType.MOUSEOVER) {
                    relatedTarget = e.fromElement;
                }
                else if (type == goog.events.EventType.MOUSEOUT) {
                    relatedTarget = e.toElement;
                }
                this.relatedTarget = relatedTarget;
                if (!goog.isNull(relevantTouch)) {
                    this.clientX = relevantTouch.clientX !== undefined ? relevantTouch.clientX :
                        relevantTouch.pageX;
                    this.clientY = relevantTouch.clientY !== undefined ? relevantTouch.clientY :
                        relevantTouch.pageY;
                    this.screenX = relevantTouch.screenX || 0;
                    this.screenY = relevantTouch.screenY || 0;
                }
                else {
                    // Webkit emits a lame warning whenever layerX/layerY is accessed.
                    // http://code.google.com/p/chromium/issues/detail?id=101733
                    this.offsetX = (goog.userAgent.WEBKIT || e.offsetX !== undefined) ?
                        e.offsetX :
                        e.layerX;
                    this.offsetY = (goog.userAgent.WEBKIT || e.offsetY !== undefined) ?
                        e.offsetY :
                        e.layerY;
                    this.clientX = e.clientX !== undefined ? e.clientX : e.pageX;
                    this.clientY = e.clientY !== undefined ? e.clientY : e.pageY;
                    this.screenX = e.screenX || 0;
                    this.screenY = e.screenY || 0;
                }
                this.button = e.button;
                this.keyCode = e.keyCode || 0;
                this.key = e.key || '';
                this.charCode = e.charCode || (type == 'keypress' ? e.keyCode : 0);
                this.ctrlKey = e.ctrlKey;
                this.altKey = e.altKey;
                this.shiftKey = e.shiftKey;
                this.metaKey = e.metaKey;
                this.platformModifierKey = goog.userAgent.MAC ? e.metaKey : e.ctrlKey;
                this.pointerId = e.pointerId || 0;
                this.pointerType = goog.events.BrowserEvent.getPointerType_(e);
                this.state = e.state;
                this.event_ = e;
                if (e.defaultPrevented) {
                    this.preventDefault();
                }
            };
            ;
            /**
             * Tests to see which button was pressed during the event. This is really only
             * useful in IE and Gecko browsers. And in IE, it's only useful for
             * mousedown/mouseup events, because click only fires for the left mouse button.
             *
             * Safari 2 only reports the left button being clicked, and uses the value '1'
             * instead of 0. Opera only reports a mousedown event for the middle button, and
             * no mouse events for the right button. Opera has default behavior for left and
             * middle click that can only be overridden via a configuration setting.
             *
             * There's a nice table of this mess at http://www.unixpapa.com/js/mouse.html.
             *
             * @param {goog.events.BrowserEvent.MouseButton} button The button
             *     to test for.
             * @return {boolean} True if button was pressed.
             */
            BrowserEvent.prototype.isButton = function (button) {
                if (!goog.events.BrowserFeature.HAS_W3C_BUTTON) {
                    if (this.type == 'click') {
                        return button == goog.events.BrowserEvent.MouseButton.LEFT;
                    }
                    else {
                        return !!(this.event_.button & goog.events.BrowserEvent.IE_BUTTON_MAP[button]);
                    }
                }
                else {
                    return this.event_.button == button;
                }
            };
            ;
            /**
             * Whether this has an "action"-producing mouse button.
             *
             * By definition, this includes left-click on windows/linux, and left-click
             * without the ctrl key on Macs.
             *
             * @return {boolean} The result.
             */
            BrowserEvent.prototype.isMouseActionButton = function () {
                // Webkit does not ctrl+click to be a right-click, so we
                // normalize it to behave like Gecko and Opera.
                return this.isButton(goog.events.BrowserEvent.MouseButton.LEFT) &&
                    !(goog.userAgent.WEBKIT && goog.userAgent.MAC && this.ctrlKey);
            };
            ;
            /**
             * @override
             */
            BrowserEvent.prototype.stopPropagation = function () {
                _super.prototype.stopPropagation.call(this);
                // goog.events.BrowserEvent.superClass_.stopPropagation.call(this);
                if (this.event_.stopPropagation) {
                    this.event_.stopPropagation();
                }
                else {
                    this.event_.cancelBubble = true;
                }
            };
            ;
            /**
             * @override
             */
            BrowserEvent.prototype.preventDefault = function () {
                _super.prototype.preventDefault.call(this);
                // goog.events.BrowserEvent.superClass_.preventDefault.call(this);
                var be = this.event_;
                if (!be.preventDefault) {
                    be.returnValue = false;
                    if (goog.events.BrowserFeature.SET_KEY_CODE_TO_PREVENT_DEFAULT) {
                        try {
                            // Most keys can be prevented using returnValue. Some special keys
                            // require setting the keyCode to -1 as well:
                            //
                            // In IE7:
                            // F3, F5, F10, F11, Ctrl+P, Crtl+O, Ctrl+F (these are taken from IE6)
                            //
                            // In IE8:
                            // Ctrl+P, Crtl+O, Ctrl+F (F1-F12 cannot be stopped through the event)
                            //
                            // We therefore do this for all function keys as well as when Ctrl key
                            // is pressed.
                            var VK_F1 = 112;
                            var VK_F12 = 123;
                            if (be.ctrlKey || be.keyCode >= VK_F1 && be.keyCode <= VK_F12) {
                                be.keyCode = -1;
                            }
                        }
                        catch (ex) {
                            // IE throws an 'access denied' exception when trying to change
                            // keyCode in some situations (e.g. srcElement is input[type=file],
                            // or srcElement is an anchor tag rewritten by parent's innerHTML).
                            // Do nothing in this case.
                        }
                    }
                }
                else {
                    be.preventDefault();
                }
            };
            ;
            /**
             * @return {Event} The underlying browser event object.
             */
            BrowserEvent.prototype.getBrowserEvent = function () {
                return this.event_;
            };
            ;
            return BrowserEvent;
        }(goog.events.Event));
        events.BrowserEvent = BrowserEvent;
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
(function (goog) {
    var events;
    (function (events) {
        var BrowserEvent;
        (function (BrowserEvent) {
            /**
             * Normalized button constants for the mouse.
             * @enum {number}
             */
            var MouseButton;
            (function (MouseButton) {
                MouseButton[MouseButton["LEFT"] = 0] = "LEFT";
                MouseButton[MouseButton["MIDDLE"] = 1] = "MIDDLE";
                MouseButton[MouseButton["RIGHT"] = 2] = "RIGHT";
            })(MouseButton = BrowserEvent.MouseButton || (BrowserEvent.MouseButton = {}));
            ;
            /**
             * Normalized pointer type constants for pointer events.
             * @enum {string}
             */
            var PointerType;
            (function (PointerType) {
                PointerType["MOUSE"] = "mouse";
                PointerType["PEN"] = "pen";
                PointerType["TOUCH"] = "touch";
            })(PointerType = BrowserEvent.PointerType || (BrowserEvent.PointerType = {}));
            ;
            /**
             * Static data for mapping mouse buttons.
             * @type {!Array<number>}
             * @deprecated Use {@code goog.events.BrowserEvent.IE_BUTTON_MAP} instead.
             */
            BrowserEvent.IEButtonMap = goog.debug.freeze([
                1,
                4,
                2 // RIGHT
            ]);
            /**
             * Static data for mapping mouse buttons.
             * @const {!Array<number>}
             */
            BrowserEvent.IE_BUTTON_MAP = goog.events.BrowserEvent.IEButtonMap;
            /**
             * Static data for mapping MSPointerEvent types to PointerEvent types.
             * @const {!Object<number, goog.events.BrowserEvent.PointerType>}
             */
            BrowserEvent.IE_POINTER_TYPE_MAP = goog.debug.freeze({
                2: goog.events.BrowserEvent.PointerType.TOUCH,
                3: goog.events.BrowserEvent.PointerType.PEN,
                4: goog.events.BrowserEvent.PointerType.MOUSE
            });
            /**
             * Extracts the pointer type from the given event.
             * @param {!Event} e
             * @return {string} The pointer type, e.g. 'mouse', 'pen', or 'touch'.
             * @private
             */
            function getPointerType_(e) {
                if (goog.isString(e.pointerType)) {
                    return e.pointerType;
                }
                // IE10 uses integer codes for pointer type.
                // https://msdn.microsoft.com/en-us/library/hh772359(v=vs.85).aspx
                return goog.events.BrowserEvent.IE_POINTER_TYPE_MAP[e.pointerType] || '';
            }
            BrowserEvent.getPointerType_ = getPointerType_;
            ;
        })(BrowserEvent = events.BrowserEvent || (events.BrowserEvent = {}));
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview An interface for a listenable JavaScript object.
 * @author chrishenry@google.com (Chris Henry)
 */
goog.provide('goog.events.Listenable');
goog.provide('goog.events.ListenableKey');
/** @suppress {extraRequire} */
goog.require('goog.events.EventId');
goog.forwardDeclare('goog.events.EventLike');
goog.forwardDeclare('goog.events.EventTarget');
var goog;
(function (goog) {
    var events;
    (function (events) {
        var Listenable;
        (function (Listenable) {
            /**
             * An expando property to indicate that an object implements
             * goog.events.Listenable.
             *
             * See addImplementation/isImplementedBy.
             *
             * @type {string}
             * @const
             */
            Listenable.IMPLEMENTED_BY_PROP = 'closure_listenable_' + ((Math.random() * 1e6) | 0);
            /**
             * Marks a given class (constructor) as an implementation of
             * Listenable, do that we can query that fact at runtime. The class
             * must have already implemented the interface.
             * @param {!function(new:goog.events.Listenable,...)} cls The class constructor.
             *     The corresponding class must have already implemented the interface.
             */
            function addImplementation(cls) {
                cls.prototype[goog.events.Listenable.IMPLEMENTED_BY_PROP] = true;
            }
            Listenable.addImplementation = addImplementation;
            ;
            /**
             * @param {Object} obj The object to check.
             * @return {boolean} Whether a given instance implements Listenable. The
             *     class/superclass of the instance must call addImplementation.
             */
            function isImplementedBy(obj) {
                return !!(obj && obj[goog.events.Listenable.IMPLEMENTED_BY_PROP]);
            }
            Listenable.isImplementedBy = isImplementedBy;
            ;
        })(Listenable = events.Listenable || (events.Listenable = {}));
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
(function (goog) {
    var events;
    (function (events) {
        var ListenableKey;
        (function (ListenableKey) {
            /**
             * Counter used to create a unique key
             * @type {number}
             * @private
             */
            ListenableKey.counter_ = 0;
            /**
             * Reserves a key to be used for ListenableKey#key field.
             * @return {number} A number to be used to fill ListenableKey#key
             *     field.
             */
            function reserveKey() {
                return ++goog.events.ListenableKey.counter_;
            }
            ListenableKey.reserveKey = reserveKey;
            ;
        })(ListenableKey = events.ListenableKey || (events.ListenableKey = {}));
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Listener object.
 * @see ../demos/events.html
 */
goog.provide('goog.events.Listener');
goog.require('goog.events.ListenableKey');
var goog;
(function (goog) {
    var events;
    (function (events) {
        var Listener = /** @class */ (function () {
            /**
             * Simple class that stores information about a listener
             * @param {function(?):?} listener Callback function.
             * @param {Function} proxy Wrapper for the listener that patches the event.
             * @param {EventTarget|goog.events.Listenable} src Source object for
             *     the event.
             * @param {string} type Event type.
             * @param {boolean} capture Whether in capture or bubble phase.
             * @param {Object=} opt_handler Object in whose context to execute the callback.
             * @implements {goog.events.ListenableKey}
             * @constructor
             */
            function Listener(listener, proxy, src, type, capture, opt_handler) {
                if (goog.events.Listener.ENABLE_MONITORING) {
                    this.creationStack = new Error().stack;
                }
                /** @override */
                this.listener = listener;
                /**
                 * A wrapper over the original listener. This is used solely to
                 * handle native browser events (it is used to simulate the capture
                 * phase and to patch the event object).
                 * @type {Function}
                 */
                this.proxy = proxy;
                /**
                 * Object or node that callback is listening to
                 * @type {EventTarget|goog.events.Listenable}
                 */
                this.src = src;
                /**
                 * The event type.
                 * @const {string}
                 */
                this.type = type;
                /**
                 * Whether the listener is being called in the capture or bubble phase
                 * @const {boolean}
                 */
                this.capture = !!capture;
                /**
                 * Optional object whose context to execute the listener in
                 * @type {Object|undefined}
                 */
                this.handler = opt_handler;
                /**
                 * The key of the listener.
                 * @const {number}
                 * @override
                 */
                this.key = goog.events.ListenableKey.reserveKey();
                /**
                 * Whether to remove the listener after it has been called.
                 * @type {boolean}
                 */
                this.callOnce = false;
                /**
                 * Whether the listener has been removed.
                 * @type {boolean}
                 */
                this.removed = false;
            }
            /**
             * Marks this listener as removed. This also remove references held by
             * this listener object (such as listener and event source).
             */
            Listener.prototype.markAsRemoved = function () {
                this.removed = true;
                this.listener = null;
                this.proxy = null;
                this.src = null;
                this.handler = null;
            };
            ;
            return Listener;
        }());
        events.Listener = Listener;
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
(function (goog) {
    var events;
    (function (events) {
        var Listener;
        (function (Listener) {
            Listener.ENABLE_MONITORING = false;
        })(Listener = events.Listener || (events.Listener = {}));
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
/**
 * @define {boolean} Whether to enable the monitoring of the
 *     goog.events.Listener instances. Switching on the monitoring is only
 *     recommended for debugging because it has a significant impact on
 *     performance and memory usage. If switched off, the monitoring code
 *     compiles down to 0 bytes.
 */
goog.define('goog.events.Listener.ENABLE_MONITORING', false);
/// <reference path="../array/array" />
/// <reference path="../events/Listener" />
/// <reference path="../object/object" />
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A map of listeners that provides utility functions to
 * deal with listeners on an event target. Used by
 * {@code goog.events.EventTarget}.
 *
 * WARNING: Do not use this class from outside goog.events package.
 *
 * @visibility {//closure/goog/bin/sizetests:__pkg__}
 * @visibility {//closure/goog:__pkg__}
 * @visibility {//closure/goog/events:__pkg__}
 * @visibility {//closure/goog/labs/events:__pkg__}
 */
goog.provide('goog.events.ListenerMap');
goog.require('goog.array');
goog.require('goog.events.Listener');
goog.require('goog.object');
var goog;
(function (goog) {
    var events;
    (function (events) {
        var ListenerMap = /** @class */ (function () {
            /**
             * Creates a new listener map.
             * @param {EventTarget|goog.events.Listenable} src The src object.
             * @constructor
             * @final
             */
            function ListenerMap(src) {
                /** @type {EventTarget|goog.events.Listenable} */
                this.src = src;
                /**
                 * Maps of event type to an array of listeners.
                 * @type {!Object<string, !Array<!goog.events.Listener>>}
                 */
                this.listeners = {};
                /**
                 * The count of types in this map that have registered listeners.
                 * @private {number}
                 */
                this.typeCount_ = 0;
            }
            /**
             * @return {number} The count of event types in this map that actually
             *     have registered listeners.
             */
            ListenerMap.prototype.getTypeCount = function () {
                return this.typeCount_;
            };
            ;
            /**
             * @return {number} Total number of registered listeners.
             */
            ListenerMap.prototype.getListenerCount = function () {
                var count = 0;
                for (var type in this.listeners) {
                    count += this.listeners[type].length;
                }
                return count;
            };
            ;
            /**
             * Adds an event listener. A listener can only be added once to an
             * object and if it is added again the key for the listener is
             * returned.
             *
             * Note that a one-off listener will not change an existing listener,
             * if any. On the other hand a normal listener will change existing
             * one-off listener to become a normal listener.
             *
             * @param {string|!goog.events.EventId} type The listener event type.
             * @param {!Function} listener This listener callback method.
             * @param {boolean} callOnce Whether the listener is a one-off
             *     listener.
             * @param {boolean=} opt_useCapture The capture mode of the listener.
             * @param {Object=} opt_listenerScope Object in whose scope to call the
             *     listener.
             * @return {!goog.events.ListenableKey} Unique key for the listener.
             */
            ListenerMap.prototype.add = function (type, listener, callOnce, opt_useCapture, opt_listenerScope) {
                var typeStr = type.toString();
                var listenerArray = this.listeners[typeStr];
                if (!listenerArray) {
                    listenerArray = this.listeners[typeStr] = [];
                    this.typeCount_++;
                }
                var listenerObj;
                var index = goog.events.ListenerMap.findListenerIndex_(listenerArray, listener, opt_useCapture, opt_listenerScope);
                if (index > -1) {
                    listenerObj = listenerArray[index];
                    if (!callOnce) {
                        // Ensure that, if there is an existing callOnce listener, it is no
                        // longer a callOnce listener.
                        listenerObj.callOnce = false;
                    }
                }
                else {
                    listenerObj = new goog.events.Listener(listener, null, this.src, typeStr, !!opt_useCapture, opt_listenerScope);
                    listenerObj.callOnce = callOnce;
                    listenerArray.push(listenerObj);
                }
                return listenerObj;
            };
            ;
            /**
             * Removes a matching listener.
             * @param {string|!goog.events.EventId} type The listener event type.
             * @param {!Function} listener This listener callback method.
             * @param {boolean=} opt_useCapture The capture mode of the listener.
             * @param {Object=} opt_listenerScope Object in whose scope to call the
             *     listener.
             * @return {boolean} Whether any listener was removed.
             */
            ListenerMap.prototype.remove = function (type, listener, opt_useCapture, opt_listenerScope) {
                var typeStr = type.toString();
                if (!(typeStr in this.listeners)) {
                    return false;
                }
                var listenerArray = this.listeners[typeStr];
                var index = goog.events.ListenerMap.findListenerIndex_(listenerArray, listener, opt_useCapture, opt_listenerScope);
                if (index > -1) {
                    var listenerObj = listenerArray[index];
                    listenerObj.markAsRemoved();
                    goog.array.removeAt(listenerArray, index);
                    if (listenerArray.length == 0) {
                        delete this.listeners[typeStr];
                        this.typeCount_--;
                    }
                    return true;
                }
                return false;
            };
            ;
            /**
             * Removes the given listener object.
             * @param {!goog.events.ListenableKey} listener The listener to remove.
             * @return {boolean} Whether the listener is removed.
             */
            ListenerMap.prototype.removeByKey = function (listener) {
                var type = listener.type;
                if (!(type in this.listeners)) {
                    return false;
                }
                var removed = goog.array.remove(this.listeners[type], listener);
                if (removed) {
                    /** @type {!goog.events.Listener} */ listener.markAsRemoved();
                    if (this.listeners[type].length == 0) {
                        delete this.listeners[type];
                        this.typeCount_--;
                    }
                }
                return removed;
            };
            ;
            /**
             * Removes all listeners from this map. If opt_type is provided, only
             * listeners that match the given type are removed.
             * @param {string|!goog.events.EventId=} opt_type Type of event to remove.
             * @return {number} Number of listeners removed.
             */
            ListenerMap.prototype.removeAll = function (opt_type) {
                var typeStr = opt_type && opt_type.toString();
                var count = 0;
                for (var type in this.listeners) {
                    if (!typeStr || type == typeStr) {
                        var listenerArray = this.listeners[type];
                        for (var i = 0; i < listenerArray.length; i++) {
                            ++count;
                            listenerArray[i].markAsRemoved();
                        }
                        delete this.listeners[type];
                        this.typeCount_--;
                    }
                }
                return count;
            };
            ;
            /**
             * Gets all listeners that match the given type and capture mode. The
             * returned array is a copy (but the listener objects are not).
             * @param {string|!goog.events.EventId} type The type of the listeners
             *     to retrieve.
             * @param {boolean} capture The capture mode of the listeners to retrieve.
             * @return {!Array<!goog.events.ListenableKey>} An array of matching
             *     listeners.
             */
            ListenerMap.prototype.getListeners = function (type, capture) {
                var listenerArray = this.listeners[type.toString()];
                var rv = [];
                if (listenerArray) {
                    for (var i = 0; i < listenerArray.length; ++i) {
                        var listenerObj = listenerArray[i];
                        if (listenerObj.capture == capture) {
                            rv.push(listenerObj);
                        }
                    }
                }
                return rv;
            };
            ;
            /**
             * Gets the goog.events.ListenableKey for the event or null if no such
             * listener is in use.
             *
             * @param {string|!goog.events.EventId} type The type of the listener
             *     to retrieve.
             * @param {!Function} listener The listener function to get.
             * @param {boolean} capture Whether the listener is a capturing listener.
             * @param {Object=} opt_listenerScope Object in whose scope to call the
             *     listener.
             * @return {goog.events.ListenableKey} the found listener or null if not found.
             */
            ListenerMap.prototype.getListener = function (type, listener, capture, opt_listenerScope) {
                var listenerArray = this.listeners[type.toString()];
                var i = -1;
                if (listenerArray) {
                    i = goog.events.ListenerMap.findListenerIndex_(listenerArray, listener, capture, opt_listenerScope);
                }
                return i > -1 ? listenerArray[i] : null;
            };
            ;
            /**
             * Whether there is a matching listener. If either the type or capture
             * parameters are unspecified, the function will match on the
             * remaining criteria.
             *
             * @param {string|!goog.events.EventId=} opt_type The type of the listener.
             * @param {boolean=} opt_capture The capture mode of the listener.
             * @return {boolean} Whether there is an active listener matching
             *     the requested type and/or capture phase.
             */
            ListenerMap.prototype.hasListener = function (opt_type, opt_capture) {
                var hasType = goog.isDef(opt_type);
                var typeStr = hasType ? opt_type.toString() : '';
                var hasCapture = goog.isDef(opt_capture);
                return goog.object.some(this.listeners, function (listenerArray, type) {
                    for (var i = 0; i < listenerArray.length; ++i) {
                        if ((!hasType || listenerArray[i].type == typeStr) &&
                            (!hasCapture || listenerArray[i].capture == opt_capture)) {
                            return true;
                        }
                    }
                    return false;
                });
            };
            ;
            return ListenerMap;
        }());
        events.ListenerMap = ListenerMap;
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
(function (goog) {
    var events;
    (function (events) {
        var ListenerMap;
        (function (ListenerMap) {
            /**
             * Finds the index of a matching goog.events.Listener in the given
             * listenerArray.
             * @param {!Array<!goog.events.Listener>} listenerArray Array of listener.
             * @param {!Function} listener The listener function.
             * @param {boolean=} opt_useCapture The capture flag for the listener.
             * @param {Object=} opt_listenerScope The listener scope.
             * @return {number} The index of the matching listener within the
             *     listenerArray.
             * @private
             */
            function findListenerIndex_(listenerArray, listener, opt_useCapture, opt_listenerScope) {
                for (var i = 0; i < listenerArray.length; ++i) {
                    var listenerObj = listenerArray[i];
                    if (!listenerObj.removed && listenerObj.listener == listener &&
                        listenerObj.capture == !!opt_useCapture &&
                        listenerObj.handler == opt_listenerScope) {
                        return i;
                    }
                }
                return -1;
            }
            ListenerMap.findListenerIndex_ = findListenerIndex_;
            ;
        })(ListenerMap = events.ListenerMap || (events.ListenerMap = {}));
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Definition of the LogRecord class. Please minimize
 * dependencies this file has on other closure classes as any dependency it
 * takes won't be able to use the logging infrastructure.
 *
 */
goog.provide('goog.debug.LogRecord');
var goog;
(function (goog) {
    var debug;
    (function (debug) {
        var LogRecord = /** @class */ (function () {
            /**
             * LogRecord objects are used to pass logging requests between
             * the logging framework and individual log Handlers.
             * @constructor
             * @param {goog.debug.Logger.Level} level One of the level identifiers.
             * @param {string} msg The string message.
             * @param {string} loggerName The name of the source logger.
             * @param {number=} opt_time Time this log record was created if other than now.
             *     If 0, we use #goog.now.
             * @param {number=} opt_sequenceNumber Sequence number of this log record. This
             *     should only be passed in when restoring a log record from persistence.
             */
            function LogRecord(level, msg, loggerName, opt_time, opt_sequenceNumber) {
                /**
                 * Sequence number for the LogRecord. Each record has a unique sequence number
                 * that is greater than all log records created before it.
                 * @type {number}
                 * @private
                 */
                this.sequenceNumber_ = 0;
                /**
                 * Exception associated with the record
                 * @type {Object}
                 * @private
                 */
                this.exception_ = null;
                this.reset(level, msg, loggerName, opt_time, opt_sequenceNumber);
            }
            /**
             * Sets all fields of the log record.
             * @param {goog.debug.Logger.Level} level One of the level identifiers.
             * @param {string} msg The string message.
             * @param {string} loggerName The name of the source logger.
             * @param {number=} opt_time Time this log record was created if other than now.
             *     If 0, we use #goog.now.
             * @param {number=} opt_sequenceNumber Sequence number of this log record. This
             *     should only be passed in when restoring a log record from persistence.
             */
            LogRecord.prototype.reset = function (level, msg, loggerName, opt_time, opt_sequenceNumber) {
                if (goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS) {
                    this.sequenceNumber_ = typeof opt_sequenceNumber == 'number' ?
                        opt_sequenceNumber :
                        goog.debug.LogRecord.nextSequenceNumber_++;
                }
                this.time_ = opt_time || goog.now();
                this.level_ = level;
                this.msg_ = msg;
                this.loggerName_ = loggerName;
                delete this.exception_;
            };
            ;
            /**
             * Get the source Logger's name.
             *
             * @return {string} source logger name (may be null).
             */
            LogRecord.prototype.getLoggerName = function () {
                return this.loggerName_;
            };
            ;
            /**
             * Get the exception that is part of the log record.
             *
             * @return {Object} the exception.
             */
            LogRecord.prototype.getException = function () {
                return this.exception_;
            };
            ;
            /**
             * Set the exception that is part of the log record.
             *
             * @param {Object} exception the exception.
             */
            LogRecord.prototype.setException = function (exception) {
                this.exception_ = exception;
            };
            ;
            /**
             * Get the source Logger's name.
             *
             * @param {string} loggerName source logger name (may be null).
             */
            LogRecord.prototype.setLoggerName = function (loggerName) {
                this.loggerName_ = loggerName;
            };
            ;
            /**
             * Get the logging message level, for example Level.SEVERE.
             * @return {goog.debug.Logger.Level} the logging message level.
             */
            LogRecord.prototype.getLevel = function () {
                return this.level_;
            };
            ;
            /**
             * Set the logging message level, for example Level.SEVERE.
             * @param {goog.debug.Logger.Level} level the logging message level.
             */
            LogRecord.prototype.setLevel = function (level) {
                this.level_ = level;
            };
            ;
            /**
             * Get the "raw" log message, before localization or formatting.
             *
             * @return {string} the raw message string.
             */
            LogRecord.prototype.getMessage = function () {
                return this.msg_;
            };
            ;
            /**
             * Set the "raw" log message, before localization or formatting.
             *
             * @param {string} msg the raw message string.
             */
            LogRecord.prototype.setMessage = function (msg) {
                this.msg_ = msg;
            };
            ;
            /**
             * Get event time in milliseconds since 1970.
             *
             * @return {number} event time in millis since 1970.
             */
            LogRecord.prototype.getMillis = function () {
                return this.time_;
            };
            ;
            /**
             * Set event time in milliseconds since 1970.
             *
             * @param {number} time event time in millis since 1970.
             */
            LogRecord.prototype.setMillis = function (time) {
                this.time_ = time;
            };
            ;
            /**
             * Get the sequence number.
             * <p>
             * Sequence numbers are normally assigned in the LogRecord
             * constructor, which assigns unique sequence numbers to
             * each new LogRecord in increasing order.
             * @return {number} the sequence number.
             */
            LogRecord.prototype.getSequenceNumber = function () {
                return this.sequenceNumber_;
            };
            ;
            /**
             * A sequence counter for assigning increasing sequence numbers to LogRecord
             * objects.
             * @type {number}
             * @private
             */
            LogRecord.nextSequenceNumber_ = 0;
            return LogRecord;
        }());
        debug.LogRecord = LogRecord;
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        var LogRecord;
        (function (LogRecord) {
            LogRecord.ENABLE_SEQUENCE_NUMBERS = true;
        })(LogRecord = debug.LogRecord || (debug.LogRecord = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
/**
 * @define {boolean} Whether to enable log sequence numbers.
 */
goog.define('goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS', true);
/// <reference path="../asserts/asserts" />
/// <reference path="../debug/LogRecord" />
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A buffer for log records. The purpose of this is to improve
 * logging performance by re-using old objects when the buffer becomes full and
 * to eliminate the need for each app to implement their own log buffer. The
 * disadvantage to doing this is that log handlers cannot maintain references to
 * log records and expect that they are not overwriten at a later point.
 *
 * @author agrieve@google.com (Andrew Grieve)
 */
goog.provide('goog.debug.LogBuffer');
goog.require('goog.asserts');
goog.require('goog.debug.LogRecord');
var goog;
(function (goog) {
    var debug;
    (function (debug) {
        var LogBuffer = /** @class */ (function () {
            /**
             * Creates the log buffer.
             * @constructor
             * @final
             */
            function LogBuffer() {
                goog.asserts.assert(goog.debug.LogBuffer.isBufferingEnabled(), 'Cannot use goog.debug.LogBuffer without defining ' +
                    'goog.debug.LogBuffer.CAPACITY.');
                this.clear();
            }
            /**
             * A static method that always returns the same instance of LogBuffer.
             * @return {!goog.debug.LogBuffer} The LogBuffer singleton instance.
             */
            LogBuffer.getInstance = function () {
                if (!goog.debug.LogBuffer.instance_) {
                    // This function is written with the return statement after the assignment
                    // to avoid the jscompiler StripCode bug described in http://b/2608064.
                    // After that bug is fixed this can be refactored.
                    goog.debug.LogBuffer.instance_ = new goog.debug.LogBuffer();
                }
                return goog.debug.LogBuffer.instance_;
            };
            ;
            /**
             * Adds a log record to the buffer, possibly overwriting the oldest record.
             * @param {goog.debug.Logger.Level} level One of the level identifiers.
             * @param {string} msg The string message.
             * @param {string} loggerName The name of the source logger.
             * @return {!goog.debug.LogRecord} The log record.
             */
            LogBuffer.prototype.addRecord = function (level, msg, loggerName) {
                var curIndex = (this.curIndex_ + 1) % goog.debug.LogBuffer.CAPACITY;
                this.curIndex_ = curIndex;
                if (this.isFull_) {
                    var ret = this.buffer_[curIndex];
                    ret.reset(level, msg, loggerName);
                    return ret;
                }
                this.isFull_ = curIndex == goog.debug.LogBuffer.CAPACITY - 1;
                return this.buffer_[curIndex] =
                    new goog.debug.LogRecord(level, msg, loggerName);
            };
            ;
            /**
             * @return {boolean} Whether the log buffer is enabled.
             */
            LogBuffer.isBufferingEnabled = function () {
                return goog.debug.LogBuffer.CAPACITY > 0;
            };
            ;
            /**
             * Removes all buffered log records.
             */
            LogBuffer.prototype.clear = function () {
                this.buffer_ = new Array(goog.debug.LogBuffer.CAPACITY);
                this.curIndex_ = -1;
                this.isFull_ = false;
            };
            ;
            /**
             * Calls the given function for each buffered log record, starting with the
             * oldest one.
             * @param {function(!goog.debug.LogRecord)} func The function to call.
             */
            LogBuffer.prototype.forEachRecord = function (func) {
                var buffer = this.buffer_;
                // Corner case: no records.
                if (!buffer[0]) {
                    return;
                }
                var curIndex = this.curIndex_;
                var i = this.isFull_ ? curIndex : -1;
                do {
                    i = (i + 1) % goog.debug.LogBuffer.CAPACITY;
                    func(/** @type {!goog.debug.LogRecord} */ (buffer[i]));
                } while (i != curIndex);
            };
            ;
            return LogBuffer;
        }());
        debug.LogBuffer = LogBuffer;
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        var LogBuffer;
        (function (LogBuffer) {
            LogBuffer.CAPACITY = 0;
        })(LogBuffer = debug.LogBuffer || (debug.LogBuffer = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
/**
 * @define {number} The number of log records to buffer. 0 means disable
 * buffering.
 */
goog.define('goog.debug.LogBuffer.CAPACITY', 0);
/// <reference path="../array/array" />
/// <reference path="../asserts/asserts" />
/// <reference path="../debug/debug" />
/// <reference path="../debug/LogBuffer" />
/// <reference path="../debug/LogRecord" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Definition of the Logger class. Please minimize dependencies
 * this file has on other closure classes as any dependency it takes won't be
 * able to use the logging infrastructure.
 *
 * @see ../demos/debug.html
 */
goog.provide('goog.debug.LogManager');
goog.provide('goog.debug.Loggable');
goog.provide('goog.debug.Logger');
goog.provide('goog.debug.Logger.Level');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug');
goog.require('goog.debug.LogBuffer');
goog.require('goog.debug.LogRecord');
var goog;
(function (goog) {
    var debug;
    (function (debug) {
        /**
         * The Logger is an object used for logging debug messages. Loggers are
         * normally named, using a hierarchical dot-separated namespace. Logger names
         * can be arbitrary strings, but they should normally be based on the package
         * name or class name of the logged component, such as goog.net.BrowserChannel.
         *
         * The Logger object is loosely based on the java class
         * java.util.logging.Logger. It supports different levels of filtering for
         * different loggers.
         *
         * The logger object should never be instantiated by application code. It
         * should always use the goog.debug.Logger.getLogger function.
         *
      
         */
        var Logger = /** @class */ (function () {
            /**
             *
             * @constructor
             * @param {string} name The name of the Logger.
             * @final
             */
            function Logger(name) {
                /**
               * Name of the Logger. Generally a dot-separated namespace
               * @private {string}
               */
                this.name_ = name;
                /**
                 * Parent Logger.
                 * @private {goog.debug.Logger}
                 */
                this.parent_ = null;
                /**
                 * Level that this logger only filters above. Null indicates it should
                 * inherit from the parent.
                 * @private {goog.debug.Logger.Level}
                 */
                this.level_ = null;
                /**
                 * Map of children loggers. The keys are the leaf names of the children and
                 * the values are the child loggers.
                 * @private {Object}
                 */
                this.children_ = null;
                /**
                 * Handlers that are listening to this logger.
                 * @private {Array<Function>}
                 */
                this.handlers_ = null;
            }
            /**
                 * Finds or creates a logger for a named subsystem. If a logger has already been
                 * created with the given name it is returned. Otherwise a new logger is
                 * created. If a new logger is created its log level will be configured based
                 * on the LogManager configuration and it will configured to also send logging
                 * output to its parent's handlers. It will be registered in the LogManager
                 * global namespace.
                 *
                 * @param {string} name A name for the logger. This should be a dot-separated
                 * name and should normally be based on the package name or class name of the
                 * subsystem, such as goog.net.BrowserChannel.
                 * @return {!goog.debug.Logger} The named logger.
                 * @deprecated use {@link goog.log} instead.
                 */
            Logger.getLogger = function (name) {
                return goog.debug.LogManager.getLogger(name);
            };
            ;
            /**
             * Logs a message to profiling tools, if available.
             * {@see https://developers.google.com/web-toolkit/speedtracer/logging-api}
             * {@see http://msdn.microsoft.com/en-us/library/dd433074(VS.85).aspx}
             * @param {string} msg The message to log.
             */
            Logger.logToProfilers = function (msg) {
                // Some browsers also log timeStamp calls to the console, only log
                // if actually asked.
                if (goog.debug.Logger.ENABLE_PROFILER_LOGGING) {
                    var msWriteProfilerMark = goog.global['msWriteProfilerMark'];
                    if (msWriteProfilerMark) {
                        // Logs a message to the Microsoft profiler
                        // On IE, console['timeStamp'] may output to console
                        msWriteProfilerMark(msg);
                        return;
                    }
                    // Using goog.global, as loggers might be used in window-less contexts.
                    var console = goog.global['console'];
                    if (console && console['timeStamp']) {
                        // Logs a message to Firebug, Web Inspector, SpeedTracer, etc.
                        console['timeStamp'](msg);
                    }
                }
            };
            ;
            /**
             * Gets the name of this logger.
             * @return {string} The name of this logger.
             */
            Logger.prototype.getName = function () {
                return this.name_;
            };
            ;
            /**
             * Adds a handler to the logger. This doesn't use the event system because
             * we want to be able to add logging to the event system.
             * @param {Function} handler Handler function to add.
             */
            Logger.prototype.addHandler = function (handler) {
                if (goog.debug.LOGGING_ENABLED) {
                    if (goog.debug.Logger.ENABLE_HIERARCHY) {
                        if (!this.handlers_) {
                            this.handlers_ = [];
                        }
                        this.handlers_.push(handler);
                    }
                    else {
                        goog.asserts.assert(!this.name_, 'Cannot call addHandler on a non-root logger when ' +
                            'goog.debug.Logger.ENABLE_HIERARCHY is false.');
                        goog.debug.Logger.rootHandlers_.push(handler);
                    }
                }
            };
            ;
            /**
             * Removes a handler from the logger. This doesn't use the event system because
             * we want to be able to add logging to the event system.
             * @param {Function} handler Handler function to remove.
             * @return {boolean} Whether the handler was removed.
             */
            Logger.prototype.removeHandler = function (handler) {
                if (goog.debug.LOGGING_ENABLED) {
                    var handlers = goog.debug.Logger.ENABLE_HIERARCHY ?
                        this.handlers_ :
                        goog.debug.Logger.rootHandlers_;
                    return !!handlers && goog.array.remove(handlers, handler);
                }
                else {
                    return false;
                }
            };
            ;
            /**
             * Returns the parent of this logger.
             * @return {goog.debug.Logger} The parent logger or null if this is the root.
             */
            Logger.prototype.getParent = function () {
                return this.parent_;
            };
            ;
            /**
             * Returns the children of this logger as a map of the child name to the logger.
             * @return {!Object} The map where the keys are the child leaf names and the
             *     values are the Logger objects.
             */
            Logger.prototype.getChildren = function () {
                if (!this.children_) {
                    this.children_ = {};
                }
                return this.children_;
            };
            ;
            /**
             * Set the log level specifying which message levels will be logged by this
             * logger. Message levels lower than this value will be discarded.
             * The level value Level.OFF can be used to turn off logging. If the new level
             * is null, it means that this node should inherit its level from its nearest
             * ancestor with a specific (non-null) level value.
             *
             * @param {goog.debug.Logger.Level} level The new level.
             */
            Logger.prototype.setLevel = function (level) {
                if (goog.debug.LOGGING_ENABLED) {
                    if (goog.debug.Logger.ENABLE_HIERARCHY) {
                        this.level_ = level;
                    }
                    else {
                        goog.asserts.assert(!this.name_, 'Cannot call setLevel() on a non-root logger when ' +
                            'goog.debug.Logger.ENABLE_HIERARCHY is false.');
                        goog.debug.Logger.rootLevel_ = level;
                    }
                }
            };
            ;
            /**
             * Gets the log level specifying which message levels will be logged by this
             * logger. Message levels lower than this value will be discarded.
             * The level value Level.OFF can be used to turn off logging. If the level
             * is null, it means that this node should inherit its level from its nearest
             * ancestor with a specific (non-null) level value.
             *
             * @return {goog.debug.Logger.Level} The level.
             */
            Logger.prototype.getLevel = function () {
                return goog.debug.LOGGING_ENABLED ? this.level_ : goog.debug.Logger.Level.OFF;
            };
            ;
            /**
             * Returns the effective level of the logger based on its ancestors' levels.
             * @return {goog.debug.Logger.Level} The level.
             */
            Logger.prototype.getEffectiveLevel = function () {
                if (!goog.debug.LOGGING_ENABLED) {
                    return goog.debug.Logger.Level.OFF;
                }
                if (!goog.debug.Logger.ENABLE_HIERARCHY) {
                    return goog.debug.Logger.rootLevel_;
                }
                if (this.level_) {
                    return this.level_;
                }
                if (this.parent_) {
                    return this.parent_.getEffectiveLevel();
                }
                goog.asserts.fail('Root logger has no level set.');
                return null;
            };
            ;
            /**
             * Checks if a message of the given level would actually be logged by this
             * logger. This check is based on the Loggers effective level, which may be
             * inherited from its parent.
             * @param {goog.debug.Logger.Level} level The level to check.
             * @return {boolean} Whether the message would be logged.
             */
            Logger.prototype.isLoggable = function (level) {
                return goog.debug.LOGGING_ENABLED &&
                    level.value >= this.getEffectiveLevel().value;
            };
            ;
            /**
             * Logs a message. If the logger is currently enabled for the
             * given message level then the given message is forwarded to all the
             * registered output Handler objects.
             * @param {goog.debug.Logger.Level} level One of the level identifiers.
             * @param {goog.debug.Loggable} msg The message to log.
             * @param {Error|Object=} opt_exception An exception associated with the
             *     message.
             */
            Logger.prototype.log = function (level, msg, opt_exception) {
                // java caches the effective level, not sure it's necessary here
                if (goog.debug.LOGGING_ENABLED && this.isLoggable(level)) {
                    // Message callbacks can be useful when a log message is expensive to build.
                    if (goog.isFunction(msg)) {
                        msg = msg();
                    }
                    this.doLogRecord_(this.getLogRecord(level, msg, opt_exception));
                }
            };
            ;
            /**
             * Creates a new log record and adds the exception (if present) to it.
             * @param {goog.debug.Logger.Level} level One of the level identifiers.
             * @param {string} msg The string message.
             * @param {Error|Object=} opt_exception An exception associated with the
             *     message.
             * @return {!goog.debug.LogRecord} A log record.
             * @suppress {es5Strict}
             */
            Logger.prototype.getLogRecord = function (level, msg, opt_exception) {
                if (goog.debug.LogBuffer.isBufferingEnabled()) {
                    var logRecord = goog.debug.LogBuffer.getInstance().addRecord(level, msg, this.name_);
                }
                else {
                    logRecord = new goog.debug.LogRecord(level, String(msg), this.name_);
                }
                if (opt_exception) {
                    logRecord.setException(opt_exception);
                }
                return logRecord;
            };
            ;
            /**
             * Logs a message at the Logger.Level.SHOUT level.
             * If the logger is currently enabled for the given message level then the
             * given message is forwarded to all the registered output Handler objects.
             * @param {goog.debug.Loggable} msg The message to log.
             * @param {Error=} opt_exception An exception associated with the message.
             */
            Logger.prototype.shout = function (msg, opt_exception) {
                if (goog.debug.LOGGING_ENABLED) {
                    this.log(goog.debug.Logger.Level.SHOUT, msg, opt_exception);
                }
            };
            ;
            /**
             * Logs a message at the Logger.Level.SEVERE level.
             * If the logger is currently enabled for the given message level then the
             * given message is forwarded to all the registered output Handler objects.
             * @param {goog.debug.Loggable} msg The message to log.
             * @param {Error=} opt_exception An exception associated with the message.
             */
            Logger.prototype.severe = function (msg, opt_exception) {
                if (goog.debug.LOGGING_ENABLED) {
                    this.log(goog.debug.Logger.Level.SEVERE, msg, opt_exception);
                }
            };
            ;
            /**
             * Logs a message at the Logger.Level.WARNING level.
             * If the logger is currently enabled for the given message level then the
             * given message is forwarded to all the registered output Handler objects.
             * @param {goog.debug.Loggable} msg The message to log.
             * @param {Error=} opt_exception An exception associated with the message.
             */
            Logger.prototype.warning = function (msg, opt_exception) {
                if (goog.debug.LOGGING_ENABLED) {
                    this.log(goog.debug.Logger.Level.WARNING, msg, opt_exception);
                }
            };
            ;
            /**
             * Logs a message at the Logger.Level.INFO level.
             * If the logger is currently enabled for the given message level then the
             * given message is forwarded to all the registered output Handler objects.
             * @param {goog.debug.Loggable} msg The message to log.
             * @param {Error=} opt_exception An exception associated with the message.
             */
            Logger.prototype.info = function (msg, opt_exception) {
                if (goog.debug.LOGGING_ENABLED) {
                    this.log(goog.debug.Logger.Level.INFO, msg, opt_exception);
                }
            };
            ;
            /**
             * Logs a message at the Logger.Level.CONFIG level.
             * If the logger is currently enabled for the given message level then the
             * given message is forwarded to all the registered output Handler objects.
             * @param {goog.debug.Loggable} msg The message to log.
             * @param {Error=} opt_exception An exception associated with the message.
             */
            Logger.prototype.config = function (msg, opt_exception) {
                if (goog.debug.LOGGING_ENABLED) {
                    this.log(goog.debug.Logger.Level.CONFIG, msg, opt_exception);
                }
            };
            ;
            /**
             * Logs a message at the Logger.Level.FINE level.
             * If the logger is currently enabled for the given message level then the
             * given message is forwarded to all the registered output Handler objects.
             * @param {goog.debug.Loggable} msg The message to log.
             * @param {Error=} opt_exception An exception associated with the message.
             */
            Logger.prototype.fine = function (msg, opt_exception) {
                if (goog.debug.LOGGING_ENABLED) {
                    this.log(goog.debug.Logger.Level.FINE, msg, opt_exception);
                }
            };
            ;
            /**
             * Logs a message at the Logger.Level.FINER level.
             * If the logger is currently enabled for the given message level then the
             * given message is forwarded to all the registered output Handler objects.
             * @param {goog.debug.Loggable} msg The message to log.
             * @param {Error=} opt_exception An exception associated with the message.
             */
            Logger.prototype.finer = function (msg, opt_exception) {
                if (goog.debug.LOGGING_ENABLED) {
                    this.log(goog.debug.Logger.Level.FINER, msg, opt_exception);
                }
            };
            ;
            /**
             * Logs a message at the Logger.Level.FINEST level.
             * If the logger is currently enabled for the given message level then the
             * given message is forwarded to all the registered output Handler objects.
             * @param {goog.debug.Loggable} msg The message to log.
             * @param {Error=} opt_exception An exception associated with the message.
             */
            Logger.prototype.finest = function (msg, opt_exception) {
                if (goog.debug.LOGGING_ENABLED) {
                    this.log(goog.debug.Logger.Level.FINEST, msg, opt_exception);
                }
            };
            ;
            /**
             * Logs a LogRecord. If the logger is currently enabled for the
             * given message level then the given message is forwarded to all the
             * registered output Handler objects.
             * @param {goog.debug.LogRecord} logRecord A log record to log.
             */
            Logger.prototype.logRecord = function (logRecord) {
                if (goog.debug.LOGGING_ENABLED && this.isLoggable(logRecord.getLevel())) {
                    this.doLogRecord_(logRecord);
                }
            };
            ;
            /**
             * Logs a LogRecord.
             * @param {goog.debug.LogRecord} logRecord A log record to log.
             * @private
             */
            Logger.prototype.doLogRecord_ = function (logRecord) {
                if (goog.debug.Logger.ENABLE_PROFILER_LOGGING) {
                    goog.debug.Logger.logToProfilers('log:' + logRecord.getMessage());
                }
                if (goog.debug.Logger.ENABLE_HIERARCHY) {
                    var target = this;
                    while (target) {
                        target.callPublish_(logRecord);
                        target = target.getParent();
                    }
                }
                else {
                    for (var i = 0, handler; handler = goog.debug.Logger.rootHandlers_[i++];) {
                        handler(logRecord);
                    }
                }
            };
            ;
            /**
             * Calls the handlers for publish.
             * @param {goog.debug.LogRecord} logRecord The log record to publish.
             * @private
             */
            Logger.prototype.callPublish_ = function (logRecord) {
                if (this.handlers_) {
                    for (var i = 0, handler; handler = this.handlers_[i]; i++) {
                        handler(logRecord);
                    }
                }
            };
            ;
            /**
             * Sets the parent of this logger. This is used for setting up the logger tree.
             * @param {goog.debug.Logger} parent The parent logger.
             * @private
             */
            Logger.prototype.setParent_ = function (parent) {
                this.parent_ = parent;
            };
            ;
            /**
             * Adds a child to this logger. This is used for setting up the logger tree.
             * @param {string} name The leaf name of the child.
             * @param {goog.debug.Logger} logger The child logger.
             * @private
             */
            Logger.prototype.addChild_ = function (name, logger) {
                this.getChildren()[name] = logger;
            };
            ;
            return Logger;
        }());
        debug.Logger = Logger;
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        var Logger;
        (function (Logger) {
            /** @const */
            Logger.ROOT_LOGGER_NAME = '';
            Logger.ENABLE_HIERARCHY = true;
            Logger.ENABLE_PROFILER_LOGGING = false;
            // if (!goog.debug.Logger.ENABLE_HIERARCHY) {
            /**
             * @type {!Array<Function>}
             * @private
             */
            Logger.rootHandlers_ = [];
            // }
        })(Logger = debug.Logger || (debug.Logger = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
/**
 * @define {boolean} Toggles whether loggers other than the root logger can have
 *     log handlers attached to them and whether they can have their log level
 *     set. Logging is a bit faster when this is set to false.
 */
goog.define('goog.debug.Logger.ENABLE_HIERARCHY', true);
/**
 * @define {boolean} Toggles whether active log statements are also recorded
 *     to the profiler.
 */
goog.define('goog.debug.Logger.ENABLE_PROFILER_LOGGING', false);
(function (goog) {
    var debug;
    (function (debug) {
        var Logger;
        (function (Logger) {
            /**
             * The Level class defines a set of standard logging levels that
             * can be used to control logging output.  The logging Level objects
             * are ordered and are specified by ordered integers.  Enabling logging
             * at a given level also enables logging at all higher levels.
             * <p>
             * Clients should normally use the predefined Level constants such
             * as Level.SEVERE.
             * <p>
             * The levels in descending order are:
             * <ul>
             * <li>SEVERE (highest value)
             * <li>WARNING
             * <li>INFO
             * <li>CONFIG
             * <li>FINE
             * <li>FINER
             * <li>FINEST  (lowest value)
             * </ul>
             * In addition there is a level OFF that can be used to turn
             * off logging, and a level ALL that can be used to enable
             * logging of all messages.
             *
          
             */
            var Level = /** @class */ (function () {
                /**
                 *
                 * @param {string} name The name of the level.
                 * @param {number} value The numeric value of the level.
                 * @constructor
                 * @final
                 */
                function Level(name, value) {
                    /**
                     * @return {string} String representation of the logger level.
                     * @override
                     */
                    this.toString = function () {
                        return this.name;
                    };
                    /**
                     * The name of the level
                     * @type {string}
                     */
                    this.name = name;
                    /**
                     * The numeric value of the level
                     * @type {number}
                     */
                    this.value = value;
                }
                /**
                 * Creates the predefined levels cache and populates it.
                 * @private
                 */
                Level.createPredefinedLevelsCache_ = function () {
                    goog.debug.Logger.Level.predefinedLevelsCache_ = {};
                    for (var i = 0, level; level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i]; i++) {
                        goog.debug.Logger.Level.predefinedLevelsCache_[level.value] = level;
                        goog.debug.Logger.Level.predefinedLevelsCache_[level.name] = level;
                    }
                };
                ;
                /**
                 * Gets the predefined level with the given name.
                 * @param {string} name The name of the level.
                 * @return {goog.debug.Logger.Level} The level, or null if none found.
                 */
                Level.getPredefinedLevel = function (name) {
                    if (!goog.debug.Logger.Level.predefinedLevelsCache_) {
                        goog.debug.Logger.Level.createPredefinedLevelsCache_();
                    }
                    return goog.debug.Logger.Level.predefinedLevelsCache_[name] || null;
                };
                ;
                /**
                 * Gets the highest predefined level <= #value.
                 * @param {number} value Level value.
                 * @return {goog.debug.Logger.Level} The level, or null if none found.
                 */
                Level.getPredefinedLevelByValue = function (value) {
                    if (!goog.debug.Logger.Level.predefinedLevelsCache_) {
                        goog.debug.Logger.Level.createPredefinedLevelsCache_();
                    }
                    if (value in /** @type {!Object} */ (goog.debug.Logger.Level.predefinedLevelsCache_)) {
                        return goog.debug.Logger.Level.predefinedLevelsCache_[value];
                    }
                    for (var i = 0; i < goog.debug.Logger.Level.PREDEFINED_LEVELS.length; ++i) {
                        var level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];
                        if (level.value <= value) {
                            return level;
                        }
                    }
                    return null;
                };
                ;
                return Level;
            }());
            Logger.Level = Level;
        })(Logger = debug.Logger || (debug.Logger = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        var Logger;
        (function (Logger) {
            var Level;
            (function (Level) {
                /**
                 * OFF is a special level that can be used to turn off logging.
                 * This level is initialized to <CODE>Infinity</CODE>.
                 * @type {!goog.debug.Logger.Level}
                 */
                Level.OFF = new goog.debug.Logger.Level('OFF', Infinity);
                /**
                 * SHOUT is a message level for extra debugging loudness.
                 * This level is initialized to <CODE>1200</CODE>.
                 * @type {!goog.debug.Logger.Level}
                 */
                Level.SHOUT = new goog.debug.Logger.Level('SHOUT', 1200);
                /**
                 * SEVERE is a message level indicating a serious failure.
                 * This level is initialized to <CODE>1000</CODE>.
                 * @type {!goog.debug.Logger.Level}
                 */
                Level.SEVERE = new goog.debug.Logger.Level('SEVERE', 1000);
                /**
                 * WARNING is a message level indicating a potential problem.
                 * This level is initialized to <CODE>900</CODE>.
                 * @type {!goog.debug.Logger.Level}
                 */
                Level.WARNING = new goog.debug.Logger.Level('WARNING', 900);
                /**
                 * INFO is a message level for informational messages.
                 * This level is initialized to <CODE>800</CODE>.
                 * @type {!goog.debug.Logger.Level}
                 */
                Level.INFO = new goog.debug.Logger.Level('INFO', 800);
                /**
                 * CONFIG is a message level for static configuration messages.
                 * This level is initialized to <CODE>700</CODE>.
                 * @type {!goog.debug.Logger.Level}
                 */
                Level.CONFIG = new goog.debug.Logger.Level('CONFIG', 700);
                /**
                 * FINE is a message level providing tracing information.
                 * This level is initialized to <CODE>500</CODE>.
                 * @type {!goog.debug.Logger.Level}
                 */
                Level.FINE = new goog.debug.Logger.Level('FINE', 500);
                /**
                 * FINER indicates a fairly detailed tracing message.
                 * This level is initialized to <CODE>400</CODE>.
                 * @type {!goog.debug.Logger.Level}
                 */
                Level.FINER = new goog.debug.Logger.Level('FINER', 400);
                /**
                 * FINEST indicates a highly detailed tracing message.
                 * This level is initialized to <CODE>300</CODE>.
                 * @type {!goog.debug.Logger.Level}
                 */
                Level.FINEST = new goog.debug.Logger.Level('FINEST', 300);
                /**
                 * ALL indicates that all messages should be logged.
                 * This level is initialized to <CODE>0</CODE>.
                 * @type {!goog.debug.Logger.Level}
                 */
                Level.ALL = new goog.debug.Logger.Level('ALL', 0);
                /**
                 * The predefined levels.
                 * @type {!Array<!goog.debug.Logger.Level>}
                 * @final
                 */
                Level.PREDEFINED_LEVELS = [
                    goog.debug.Logger.Level.OFF, goog.debug.Logger.Level.SHOUT,
                    goog.debug.Logger.Level.SEVERE, goog.debug.Logger.Level.WARNING,
                    goog.debug.Logger.Level.INFO, goog.debug.Logger.Level.CONFIG,
                    goog.debug.Logger.Level.FINE, goog.debug.Logger.Level.FINER,
                    goog.debug.Logger.Level.FINEST, goog.debug.Logger.Level.ALL
                ];
                /**
                 * A lookup map used to find the level object based on the name or value of
                 * the level object.
                 * @type {Object}
                 * @private
                 */
                Level.predefinedLevelsCache_ = null;
            })(Level = Logger.Level || (Logger.Level = {}));
        })(Logger = debug.Logger || (debug.Logger = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        var LogManager;
        (function (LogManager) {
            /**
             * Map of logger names to logger objects.
             *
             * @type {!Object<string, !goog.debug.Logger>}
             * @private
             */
            LogManager.loggers_ = {};
            /**
             * The root logger which is the root of the logger tree.
             * @type {goog.debug.Logger}
             * @private
             */
            LogManager.rootLogger_ = null;
            /**
             * Initializes the LogManager if not already initialized.
             */
            function initialize() {
                if (!goog.debug.LogManager.rootLogger_) {
                    goog.debug.LogManager.rootLogger_ =
                        new goog.debug.Logger(goog.debug.Logger.ROOT_LOGGER_NAME);
                    goog.debug.LogManager.loggers_[goog.debug.Logger.ROOT_LOGGER_NAME] =
                        goog.debug.LogManager.rootLogger_;
                    goog.debug.LogManager.rootLogger_.setLevel(goog.debug.Logger.Level.CONFIG);
                }
            }
            LogManager.initialize = initialize;
            ;
            /**
             * Returns all the loggers.
             * @return {!Object<string, !goog.debug.Logger>} Map of logger names to logger
             *     objects.
             */
            function getLoggers() {
                return goog.debug.LogManager.loggers_;
            }
            LogManager.getLoggers = getLoggers;
            ;
            /**
             * Returns the root of the logger tree namespace, the logger with the empty
             * string as its name.
             *
             * @return {!goog.debug.Logger} The root logger.
             */
            function getRoot() {
                goog.debug.LogManager.initialize();
                return /** @type {!goog.debug.Logger} */ (goog.debug.LogManager.rootLogger_);
            }
            LogManager.getRoot = getRoot;
            ;
            /**
             * Finds a named logger.
             *
             * @param {string} name A name for the logger. This should be a dot-separated
             * name and should normally be based on the package name or class name of the
             * subsystem, such as goog.net.BrowserChannel.
             * @return {!goog.debug.Logger} The named logger.
             */
            function getLogger(name) {
                goog.debug.LogManager.initialize();
                var ret = goog.debug.LogManager.loggers_[name];
                return ret || goog.debug.LogManager.createLogger_(name);
            }
            LogManager.getLogger = getLogger;
            ;
            /**
             * Creates a function that can be passed to goog.debug.catchErrors. The function
             * will log all reported errors using the given logger.
             * @param {goog.debug.Logger=} opt_logger The logger to log the errors to.
             *     Defaults to the root logger.
             * @return {function(Object)} The created function.
             */
            function createFunctionForCatchErrors(opt_logger) {
                return function (info) {
                    var logger = opt_logger || goog.debug.LogManager.getRoot();
                    logger.severe('Error: ' + info.message + ' (' + info.fileName + ' @ Line: ' +
                        info.line + ')');
                };
            }
            LogManager.createFunctionForCatchErrors = createFunctionForCatchErrors;
            ;
            /**
             * Creates the named logger. Will also create the parents of the named logger
             * if they don't yet exist.
             * @param {string} name The name of the logger.
             * @return {!goog.debug.Logger} The named logger.
             * @private
             */
            function createLogger_(name) {
                // find parent logger
                var logger = new goog.debug.Logger(name);
                if (goog.debug.Logger.ENABLE_HIERARCHY) {
                    var lastDotIndex = name.lastIndexOf('.');
                    var parentName = name.substr(0, lastDotIndex);
                    var leafName = name.substr(lastDotIndex + 1);
                    var parentLogger = goog.debug.LogManager.getLogger(parentName);
                    // tell the parent about the child and the child about the parent
                    parentLogger.addChild_(leafName, logger);
                    logger.setParent_(parentLogger);
                }
                goog.debug.LogManager.loggers_[name] = logger;
                return logger;
            }
            LogManager.createLogger_ = createLogger_;
            ;
        })(LogManager = debug.LogManager || (debug.LogManager = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utilities for creating functions. Loosely inspired by the
 * java classes: http://goo.gl/GM0Hmu and http://goo.gl/6k7nI8.
 *
 * @author nicksantos@google.com (Nick Santos)
 */
goog.provide('goog.functions');
var goog;
(function (goog) {
    var functions;
    (function (functions_1) {
        /**
         * Creates a function that always returns the same value.
         * @param {T} retValue The value to return.
         * @return {function():T} The new function.
         * @template T
         */
        function constant(retValue) {
            return function () { return retValue; };
        }
        functions_1.constant = constant;
        ;
        /**
         * Always returns false.
         * @type {function(...): boolean}
         */
        functions_1.FALSE = goog.functions.constant(false);
        /**
         * Always returns true.
         * @type {function(...): boolean}
         */
        functions_1.TRUE = goog.functions.constant(true);
        /**
         * Always returns NULL.
         * @type {function(...): null}
         */
        functions_1.NULL = goog.functions.constant(null);
        /**
         * A simple function that returns the first argument of whatever is passed
         * into it.
         * @param {T=} opt_returnValue The single value that will be returned.
         * @param {...*} var_args Optional trailing arguments. These are ignored.
         * @return {T} The first argument passed in, or undefined if nothing was passed.
         * @template T
         */
        function identity(opt_returnValue) {
            var var_args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                var_args[_i - 1] = arguments[_i];
            }
            return opt_returnValue;
        }
        functions_1.identity = identity;
        ;
        /**
         * Creates a function that always throws an error with the given message.
         * @param {string} message The error message.
         * @return {!Function} The error-throwing function.
         */
        function error(message) {
            return function () {
                throw new Error(message);
            };
        }
        functions_1.error = error;
        ;
        /**
         * Creates a function that throws the given object.
         * @param {*} err An object to be thrown.
         * @return {!Function} The error-throwing function.
         */
        function fail(err) {
            return function () { throw err; };
        }
        functions_1.fail = fail;
        ;
        /**
         * Given a function, create a function that keeps opt_numArgs arguments and
         * silently discards all additional arguments.
         * @param {Function} f The original function.
         * @param {number=} opt_numArgs The number of arguments to keep. Defaults to 0.
         * @return {!Function} A version of f that only keeps the first opt_numArgs
         *     arguments.
         */
        function lock(f, opt_numArgs) {
            opt_numArgs = opt_numArgs || 0;
            return function () {
                var self = (this);
                return f.apply(self, Array.prototype.slice.call(arguments, 0, opt_numArgs));
            };
        }
        functions_1.lock = lock;
        ;
        /**
         * Creates a function that returns its nth argument.
         * @param {number} n The position of the return argument.
         * @return {!Function} A new function.
         */
        function nth(n) {
            return function () { return arguments[n]; };
        }
        functions_1.nth = nth;
        ;
        /**
         * Like goog.partial(), except that arguments are added after arguments to the
         * returned function.
         *
         * Usage:
         * function f(arg1, arg2, arg3, arg4) { ... }
         * var g = goog.functions.partialRight(f, arg3, arg4);
         * g(arg1, arg2);
         *
         * @param {!Function} fn A function to partially apply.
         * @param {...*} var_args Additional arguments that are partially applied to fn
         *     at the end.
         * @return {!Function} A partially-applied form of the function goog.partial()
         *     was invoked as a method of.
         */
        function partialRight(fn) {
            var var_args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                var_args[_i - 1] = arguments[_i];
            }
            var rightArgs = Array.prototype.slice.call(arguments, 1);
            return function () {
                var self = (this);
                var newArgs = Array.prototype.slice.call(arguments);
                newArgs.push.apply(newArgs, rightArgs);
                return fn.apply(self, newArgs);
            };
        }
        functions_1.partialRight = partialRight;
        ;
        /**
         * Given a function, create a new function that swallows its return value
         * and replaces it with a new one.
         * @param {Function} f A function.
         * @param {T} retValue A new return value.
         * @return {function(...?):T} A new function.
         * @template T
         */
        function withReturnValue(f, retValue) {
            return goog.functions.sequence(f, goog.functions.constant(retValue));
        }
        functions_1.withReturnValue = withReturnValue;
        ;
        /**
         * Creates a function that returns whether its argument equals the given value.
         *
         * Example:
         * var key = goog.object.findKey(obj, goog.functions.equalTo('needle'));
         *
         * @param {*} value The value to compare to.
         * @param {boolean=} opt_useLooseComparison Whether to use a loose (==)
         *     comparison rather than a strict (===) one. Defaults to false.
         * @return {function(*):boolean} The new function.
         */
        function equalTo(value, opt_useLooseComparison) {
            return function (other) {
                return opt_useLooseComparison ? (value == other) : (value === other);
            };
        }
        functions_1.equalTo = equalTo;
        ;
        /**
         * Creates the composition of the functions passed in.
         * For example, (goog.functions.compose(f, g))(a) is equivalent to f(g(a)).
         * @param {function(...?):T} fn The final function.
         * @param {...Function} var_args A list of functions.
         * @return {function(...?):T} The composition of all inputs.
         * @template T
         */
        function compose(fn) {
            var var_args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                var_args[_i - 1] = arguments[_i];
            }
            var functions = arguments;
            var length = functions.length;
            return function () {
                var self = (this);
                var result;
                if (length) {
                    result = functions[length - 1].apply(self, arguments);
                }
                for (var i = length - 2; i >= 0; i--) {
                    result = functions[i].call(self, result);
                }
                return result;
            };
        }
        functions_1.compose = compose;
        ;
        /**
         * Creates a function that calls the functions passed in in sequence, and
         * returns the value of the last function. For example,
         * (goog.functions.sequence(f, g))(x) is equivalent to f(x),g(x).
         * @param {...Function} var_args A list of functions.
         * @return {!Function} A function that calls all inputs in sequence.
         */
        function sequence() {
            var var_args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                var_args[_i] = arguments[_i];
            }
            var functions = arguments;
            var length = functions.length;
            return function () {
                var self = (this);
                var result;
                for (var i = 0; i < length; i++) {
                    result = functions[i].apply(self, arguments);
                }
                return result;
            };
        }
        functions_1.sequence = sequence;
        ;
        /**
         * Creates a function that returns true if each of its components evaluates
         * to true. The components are evaluated in order, and the evaluation will be
         * short-circuited as soon as a function returns false.
         * For example, (goog.functions.and(f, g))(x) is equivalent to f(x) && g(x).
         * @param {...Function} var_args A list of functions.
         * @return {function(...?):boolean} A function that ANDs its component
         *      functions.
         */
        function and() {
            var var_args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                var_args[_i] = arguments[_i];
            }
            var functions = arguments;
            var length = functions.length;
            return function () {
                var self = (this);
                for (var i = 0; i < length; i++) {
                    if (!functions[i].apply(self, arguments)) {
                        return false;
                    }
                }
                return true;
            };
        }
        functions_1.and = and;
        ;
        /**
         * Creates a function that returns true if any of its components evaluates
         * to true. The components are evaluated in order, and the evaluation will be
         * short-circuited as soon as a function returns true.
         * For example, (goog.functions.or(f, g))(x) is equivalent to f(x) || g(x).
         * @param {...Function} var_args A list of functions.
         * @return {function(...?):boolean} A function that ORs its component
         *    functions.
         */
        function or() {
            var var_args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                var_args[_i] = arguments[_i];
            }
            var functions = arguments;
            var length = functions.length;
            return function () {
                var self = (this);
                for (var i = 0; i < length; i++) {
                    if (functions[i].apply(self, arguments)) {
                        return true;
                    }
                }
                return false;
            };
        }
        functions_1.or = or;
        ;
        /**
         * Creates a function that returns the Boolean opposite of a provided function.
         * For example, (goog.functions.not(f))(x) is equivalent to !f(x).
         * @param {!Function} f The original function.
         * @return {function(...?):boolean} A function that delegates to f and returns
         * opposite.
         */
        function not(f) {
            return function () {
                var self = (this);
                return !f.apply(self, arguments);
            };
        }
        functions_1.not = not;
        ;
        /**
         * Generic factory function to construct an object given the constructor
         * and the arguments. Intended to be bound to create object factories.
         *
         * Example:
         *
         * var factory = goog.partial(goog.functions.create, Class);
         *
         * @param {function(new:T, ...)} constructor The constructor for the Object.
         * @param {...*} var_args The arguments to be passed to the constructor.
         * @return {T} A new instance of the class given in {@code constructor}.
         * @template T
         */
        function create(constructor) {
            var var_args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                var_args[_i - 1] = arguments[_i];
            }
            /**
             * @constructor
             * @final
             */
            var temp = function () { };
            temp.prototype = constructor.prototype;
            // obj will have constructor's prototype in its chain and
            // 'obj instanceof constructor' will be true.
            var obj = new temp();
            // obj is initialized by constructor.
            // arguments is only array-like so lacks shift(), but can be used with
            // the Array prototype function.
            constructor.apply(obj, Array.prototype.slice.call(arguments, 1));
            return obj;
        }
        functions_1.create = create;
        ;
        functions_1.CACHE_RETURN_VALUE = true;
        /**
         * Gives a wrapper function that caches the return value of a parameterless
         * function when first called.
         *
         * When called for the first time, the given function is called and its
         * return value is cached (thus this is only appropriate for idempotent
         * functions).  Subsequent calls will return the cached return value. This
         * allows the evaluation of expensive functions to be delayed until first used.
         *
         * To cache the return values of functions with parameters, see goog.memoize.
         *
         * @param {function():T} fn A function to lazily evaluate.
         * @return {function():T} A wrapped version the function.
         * @template T
         */
        function cacheReturnValue(fn) {
            var called = false;
            var value;
            return function () {
                if (!goog.functions.CACHE_RETURN_VALUE) {
                    return fn();
                }
                if (!called) {
                    value = fn();
                    called = true;
                }
                return value;
            };
        }
        functions_1.cacheReturnValue = cacheReturnValue;
        ;
        /**
         * Wraps a function to allow it to be called, at most, once. All
         * additional calls are no-ops.
         *
         * This is particularly useful for initialization functions
         * that should be called, at most, once.
         *
         * @param {function():*} f Function to call.
         * @return {function():undefined} Wrapped function.
         */
        function once(f) {
            // Keep a reference to the function that we null out when we're done with
            // it -- that way, the function can be GC'd when we're done with it.
            var inner = f;
            return function () {
                if (inner) {
                    var tmp = inner;
                    inner = null;
                    tmp();
                }
            };
        }
        functions_1.once = once;
        ;
        /**
         * Wraps a function to allow it to be called, at most, once per interval
         * (specified in milliseconds). If the wrapper function is called N times within
         * that interval, only the Nth call will go through.
         *
         * This is particularly useful for batching up repeated actions where the
         * last action should win. This can be used, for example, for refreshing an
         * autocomplete pop-up every so often rather than updating with every keystroke,
         * since the final text typed by the user is the one that should produce the
         * final autocomplete results. For more stateful debouncing with support for
         * pausing, resuming, and canceling debounced actions, use {@code
         * goog.async.Debouncer}.
         *
         * @param {function(this:SCOPE, ...?)} f Function to call.
         * @param {number} interval Interval over which to debounce. The function will
         *     only be called after the full interval has elapsed since the last call.
         * @param {SCOPE=} opt_scope Object in whose scope to call the function.
         * @return {function(...?): undefined} Wrapped function.
         * @template SCOPE
         */
        function debounce(f, interval, opt_scope) {
            var timeout = 0;
            return /** @type {function(...?)} */ (function () {
                var var_args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    var_args[_i] = arguments[_i];
                }
                goog.global.clearTimeout(timeout);
                var args = arguments;
                timeout = goog.global.setTimeout(function () {
                    f.apply(opt_scope, args);
                }, interval);
            });
        }
        functions_1.debounce = debounce;
        ;
        /**
         * Wraps a function to allow it to be called, at most, once per interval
         * (specified in milliseconds). If the wrapper function is called N times in
         * that interval, both the 1st and the Nth calls will go through.
         *
         * This is particularly useful for limiting repeated user requests where the
         * the last action should win, but you also don't want to wait until the end of
         * the interval before sending a request out, as it leads to a perception of
         * slowness for the user.
         *
         * @param {function(this:SCOPE, ...?)} f Function to call.
         * @param {number} interval Interval over which to throttle. The function can
         *     only be called once per interval.
         * @param {SCOPE=} opt_scope Object in whose scope to call the function.
         * @return {function(...?): undefined} Wrapped function.
         * @template SCOPE
         */
        function throttle(f, interval, opt_scope) {
            var timeout = 0;
            var shouldFire = false;
            var args = [];
            var handleTimeout = function () {
                timeout = 0;
                if (shouldFire) {
                    shouldFire = false;
                    fire();
                }
            };
            var fire = function () {
                timeout = goog.global.setTimeout(handleTimeout, interval);
                f.apply(opt_scope, args);
            };
            return /** @type {function(...?)} */ (function (var_args) {
                args = arguments;
                if (!timeout) {
                    fire();
                }
                else {
                    shouldFire = true;
                }
            });
        }
        functions_1.throttle = throttle;
        ;
        /**
         * Wraps a function to allow it to be called, at most, once per interval
         * (specified in milliseconds). If the wrapper function is called N times within
         * that interval, only the 1st call will go through.
         *
         * This is particularly useful for limiting repeated user requests where the
         * first request is guaranteed to have all the data required to perform the
         * final action, so there's no need to wait until the end of the interval before
         * sending the request out.
         *
         * @param {function(this:SCOPE, ...?)} f Function to call.
         * @param {number} interval Interval over which to rate-limit. The function will
         *     only be called once per interval, and ignored for the remainer of the
         *     interval.
         * @param {SCOPE=} opt_scope Object in whose scope to call the function.
         * @return {function(...?): undefined} Wrapped function.
         * @template SCOPE
         */
        function rateLimit(f, interval, opt_scope) {
            var timeout = 0;
            var handleTimeout = function () {
                timeout = 0;
            };
            return /** @type {function(...?)} */ (function (var_args) {
                if (!timeout) {
                    timeout = goog.global.setTimeout(handleTimeout, interval);
                    f.apply(opt_scope, arguments);
                }
            });
        }
        functions_1.rateLimit = rateLimit;
        ;
    })(functions = goog.functions || (goog.functions = {}));
})(goog || (goog = {}));
/**
 * @define {boolean} Whether the return value cache should be used.
 *    This should only be used to disable caches when testing.
 */
goog.define('goog.functions.CACHE_RETURN_VALUE', true);
/// <reference path="../array/array" />
/// <reference path="../asserts/asserts" />
/// <reference path="../functions/functions" />
/// <reference path="../math/math" />
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Python style iteration utilities.
 * @author arv@google.com (Erik Arvidsson)
 */
goog.provide('goog.iter');
goog.provide('goog.iter.Iterable');
goog.provide('goog.iter.Iterator');
goog.provide('goog.iter.StopIteration');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.functions');
goog.require('goog.math');
var goog;
(function (goog) {
    var iter;
    (function (iter) {
        /**
         * Singleton Error object that is used to terminate iterations.
         * @const {!Error}
         */
        iter.StopIteration = ('StopIteration' in goog.global) ?
            // For script engines that support legacy iterators.
            goog.global['StopIteration'] :
            { message: 'StopIteration', stack: '' };
    })(iter = goog.iter || (goog.iter = {}));
})(goog || (goog = {}));
(function (goog) {
    var iter;
    (function (iter) {
        var Iterator = /** @class */ (function () {
            /**
             * Class/interface for iterators.  An iterator needs to implement a {@code next}
             * method and it needs to throw a {@code goog.iter.StopIteration} when the
             * iteration passes beyond the end.  Iterators have no {@code hasNext} method.
             * It is recommended to always use the helper functions to iterate over the
             * iterator or in case you are only targeting JavaScript 1.7 for in loops.
             * @constructor
             * @template VALUE
             */
            function Iterator() {
            }
            /**
             * Returns the next value of the iteration.  This will throw the object
             * {@see goog.iter#StopIteration} when the iteration passes the end.
             * @return {VALUE} Any object or value.
             */
            Iterator.prototype.next = function () {
                throw goog.iter.StopIteration;
            };
            ;
            /**
             * Returns the {@code Iterator} object itself.  This is used to implement
             * the iterator protocol in JavaScript 1.7
             * @param {boolean=} opt_keys  Whether to return the keys or values. Default is
             *     to only return the values.  This is being used by the for-in loop (true)
             *     and the for-each-in loop (false).  Even though the param gives a hint
             *     about what the iterator will return there is no guarantee that it will
             *     return the keys when true is passed.
             * @return {!goog.iter.Iterator<VALUE>} The object itself.
             */
            Iterator.prototype.__iterator__ = function (opt_keys) {
                return this;
            };
            ;
            return Iterator;
        }());
        iter.Iterator = Iterator;
    })(iter = goog.iter || (goog.iter = {}));
})(goog || (goog = {}));
(function (goog) {
    var iter;
    (function (iter_1) {
        /**
         * Returns an iterator that knows how to iterate over the values in the object.
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable  If the
         *     object is an iterator it will be returned as is.  If the object has an
         *     {@code __iterator__} method that will be called to get the value
         *     iterator.  If the object is an array-like object we create an iterator
         *     for that.
         * @return {!goog.iter.Iterator<VALUE>} An iterator that knows how to iterate
         *     over the values in {@code iterable}.
         * @template VALUE
         */
        function toIterator(iterable) {
            if (iterable instanceof goog.iter.Iterator) {
                return iterable;
            }
            if (typeof iterable.__iterator__ == 'function') {
                return iterable.__iterator__(false);
            }
            if (goog.isArrayLike(iterable)) {
                var i = 0;
                var newIter = new goog.iter.Iterator;
                newIter.next = function () {
                    while (true) {
                        if (i >= iterable.length) {
                            throw goog.iter.StopIteration;
                        }
                        // Don't include deleted elements.
                        if (!(i in iterable)) {
                            i++;
                            continue;
                        }
                        return iterable[i++];
                    }
                };
                return newIter;
            }
            // TODO(arv): Should we fall back on goog.structs.getValues()?
            throw new Error('Not implemented');
        }
        iter_1.toIterator = toIterator;
        ;
        /**
         * Calls a function for each element in the iterator with the element of the
         * iterator passed as argument.
         *
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable  The iterator
         *     to iterate over. If the iterable is an object {@code toIterator} will be
         *     called on it.
         * @param {function(this:THIS,VALUE,?,!goog.iter.Iterator<VALUE>)} f
         *     The function to call for every element.  This function takes 3 arguments
         *     (the element, undefined, and the iterator) and the return value is
         *     irrelevant.  The reason for passing undefined as the second argument is
         *     so that the same function can be used in {@see goog.array#forEach} as
         *     well as others.  The third parameter is of type "number" for
         *     arraylike objects, undefined, otherwise.
         * @param {THIS=} opt_obj  The object to be used as the value of 'this' within
         *     {@code f}.
         * @template THIS, VALUE
         */
        function forEach(iterable, f, opt_obj) {
            if (goog.isArrayLike(iterable)) {
                try {
                    // NOTES: this passes the index number to the second parameter
                    // of the callback contrary to the documentation above.
                    goog.array.forEach(
                    /** @type {IArrayLike<?>} */ (iterable), f, opt_obj);
                }
                catch (ex) {
                    if (ex !== goog.iter.StopIteration) {
                        throw ex;
                    }
                }
            }
            else {
                iterable = goog.iter.toIterator(iterable);
                try {
                    while (true) {
                        f.call(opt_obj, iterable.next(), undefined, iterable);
                    }
                }
                catch (ex) {
                    if (ex !== goog.iter.StopIteration) {
                        throw ex;
                    }
                }
            }
        }
        iter_1.forEach = forEach;
        ;
        /**
         * Calls a function for every element in the iterator, and if the function
         * returns true adds the element to a new iterator.
         *
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
         *     to iterate over.
         * @param {
         *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
         *     The function to call for every element. This function takes 3 arguments
         *     (the element, undefined, and the iterator) and should return a boolean.
         *     If the return value is true the element will be included in the returned
         *     iterator.  If it is false the element is not included.
         * @param {THIS=} opt_obj The object to be used as the value of 'this' within
         *     {@code f}.
         * @return {!goog.iter.Iterator<VALUE>} A new iterator in which only elements
         *     that passed the test are present.
         * @template THIS, VALUE
         */
        function filter(iterable, f, opt_obj) {
            var iterator = goog.iter.toIterator(iterable);
            var newIter = new goog.iter.Iterator;
            newIter.next = function () {
                while (true) {
                    var val = iterator.next();
                    if (f.call(opt_obj, val, undefined, iterator)) {
                        return val;
                    }
                }
            };
            return newIter;
        }
        iter_1.filter = filter;
        ;
        /**
         * Calls a function for every element in the iterator, and if the function
         * returns false adds the element to a new iterator.
         *
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
         *     to iterate over.
         * @param {
         *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
         *     The function to call for every element. This function takes 3 arguments
         *     (the element, undefined, and the iterator) and should return a boolean.
         *     If the return value is false the element will be included in the returned
         *     iterator.  If it is true the element is not included.
         * @param {THIS=} opt_obj The object to be used as the value of 'this' within
         *     {@code f}.
         * @return {!goog.iter.Iterator<VALUE>} A new iterator in which only elements
         *     that did not pass the test are present.
         * @template THIS, VALUE
         */
        function filterFalse(iterable, f, opt_obj) {
            return goog.iter.filter(iterable, goog.functions.not(f), opt_obj);
        }
        iter_1.filterFalse = filterFalse;
        ;
        /**
         * Creates a new iterator that returns the values in a range.  This function
         * can take 1, 2 or 3 arguments:
         * <pre>
         * range(5) same as range(0, 5, 1)
         * range(2, 5) same as range(2, 5, 1)
         * </pre>
         *
         * @param {number} startOrStop  The stop value if only one argument is provided.
         *     The start value if 2 or more arguments are provided.  If only one
         *     argument is used the start value is 0.
         * @param {number=} opt_stop  The stop value.  If left out then the first
         *     argument is used as the stop value.
         * @param {number=} opt_step  The number to increment with between each call to
         *     next.  This can be negative.
         * @return {!goog.iter.Iterator<number>} A new iterator that returns the values
         *     in the range.
         */
        function range(startOrStop, opt_stop, opt_step) {
            var start = 0;
            var stop = startOrStop;
            var step = opt_step || 1;
            if (arguments.length > 1) {
                start = startOrStop;
                stop = opt_stop;
            }
            if (step == 0) {
                throw new Error('Range step argument must not be zero');
            }
            var newIter = new goog.iter.Iterator;
            newIter.next = function () {
                if (step > 0 && start >= stop || step < 0 && start <= stop) {
                    throw goog.iter.StopIteration;
                }
                var rv = start;
                start += step;
                return rv;
            };
            return newIter;
        }
        iter_1.range = range;
        ;
        /**
         * Joins the values in a iterator with a delimiter.
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
         *     to get the values from.
         * @param {string} deliminator  The text to put between the values.
         * @return {string} The joined value string.
         * @template VALUE
         */
        function join(iterable, deliminator) {
            return goog.iter.toArray(iterable).join(deliminator);
        }
        iter_1.join = join;
        ;
        /**
         * For every element in the iterator call a function and return a new iterator
         * with that value.
         *
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterator to iterate over.
         * @param {
         *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):RESULT} f
         *     The function to call for every element.  This function takes 3 arguments
         *     (the element, undefined, and the iterator) and should return a new value.
         * @param {THIS=} opt_obj The object to be used as the value of 'this' within
         *     {@code f}.
         * @return {!goog.iter.Iterator<RESULT>} A new iterator that returns the
         *     results of applying the function to each element in the original
         *     iterator.
         * @template THIS, VALUE, RESULT
         */
        function map(iterable, f, opt_obj) {
            var iterator = goog.iter.toIterator(iterable);
            var newIter = new goog.iter.Iterator;
            newIter.next = function () {
                var val = iterator.next();
                return f.call(opt_obj, val, undefined, iterator);
            };
            return newIter;
        }
        iter_1.map = map;
        ;
        /**
         * Passes every element of an iterator into a function and accumulates the
         * result.
         *
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
         *     to iterate over.
         * @param {function(this:THIS,VALUE,VALUE):VALUE} f The function to call for
         *     every element. This function takes 2 arguments (the function's previous
         *     result or the initial value, and the value of the current element).
         *     function(previousValue, currentElement) : newValue.
         * @param {VALUE} val The initial value to pass into the function on the first
         *     call.
         * @param {THIS=} opt_obj  The object to be used as the value of 'this' within
         *     f.
         * @return {VALUE} Result of evaluating f repeatedly across the values of
         *     the iterator.
         * @template THIS, VALUE
         */
        function reduce(iterable, f, val, opt_obj) {
            var rval = val;
            goog.iter.forEach(iterable, function (val) { rval = f.call(opt_obj, rval, val); });
            return rval;
        }
        iter_1.reduce = reduce;
        ;
        /**
         * Goes through the values in the iterator. Calls f for each of these, and if
         * any of them returns true, this returns true (without checking the rest). If
         * all return false this will return false.
         *
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
         *     object.
         * @param {
         *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
         *     The function to call for every value. This function takes 3 arguments
         *     (the value, undefined, and the iterator) and should return a boolean.
         * @param {THIS=} opt_obj The object to be used as the value of 'this' within
         *     {@code f}.
         * @return {boolean} true if any value passes the test.
         * @template THIS, VALUE
         */
        function some(iterable, f, opt_obj) {
            iterable = goog.iter.toIterator(iterable);
            try {
                while (true) {
                    if (f.call(opt_obj, iterable.next(), undefined, iterable)) {
                        return true;
                    }
                }
            }
            catch (ex) {
                if (ex !== goog.iter.StopIteration) {
                    throw ex;
                }
            }
            return false;
        }
        iter_1.some = some;
        ;
        /**
         * Goes through the values in the iterator. Calls f for each of these and if any
         * of them returns false this returns false (without checking the rest). If all
         * return true this will return true.
         *
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
         *     object.
         * @param {
         *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
         *     The function to call for every value. This function takes 3 arguments
         *     (the value, undefined, and the iterator) and should return a boolean.
         * @param {THIS=} opt_obj The object to be used as the value of 'this' within
         *     {@code f}.
         * @return {boolean} true if every value passes the test.
         * @template THIS, VALUE
         */
        function every(iterable, f, opt_obj) {
            iterable = goog.iter.toIterator(iterable);
            try {
                while (true) {
                    if (!f.call(opt_obj, iterable.next(), undefined, iterable)) {
                        return false;
                    }
                }
            }
            catch (ex) {
                if (ex !== goog.iter.StopIteration) {
                    throw ex;
                }
            }
            return true;
        }
        iter_1.every = every;
        ;
        /**
         * Takes zero or more iterables and returns one iterator that will iterate over
         * them in the order chained.
         * @param {...!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} var_args Any
         *     number of iterable objects.
         * @return {!goog.iter.Iterator<VALUE>} Returns a new iterator that will
         *     iterate over all the given iterables' contents.
         * @template VALUE
         */
        function chain(var_args) {
            return goog.iter.chainFromIterable(arguments);
        }
        iter_1.chain = chain;
        ;
        /**
         * Takes a single iterable containing zero or more iterables and returns one
         * iterator that will iterate over each one in the order given.
         * @see https://goo.gl/5NRp5d
         * @param {goog.iter.Iterable} iterable The iterable of iterables to chain.
         * @return {!goog.iter.Iterator<VALUE>} Returns a new iterator that will
         *     iterate over all the contents of the iterables contained within
         *     {@code iterable}.
         * @template VALUE
         */
        function chainFromIterable(iterable) {
            var iterator = goog.iter.toIterator(iterable);
            var iter = new goog.iter.Iterator();
            var current = null;
            iter.next = function () {
                while (true) {
                    if (current == null) {
                        var it = iterator.next();
                        current = goog.iter.toIterator(it);
                    }
                    try {
                        return current.next();
                    }
                    catch (ex) {
                        if (ex !== goog.iter.StopIteration) {
                            throw ex;
                        }
                        current = null;
                    }
                }
            };
            return iter;
        }
        iter_1.chainFromIterable = chainFromIterable;
        ;
        /**
         * Builds a new iterator that iterates over the original, but skips elements as
         * long as a supplied function returns true.
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
         *     object.
         * @param {
         *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
         *     The function to call for every value. This function takes 3 arguments
         *     (the value, undefined, and the iterator) and should return a boolean.
         * @param {THIS=} opt_obj The object to be used as the value of 'this' within
         *     {@code f}.
         * @return {!goog.iter.Iterator<VALUE>} A new iterator that drops elements from
         *     the original iterator as long as {@code f} is true.
         * @template THIS, VALUE
         */
        function dropWhile(iterable, f, opt_obj) {
            var iterator = goog.iter.toIterator(iterable);
            var newIter = new goog.iter.Iterator;
            var dropping = true;
            newIter.next = function () {
                while (true) {
                    var val = iterator.next();
                    if (dropping && f.call(opt_obj, val, undefined, iterator)) {
                        continue;
                    }
                    else {
                        dropping = false;
                    }
                    return val;
                }
            };
            return newIter;
        }
        iter_1.dropWhile = dropWhile;
        ;
        /**
         * Builds a new iterator that iterates over the original, but only as long as a
         * supplied function returns true.
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
         *     object.
         * @param {
         *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
         *     The function to call for every value. This function takes 3 arguments
         *     (the value, undefined, and the iterator) and should return a boolean.
         * @param {THIS=} opt_obj This is used as the 'this' object in f when called.
         * @return {!goog.iter.Iterator<VALUE>} A new iterator that keeps elements in
         *     the original iterator as long as the function is true.
         * @template THIS, VALUE
         */
        function takeWhile(iterable, f, opt_obj) {
            var iterator = goog.iter.toIterator(iterable);
            var iter = new goog.iter.Iterator();
            iter.next = function () {
                var val = iterator.next();
                if (f.call(opt_obj, val, undefined, iterator)) {
                    return val;
                }
                throw goog.iter.StopIteration;
            };
            return iter;
        }
        iter_1.takeWhile = takeWhile;
        ;
        /**
         * Converts the iterator to an array
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
         *     to convert to an array.
         * @return {!Array<VALUE>} An array of the elements the iterator iterates over.
         * @template VALUE
         */
        function toArray(iterable) {
            // Fast path for array-like.
            if (goog.isArrayLike(iterable)) {
                return goog.array.toArray(/** @type {!IArrayLike<?>} */ (iterable));
            }
            iterable = goog.iter.toIterator(iterable);
            var array = [];
            goog.iter.forEach(iterable, function (val) { array.push(val); });
            return array;
        }
        iter_1.toArray = toArray;
        ;
        /**
         * Iterates over two iterables and returns true if they contain the same
         * sequence of elements and have the same length.
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable1 The first
         *     iterable object.
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable2 The second
         *     iterable object.
         * @param {function(VALUE,VALUE):boolean=} opt_equalsFn Optional comparison
         *     function.
         *     Should take two arguments to compare, and return true if the arguments
         *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
         *     compares the elements using the built-in '===' operator.
         * @return {boolean} true if the iterables contain the same sequence of elements
         *     and have the same length.
         * @template VALUE
         */
        function equals(iterable1, iterable2, opt_equalsFn) {
            var fillValue = {};
            var pairs = goog.iter.zipLongest(fillValue, iterable1, iterable2);
            var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
            return goog.iter.every(pairs, function (pair) { return equalsFn(pair[0], pair[1]); });
        }
        iter_1.equals = equals;
        ;
        /**
         * Advances the iterator to the next position, returning the given default value
         * instead of throwing an exception if the iterator has no more entries.
         * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterable
         *     object.
         * @param {VALUE} defaultValue The value to return if the iterator is empty.
         * @return {VALUE} The next item in the iteration, or defaultValue if the
         *     iterator was empty.
         * @template VALUE
         */
        function nextOrValue(iterable, defaultValue) {
            try {
                return goog.iter.toIterator(iterable).next();
            }
            catch (e) {
                if (e != goog.iter.StopIteration) {
                    throw e;
                }
                return defaultValue;
            }
        }
        iter_1.nextOrValue = nextOrValue;
        ;
        /**
         * Cartesian product of zero or more sets.  Gives an iterator that gives every
         * combination of one element chosen from each set.  For example,
         * ([1, 2], [3, 4]) gives ([1, 3], [1, 4], [2, 3], [2, 4]).
         * @see http://docs.python.org/library/itertools.html#itertools.product
         * @param {...!IArrayLike<VALUE>} var_args Zero or more sets, as
         *     arrays.
         * @return {!goog.iter.Iterator<!Array<VALUE>>} An iterator that gives each
         *     n-tuple (as an array).
         * @template VALUE
         */
        function product(var_args) {
            var someArrayEmpty = goog.array.some(arguments, function (arr) { return !arr.length; });
            // An empty set in a cartesian product gives an empty set.
            if (someArrayEmpty || !arguments.length) {
                return new goog.iter.Iterator();
            }
            var iter = new goog.iter.Iterator();
            var arrays = arguments;
            // The first indices are [0, 0, ...]
            /** @type {?Array<number>} */
            var indicies = goog.array.repeat(0, arrays.length);
            iter.next = function () {
                if (indicies) {
                    var retVal = goog.array.map(indicies, function (valueIndex, arrayIndex) {
                        return arrays[arrayIndex][valueIndex];
                    });
                    // Generate the next-largest indices for the next call.
                    // Increase the rightmost index. If it goes over, increase the next
                    // rightmost (like carry-over addition).
                    for (var i = indicies.length - 1; i >= 0; i--) {
                        // Assertion prevents compiler warning below.
                        goog.asserts.assert(indicies);
                        if (indicies[i] < arrays[i].length - 1) {
                            indicies[i]++;
                            break;
                        }
                        // We're at the last indices (the last element of every array), so
                        // the iteration is over on the next call.
                        if (i == 0) {
                            indicies = null;
                            break;
                        }
                        // Reset the index in this column and loop back to increment the
                        // next one.
                        indicies[i] = 0;
                    }
                    return retVal;
                }
                throw goog.iter.StopIteration;
            };
            return iter;
        }
        iter_1.product = product;
        ;
        /**
         * Create an iterator to cycle over the iterable's elements indefinitely.
         * For example, ([1, 2, 3]) would return : 1, 2, 3, 1, 2, 3, ...
         * @see: http://docs.python.org/library/itertools.html#itertools.cycle.
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable object.
         * @return {!goog.iter.Iterator<VALUE>} An iterator that iterates indefinitely
         *     over the values in {@code iterable}.
         * @template VALUE
         */
        function cycle(iterable) {
            var baseIterator = goog.iter.toIterator(iterable);
            // We maintain a cache to store the iterable elements as we iterate
            // over them. The cache is used to return elements once we have
            // iterated over the iterable once.
            var cache = [];
            var cacheIndex = 0;
            var iter = new goog.iter.Iterator();
            // This flag is set after the iterable is iterated over once
            var useCache = false;
            iter.next = function () {
                var returnElement = null;
                // Pull elements off the original iterator if not using cache
                if (!useCache) {
                    try {
                        // Return the element from the iterable
                        returnElement = baseIterator.next();
                        cache.push(returnElement);
                        return returnElement;
                    }
                    catch (e) {
                        // If an exception other than StopIteration is thrown
                        // or if there are no elements to iterate over (the iterable was empty)
                        // throw an exception
                        if (e != goog.iter.StopIteration || goog.array.isEmpty(cache)) {
                            throw e;
                        }
                        // set useCache to true after we know that a 'StopIteration' exception
                        // was thrown and the cache is not empty (to handle the 'empty iterable'
                        // use case)
                        useCache = true;
                    }
                }
                returnElement = cache[cacheIndex];
                cacheIndex = (cacheIndex + 1) % cache.length;
                return returnElement;
            };
            return iter;
        }
        iter_1.cycle = cycle;
        ;
        /**
         * Creates an iterator that counts indefinitely from a starting value.
         * @see http://docs.python.org/2/library/itertools.html#itertools.count
         * @param {number=} opt_start The starting value. Default is 0.
         * @param {number=} opt_step The number to increment with between each call to
         *     next. Negative and floating point numbers are allowed. Default is 1.
         * @return {!goog.iter.Iterator<number>} A new iterator that returns the values
         *     in the series.
         */
        function count(opt_start, opt_step) {
            var counter = opt_start || 0;
            var step = goog.isDef(opt_step) ? opt_step : 1;
            var iter = new goog.iter.Iterator();
            iter.next = function () {
                var returnValue = counter;
                counter += step;
                return returnValue;
            };
            return iter;
        }
        iter_1.count = count;
        ;
        /**
         * Creates an iterator that returns the same object or value repeatedly.
         * @param {VALUE} value Any object or value to repeat.
         * @return {!goog.iter.Iterator<VALUE>} A new iterator that returns the
         *     repeated value.
         * @template VALUE
         */
        function repeat(value) {
            var iter = new goog.iter.Iterator();
            iter.next = goog.functions.constant(value);
            return iter;
        }
        iter_1.repeat = repeat;
        ;
        /**
         * Creates an iterator that returns running totals from the numbers in
         * {@code iterable}. For example, the array {@code [1, 2, 3, 4, 5]} yields
         * {@code 1 -> 3 -> 6 -> 10 -> 15}.
         * @see http://docs.python.org/3.2/library/itertools.html#itertools.accumulate
         * @param {!goog.iter.Iterable} iterable The iterable of numbers to
         *     accumulate.
         * @return {!goog.iter.Iterator<number>} A new iterator that returns the
         *     numbers in the series.
         */
        function accumulate(iterable) {
            var iterator = goog.iter.toIterator(iterable);
            var total = 0;
            var iter = new goog.iter.Iterator();
            iter.next = function () {
                total += iterator.next();
                return total;
            };
            return iter;
        }
        iter_1.accumulate = accumulate;
        ;
        /**
         * Creates an iterator that returns arrays containing the ith elements from the
         * provided iterables. The returned arrays will be the same size as the number
         * of iterables given in {@code var_args}. Once the shortest iterable is
         * exhausted, subsequent calls to {@code next()} will throw
         * {@code goog.iter.StopIteration}.
         * @see http://docs.python.org/2/library/itertools.html#itertools.izip
         * @param {...!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} var_args Any
         *     number of iterable objects.
         * @return {!goog.iter.Iterator<!Array<VALUE>>} A new iterator that returns
         *     arrays of elements from the provided iterables.
         * @template VALUE
         */
        function zip() {
            var var_args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                var_args[_i] = arguments[_i];
            }
            var args = arguments;
            var iter = new goog.iter.Iterator();
            if (args.length > 0) {
                var iterators = goog.array.map(args, goog.iter.toIterator);
                iter.next = function () {
                    var arr = goog.array.map(iterators, function (it) { return it.next(); });
                    return arr;
                };
            }
            return iter;
        }
        iter_1.zip = zip;
        ;
        /**
         * Creates an iterator that returns arrays containing the ith elements from the
         * provided iterables. The returned arrays will be the same size as the number
         * of iterables given in {@code var_args}. Shorter iterables will be extended
         * with {@code fillValue}. Once the longest iterable is exhausted, subsequent
         * calls to {@code next()} will throw {@code goog.iter.StopIteration}.
         * @see http://docs.python.org/2/library/itertools.html#itertools.izip_longest
         * @param {VALUE} fillValue The object or value used to fill shorter iterables.
         * @param {...!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} var_args Any
         *     number of iterable objects.
         * @return {!goog.iter.Iterator<!Array<VALUE>>} A new iterator that returns
         *     arrays of elements from the provided iterables.
         * @template VALUE
         */
        function zipLongest(fillValue) {
            var var_args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                var_args[_i - 1] = arguments[_i];
            }
            var args = goog.array.slice(arguments, 1);
            var iter = new goog.iter.Iterator();
            if (args.length > 0) {
                var iterators = goog.array.map(args, goog.iter.toIterator);
                iter.next = function () {
                    var iteratorsHaveValues = false; // false when all iterators are empty.
                    var arr = goog.array.map(iterators, function (it) {
                        var returnValue;
                        try {
                            returnValue = it.next();
                            // Iterator had a value, so we've not exhausted the iterators.
                            // Set flag accordingly.
                            iteratorsHaveValues = true;
                        }
                        catch (ex) {
                            if (ex !== goog.iter.StopIteration) {
                                throw ex;
                            }
                            returnValue = fillValue;
                        }
                        return returnValue;
                    });
                    if (!iteratorsHaveValues) {
                        throw goog.iter.StopIteration;
                    }
                    return arr;
                };
            }
            return iter;
        }
        iter_1.zipLongest = zipLongest;
        ;
        /**
         * Creates an iterator that filters {@code iterable} based on a series of
         * {@code selectors}. On each call to {@code next()}, one item is taken from
         * both the {@code iterable} and {@code selectors} iterators. If the item from
         * {@code selectors} evaluates to true, the item from {@code iterable} is given.
         * Otherwise, it is skipped. Once either {@code iterable} or {@code selectors}
         * is exhausted, subsequent calls to {@code next()} will throw
         * {@code goog.iter.StopIteration}.
         * @see http://docs.python.org/2/library/itertools.html#itertools.compress
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable to filter.
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} selectors An
         *     iterable of items to be evaluated in a boolean context to determine if
         *     the corresponding element in {@code iterable} should be included in the
         *     result.
         * @return {!goog.iter.Iterator<VALUE>} A new iterator that returns the
         *     filtered values.
         * @template VALUE
         */
        function compress(iterable, selectors) {
            var selectorIterator = goog.iter.toIterator(selectors);
            return goog.iter.filter(iterable, function () { return !!selectorIterator.next(); });
        }
        iter_1.compress = compress;
        ;
        /**
         * Creates an iterator that returns arrays containing elements from the
         * {@code iterable} grouped by a key value. For iterables with repeated
         * elements (i.e. sorted according to a particular key function), this function
         * has a {@code uniq}-like effect. For example, grouping the array:
         * {@code [A, B, B, C, C, A]} produces
         * {@code [A, [A]], [B, [B, B]], [C, [C, C]], [A, [A]]}.
         * @see http://docs.python.org/2/library/itertools.html#itertools.groupby
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable to group.
         * @param {function(VALUE): KEY=} opt_keyFunc  Optional function for
         *     determining the key value for each group in the {@code iterable}. Default
         *     is the identity function.
         * @return {!goog.iter.Iterator<!Array<?>>} A new iterator that returns
         *     arrays of consecutive key and groups.
         * @template KEY, VALUE
         */
        function groupBy(iterable, opt_keyFunc) {
            return new goog.iter.GroupByIterator_(iterable, opt_keyFunc);
        }
        iter_1.groupBy = groupBy;
        ;
        /**
         * Gives an iterator that gives the result of calling the given function
         * <code>f</code> with the arguments taken from the next element from
         * <code>iterable</code> (the elements are expected to also be iterables).
         *
         * Similar to {@see goog.iter#map} but allows the function to accept multiple
         * arguments from the iterable.
         *
         * @param {!goog.iter.Iterable} iterable The iterable of
         *     iterables to iterate over.
         * @param {function(this:THIS,...*):RESULT} f The function to call for every
         *     element.  This function takes N+2 arguments, where N represents the
         *     number of items from the next element of the iterable. The two
         *     additional arguments passed to the function are undefined and the
         *     iterator itself. The function should return a new value.
         * @param {THIS=} opt_obj The object to be used as the value of 'this' within
         *     {@code f}.
         * @return {!goog.iter.Iterator<RESULT>} A new iterator that returns the
         *     results of applying the function to each element in the original
         *     iterator.
         * @template THIS, RESULT
         */
        function starMap(iterable, f, opt_obj) {
            var iterator = goog.iter.toIterator(iterable);
            var iter = new goog.iter.Iterator();
            iter.next = function () {
                var args = goog.iter.toArray(iterator.next());
                return f.apply(opt_obj, goog.array.concat(args, undefined, iterator));
            };
            return iter;
        }
        iter_1.starMap = starMap;
        ;
        /**
         * Returns an array of iterators each of which can iterate over the values in
         * {@code iterable} without advancing the others.
         * @see http://docs.python.org/2/library/itertools.html#itertools.tee
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable to tee.
         * @param {number=} opt_num  The number of iterators to create. Default is 2.
         * @return {!Array<goog.iter.Iterator<VALUE>>} An array of iterators.
         * @template VALUE
         */
        function tee(iterable, opt_num) {
            var iterator = goog.iter.toIterator(iterable);
            var num = goog.isNumber(opt_num) ? opt_num : 2;
            var buffers = goog.array.map(goog.array.range(num), function () { return []; });
            var addNextIteratorValueToBuffers = function () {
                var val = iterator.next();
                goog.array.forEach(buffers, function (buffer) { buffer.push(val); });
            };
            var createIterator = function (buffer) {
                // Each tee'd iterator has an associated buffer (initially empty). When a
                // tee'd iterator's buffer is empty, it calls
                // addNextIteratorValueToBuffers(), adding the next value to all tee'd
                // iterators' buffers, and then returns that value. This allows each
                // iterator to be advanced independently.
                var iter = new goog.iter.Iterator();
                iter.next = function () {
                    if (goog.array.isEmpty(buffer)) {
                        addNextIteratorValueToBuffers();
                    }
                    goog.asserts.assert(!goog.array.isEmpty(buffer));
                    return buffer.shift();
                };
                return iter;
            };
            return goog.array.map(buffers, createIterator);
        }
        iter_1.tee = tee;
        ;
        /**
         * Creates an iterator that returns arrays containing a count and an element
         * obtained from the given {@code iterable}.
         * @see http://docs.python.org/2/library/functions.html#enumerate
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable to enumerate.
         * @param {number=} opt_start  Optional starting value. Default is 0.
         * @return {!goog.iter.Iterator<!Array<?>>} A new iterator containing
         *     count/item pairs.
         * @template VALUE
         */
        function enumerate(iterable, opt_start) {
            return goog.iter.zip(goog.iter.count(opt_start), iterable);
        }
        iter_1.enumerate = enumerate;
        ;
        /**
         * Creates an iterator that returns the first {@code limitSize} elements from an
         * iterable. If this number is greater than the number of elements in the
         * iterable, all the elements are returned.
         * @see http://goo.gl/V0sihp Inspired by the limit iterator in Guava.
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable to limit.
         * @param {number} limitSize  The maximum number of elements to return.
         * @return {!goog.iter.Iterator<VALUE>} A new iterator containing
         *     {@code limitSize} elements.
         * @template VALUE
         */
        function limit(iterable, limitSize) {
            goog.asserts.assert(goog.math.isInt(limitSize) && limitSize >= 0);
            var iterator = goog.iter.toIterator(iterable);
            var iter = new goog.iter.Iterator();
            var remaining = limitSize;
            iter.next = function () {
                if (remaining-- > 0) {
                    return iterator.next();
                }
                throw goog.iter.StopIteration;
            };
            return iter;
        }
        iter_1.limit = limit;
        ;
        /**
         * Creates an iterator that is advanced {@code count} steps ahead. Consumed
         * values are silently discarded. If {@code count} is greater than the number
         * of elements in {@code iterable}, an empty iterator is returned. Subsequent
         * calls to {@code next()} will throw {@code goog.iter.StopIteration}.
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable to consume.
         * @param {number} count  The number of elements to consume from the iterator.
         * @return {!goog.iter.Iterator<VALUE>} An iterator advanced zero or more steps
         *     ahead.
         * @template VALUE
         */
        function consume(iterable, count) {
            goog.asserts.assert(goog.math.isInt(count) && count >= 0);
            var iterator = goog.iter.toIterator(iterable);
            while (count-- > 0) {
                goog.iter.nextOrValue(iterator, null);
            }
            return iterator;
        }
        iter_1.consume = consume;
        ;
        /**
         * Creates an iterator that returns a range of elements from an iterable.
         * Similar to {@see goog.array#slice} but does not support negative indexes.
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable to slice.
         * @param {number} start  The index of the first element to return.
         * @param {number=} opt_end  The index after the last element to return. If
         *     defined, must be greater than or equal to {@code start}.
         * @return {!goog.iter.Iterator<VALUE>} A new iterator containing a slice of
         *     the original.
         * @template VALUE
         */
        function slice(iterable, start, opt_end) {
            goog.asserts.assert(goog.math.isInt(start) && start >= 0);
            var iterator = goog.iter.consume(iterable, start);
            if (goog.isNumber(opt_end)) {
                goog.asserts.assert(goog.math.isInt(opt_end) && opt_end >= start);
                iterator = goog.iter.limit(iterator, opt_end - start /* limitSize */);
            }
            return iterator;
        }
        iter_1.slice = slice;
        ;
        /**
         * Checks an array for duplicate elements.
         * @param {?IArrayLike<VALUE>} arr The array to check for
         *     duplicates.
         * @return {boolean} True, if the array contains duplicates, false otherwise.
         * @private
         * @template VALUE
         */
        // TODO(user): Consider moving this into goog.array as a public function.
        function hasDuplicates_(arr) {
            var deduped = [];
            goog.array.removeDuplicates(arr, deduped);
            return arr.length != deduped.length;
        }
        iter_1.hasDuplicates_ = hasDuplicates_;
        ;
        /**
         * Creates an iterator that returns permutations of elements in
         * {@code iterable}.
         *
         * Permutations are obtained by taking the Cartesian product of
         * {@code opt_length} iterables and filtering out those with repeated
         * elements. For example, the permutations of {@code [1,2,3]} are
         * {@code [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]}.
         * @see http://docs.python.org/2/library/itertools.html#itertools.permutations
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable from which to generate permutations.
         * @param {number=} opt_length Length of each permutation. If omitted, defaults
         *     to the length of {@code iterable}.
         * @return {!goog.iter.Iterator<!Array<VALUE>>} A new iterator containing the
         *     permutations of {@code iterable}.
         * @template VALUE
         */
        function permutations(iterable, opt_length) {
            var elements = goog.iter.toArray(iterable);
            var length = goog.isNumber(opt_length) ? opt_length : elements.length;
            var sets = goog.array.repeat(elements, length);
            var product = goog.iter.product.apply(undefined, sets);
            return goog.iter.filter(product, function (arr) { return !goog.iter.hasDuplicates_(arr); });
        }
        iter_1.permutations = permutations;
        ;
        /**
         * Creates an iterator that returns combinations of elements from
         * {@code iterable}.
         *
         * Combinations are obtained by taking the {@see goog.iter#permutations} of
         * {@code iterable} and filtering those whose elements appear in the order they
         * are encountered in {@code iterable}. For example, the 3-length combinations
         * of {@code [0,1,2,3]} are {@code [[0,1,2], [0,1,3], [0,2,3], [1,2,3]]}.
         * @see http://docs.python.org/2/library/itertools.html#itertools.combinations
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable from which to generate combinations.
         * @param {number} length The length of each combination.
         * @return {!goog.iter.Iterator<!Array<VALUE>>} A new iterator containing
         *     combinations from the {@code iterable}.
         * @template VALUE
         */
        function combinations(iterable, length) {
            var elements = goog.iter.toArray(iterable);
            var indexes = goog.iter.range(elements.length);
            var indexIterator = goog.iter.permutations(indexes, length);
            // sortedIndexIterator will now give arrays of with the given length that
            // indicate what indexes into "elements" should be returned on each iteration.
            var sortedIndexIterator = goog.iter.filter(indexIterator, function (arr) { return goog.array.isSorted(arr); });
            var iter = new goog.iter.Iterator();
            function getIndexFromElements(index) { return elements[index]; }
            iter.next = function () {
                return goog.array.map(sortedIndexIterator.next(), getIndexFromElements);
            };
            return iter;
        }
        iter_1.combinations = combinations;
        ;
        /**
         * Creates an iterator that returns combinations of elements from
         * {@code iterable}, with repeated elements possible.
         *
         * Combinations are obtained by taking the Cartesian product of {@code length}
         * iterables and filtering those whose elements appear in the order they are
         * encountered in {@code iterable}. For example, the 2-length combinations of
         * {@code [1,2,3]} are {@code [[1,1], [1,2], [1,3], [2,2], [2,3], [3,3]]}.
         * @see https://goo.gl/C0yXe4
         * @see https://goo.gl/djOCsk
         * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
         *     iterable to combine.
         * @param {number} length The length of each combination.
         * @return {!goog.iter.Iterator<!Array<VALUE>>} A new iterator containing
         *     combinations from the {@code iterable}.
         * @template VALUE
         */
        function combinationsWithReplacement(iterable, length) {
            var elements = goog.iter.toArray(iterable);
            var indexes = goog.array.range(elements.length);
            var sets = goog.array.repeat(indexes, length);
            var indexIterator = goog.iter.product.apply(undefined, sets);
            // sortedIndexIterator will now give arrays of with the given length that
            // indicate what indexes into "elements" should be returned on each iteration.
            var sortedIndexIterator = goog.iter.filter(indexIterator, function (arr) { return goog.array.isSorted(arr); });
            var iter = new goog.iter.Iterator();
            function getIndexFromElements(index) { return elements[index]; }
            iter.next = function () {
                return goog.array.map(
                /** @type {!Array<number>} */
                (sortedIndexIterator.next()), getIndexFromElements);
            };
            return iter;
        }
        iter_1.combinationsWithReplacement = combinationsWithReplacement;
        ;
    })(iter = goog.iter || (goog.iter = {}));
})(goog || (goog = {}));
(function (goog) {
    var iter;
    (function (iter) {
        var GroupByIterator_ = /** @class */ (function (_super) {
            __extends(GroupByIterator_, _super);
            /**
             * Implements the {@code goog.iter.groupBy} iterator.
             * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
             *     iterable to group.
             * @param {function(VALUE): KEY=} opt_keyFunc  Optional function for
             *     determining the key value for each group in the {@code iterable}. Default
             *     is the identity function.
             * @constructor
             * @extends {goog.iter.Iterator<!Array<?>>}
             * @template KEY, VALUE
             * @private
             */
            function GroupByIterator_(iterable, opt_keyFunc) {
                var _this = _super.call(this) || this;
                /**
                 * The iterable to group, coerced to an iterator.
                 * @type {!goog.iter.Iterator}
                 */
                _this.iterator = goog.iter.toIterator(iterable);
                /**
                 * A function for determining the key value for each element in the iterable.
                 * If no function is provided, the identity function is used and returns the
                 * element unchanged.
                 * @type {function(VALUE): KEY}
                 */
                _this.keyFunc = opt_keyFunc || goog.functions.identity;
                /**
                 * The target key for determining the start of a group.
                 * @type {KEY}
                 */
                _this.targetKey;
                /**
                 * The current key visited during iteration.
                 * @type {KEY}
                 */
                _this.currentKey;
                /**
                 * The current value being added to the group.
                 * @type {VALUE}
                 */
                _this.currentValue;
                return _this;
            }
            /** @override */
            GroupByIterator_.prototype.next = function () {
                while (this.currentKey == this.targetKey) {
                    this.currentValue = this.iterator.next(); // Exits on StopIteration
                    this.currentKey = this.keyFunc(this.currentValue);
                }
                this.targetKey = this.currentKey;
                return [this.currentKey, this.groupItems_(this.targetKey)];
            };
            ;
            /**
             * Performs the grouping of objects using the given key.
             * @param {KEY} targetKey  The target key object for the group.
             * @return {!Array<VALUE>} An array of grouped objects.
             * @private
             */
            GroupByIterator_.prototype.groupItems_ = function (targetKey) {
                var arr = [];
                while (this.currentKey == targetKey) {
                    arr.push(this.currentValue);
                    try {
                        this.currentValue = this.iterator.next();
                    }
                    catch (ex) {
                        if (ex !== goog.iter.StopIteration) {
                            throw ex;
                        }
                        break;
                    }
                    this.currentKey = this.keyFunc(this.currentValue);
                }
                return arr;
            };
            ;
            return GroupByIterator_;
        }(goog.iter.Iterator));
        iter.GroupByIterator_ = GroupByIterator_;
    })(iter = goog.iter || (goog.iter = {}));
})(goog || (goog = {}));
/// <reference path="../base.ts" />
/// <reference path="../debug/debug" />
/// <reference path="../debug/LogRecord" />
/// <reference path="../debug/Logger" />
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Basic strippable logging definitions.
 * @see http://go/closurelogging
 *
 * @author johnlenz@google.com (John Lenz)
 */
goog.provide('goog.log');
goog.provide('goog.log.Level');
goog.provide('goog.log.LogRecord');
goog.provide('goog.log.Logger');
goog.require('goog.debug');
goog.require('goog.debug.LogManager');
goog.require('goog.debug.LogRecord');
goog.require('goog.debug.Logger');
var goog;
(function (goog) {
    var log;
    (function (log) {
        log.ENABLED = goog.debug.LOGGING_ENABLED;
        /** @const {string} */
        log.ROOT_LOGGER_NAME = goog.debug.Logger.ROOT_LOGGER_NAME;
    })(log = goog.log || (goog.log = {}));
})(goog || (goog = {}));
/** @define {boolean} Whether logging is enabled. */
goog.define('goog.log.ENABLED', goog.debug.LOGGING_ENABLED);
(function (goog) {
    var log;
    (function (log) {
        var Logger = /** @class */ (function () {
            /**
             * @constructor
             * @final
             */
            function Logger(name) {
                new goog.debug.Logger(name);
            }
            return Logger;
        }());
        log.Logger = Logger;
        var Level = /** @class */ (function () {
            /**
             * @constructor
             * @final
             */
            function Level(name, value) {
                new goog.debug.Logger.Level(name, value);
            }
            return Level;
        }());
        log.Level = Level;
        var LogRecord = /** @class */ (function () {
            /**
             * @constructor
             * @final
             */
            function LogRecord(level, msg, loggerName, opt_time, opt_sequenceNumber) {
                new goog.debug.LogRecord(level, msg, loggerName, opt_time, opt_sequenceNumber);
            }
            return LogRecord;
        }());
        log.LogRecord = LogRecord;
    })(log = goog.log || (goog.log = {}));
})(goog || (goog = {}));
(function (goog) {
    var log;
    (function (log_1) {
        /**
         * Finds or creates a logger for a named subsystem. If a logger has already been
         * created with the given name it is returned. Otherwise a new logger is
         * created. If a new logger is created its log level will be configured based
         * on the goog.debug.LogManager configuration and it will configured to also
         * send logging output to its parent's handlers.
         * @see goog.debug.LogManager
         *
         * @param {string} name A name for the logger. This should be a dot-separated
         *     name and should normally be based on the package name or class name of
         *     the subsystem, such as goog.net.BrowserChannel.
         * @param {goog.log.Level=} opt_level If provided, override the
         *     default logging level with the provided level.
         * @return {goog.log.Logger} The named logger or null if logging is disabled.
         */
        function getLogger(name, opt_level) {
            if (goog.log.ENABLED) {
                var logger = goog.debug.LogManager.getLogger(name);
                if (opt_level && logger) {
                    logger.setLevel(opt_level);
                }
                return logger;
            }
            else {
                return null;
            }
        }
        log_1.getLogger = getLogger;
        ;
        // TODO(johnlenz): try to tighten the types to these functions.
        /**
         * Adds a handler to the logger. This doesn't use the event system because
         * we want to be able to add logging to the event system.
         * @param {goog.log.Logger} logger
         * @param {Function} handler Handler function to add.
         */
        function addHandler(logger, handler) {
            if (goog.log.ENABLED && logger) {
                logger.addHandler(handler);
            }
        }
        log_1.addHandler = addHandler;
        ;
        /**
         * Removes a handler from the logger. This doesn't use the event system because
         * we want to be able to add logging to the event system.
         * @param {goog.log.Logger} logger
         * @param {Function} handler Handler function to remove.
         * @return {boolean} Whether the handler was removed.
         */
        function removeHandler(logger, handler) {
            if (goog.log.ENABLED && logger) {
                return logger.removeHandler(handler);
            }
            else {
                return false;
            }
        }
        log_1.removeHandler = removeHandler;
        ;
        /**
         * Logs a message. If the logger is currently enabled for the
         * given message level then the given message is forwarded to all the
         * registered output Handler objects.
         * @param {goog.log.Logger} logger
         * @param {goog.log.Level} level One of the level identifiers.
         * @param {goog.debug.Loggable} msg The message to log.
         * @param {Error|Object=} opt_exception An exception associated with the
         *     message.
         */
        function log(logger, level, msg, opt_exception) {
            if (goog.log.ENABLED && logger) {
                logger.log(level, msg, opt_exception);
            }
        }
        log_1.log = log;
        ;
        /**
         * Logs a message at the Level.SEVERE level.
         * If the logger is currently enabled for the given message level then the
         * given message is forwarded to all the registered output Handler objects.
         * @param {goog.log.Logger} logger
         * @param {goog.debug.Loggable} msg The message to log.
         * @param {Error=} opt_exception An exception associated with the message.
         */
        function error(logger, msg, opt_exception) {
            if (goog.log.ENABLED && logger) {
                logger.severe(msg, opt_exception);
            }
        }
        log_1.error = error;
        ;
        /**
         * Logs a message at the Level.WARNING level.
         * If the logger is currently enabled for the given message level then the
         * given message is forwarded to all the registered output Handler objects.
         * @param {goog.log.Logger} logger
         * @param {goog.debug.Loggable} msg The message to log.
         * @param {Error=} opt_exception An exception associated with the message.
         */
        function warning(logger, msg, opt_exception) {
            if (goog.log.ENABLED && logger) {
                logger.warning(msg, opt_exception);
            }
        }
        log_1.warning = warning;
        ;
        /**
         * Logs a message at the Level.INFO level.
         * If the logger is currently enabled for the given message level then the
         * given message is forwarded to all the registered output Handler objects.
         * @param {goog.log.Logger} logger
         * @param {goog.debug.Loggable} msg The message to log.
         * @param {Error=} opt_exception An exception associated with the message.
         */
        function info(logger, msg, opt_exception) {
            if (goog.log.ENABLED && logger) {
                logger.info(msg, opt_exception);
            }
        }
        log_1.info = info;
        ;
        /**
         * Logs a message at the Level.Fine level.
         * If the logger is currently enabled for the given message level then the
         * given message is forwarded to all the registered output Handler objects.
         * @param {goog.log.Logger} logger
         * @param {goog.debug.Loggable} msg The message to log.
         * @param {Error=} opt_exception An exception associated with the message.
         */
        function fine(logger, msg, opt_exception) {
            if (goog.log.ENABLED && logger) {
                logger.fine(msg, opt_exception);
            }
        }
        log_1.fine = fine;
        ;
    })(log = goog.log || (goog.log = {}));
})(goog || (goog = {}));
/// <reference path="../iter/iter" />
/// <reference path="../object/object" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Datastructure: Hash Map.
 *
 * @author arv@google.com (Erik Arvidsson)
 *
 * This file contains an implementation of a Map structure. It implements a lot
 * of the methods used in goog.structs so those functions work on hashes. This
 * is best suited for complex key types. For simple keys such as numbers and
 * strings consider using the lighter-weight utilities in goog.object.
 */
goog.provide('goog.structs.Map');
goog.require('goog.iter.Iterator');
goog.require('goog.iter.StopIteration');
goog.require('goog.object');
var goog;
(function (goog) {
    var structs;
    (function (structs) {
        var Map = /** @class */ (function () {
            /**
             * Class for Hash Map datastructure.
             * @param {*=} opt_map Map or Object to initialize the map with.
             * @param {...*} var_args If 2 or more arguments are present then they
             *     will be used as key-value pairs.
             * @constructor
             * @template K, V
             * @deprecated This type is misleading: use ES6 Map instead.
             */
            function Map(opt_map) {
                var var_args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    var_args[_i - 1] = arguments[_i];
                }
                /**
                 * Underlying JS object used to implement the map.
                 * @private {!Object}
                 */
                this.map_ = {};
                /**
                 * An array of keys. This is necessary for two reasons:
                 *   1. Iterating the keys using for (var key in this.map_) allocates an
                 *      object for every key in IE which is really bad for IE6 GC perf.
                 *   2. Without a side data structure, we would need to escape all the keys
                 *      as that would be the only way we could tell during iteration if the
                 *      key was an internal key or a property of the object.
                 *
                 * This array can contain deleted keys so it's necessary to check the map
                 * as well to see if the key is still in the map (this doesn't require a
                 * memory allocation in IE).
                 * @private {!Array<string>}
                 */
                this.keys_ = [];
                /**
                 * The number of key value pairs in the map.
                 * @private {number}
                 */
                this.count_ = 0;
                /**
                 * Version used to detect changes while iterating.
                 * @private {number}
                 */
                this.version_ = 0;
                var argLength = arguments.length;
                if (argLength > 1) {
                    if (argLength % 2) {
                        throw new Error('Uneven number of arguments');
                    }
                    for (var i = 0; i < argLength; i += 2) {
                        this.set(arguments[i], arguments[i + 1]);
                    }
                }
                else if (opt_map) {
                    this.addAll(/** @type {Object} */ (opt_map));
                }
            }
            /**
             * @return {number} The number of key-value pairs in the map.
             */
            Map.prototype.getCount = function () {
                return this.count_;
            };
            ;
            /**
             * Returns the values of the map.
             * @return {!Array<V>} The values in the map.
             */
            Map.prototype.getValues = function () {
                this.cleanupKeysArray_();
                var rv = [];
                for (var i = 0; i < this.keys_.length; i++) {
                    var key = this.keys_[i];
                    rv.push(this.map_[key]);
                }
                return rv;
            };
            ;
            /**
             * Returns the keys of the map.
             * @return {!Array<string>} Array of string values.
             */
            Map.prototype.getKeys = function () {
                this.cleanupKeysArray_();
                return /** @type {!Array<string>} */ (this.keys_.concat());
            };
            ;
            /**
             * Whether the map contains the given key.
             * @param {*} key The key to check for.
             * @return {boolean} Whether the map contains the key.
             */
            Map.prototype.containsKey = function (key) {
                return goog.structs.Map.hasKey_(this.map_, key);
            };
            ;
            /**
             * Whether the map contains the given value. This is O(n).
             * @param {V} val The value to check for.
             * @return {boolean} Whether the map contains the value.
             */
            Map.prototype.containsValue = function (val) {
                for (var i = 0; i < this.keys_.length; i++) {
                    var key = this.keys_[i];
                    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {
                        return true;
                    }
                }
                return false;
            };
            ;
            /**
             * Whether this map is equal to the argument map.
             * @param {goog.structs.Map} otherMap The map against which to test equality.
             * @param {function(V, V): boolean=} opt_equalityFn Optional equality function
             *     to test equality of values. If not specified, this will test whether
             *     the values contained in each map are identical objects.
             * @return {boolean} Whether the maps are equal.
             */
            Map.prototype.equals = function (otherMap, opt_equalityFn) {
                if (this === otherMap) {
                    return true;
                }
                if (this.count_ != otherMap.getCount()) {
                    return false;
                }
                var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;
                this.cleanupKeysArray_();
                for (var key, i = 0; key = this.keys_[i]; i++) {
                    if (!equalityFn(this.get(key), otherMap.get(key))) {
                        return false;
                    }
                }
                return true;
            };
            ;
            /**
             * Default equality test for values.
             * @param {*} a The first value.
             * @param {*} b The second value.
             * @return {boolean} Whether a and b reference the same object.
             */
            Map.defaultEquals = function (a, b) {
                return a === b;
            };
            ;
            /**
             * @return {boolean} Whether the map is empty.
             */
            Map.prototype.isEmpty = function () {
                return this.count_ == 0;
            };
            ;
            /**
             * Removes all key-value pairs from the map.
             */
            Map.prototype.clear = function () {
                this.map_ = {};
                this.keys_.length = 0;
                this.count_ = 0;
                this.version_ = 0;
            };
            ;
            /**
             * Removes a key-value pair based on the key. This is O(logN) amortized due to
             * updating the keys array whenever the count becomes half the size of the keys
             * in the keys array.
             * @param {*} key  The key to remove.
             * @return {boolean} Whether object was removed.
             */
            Map.prototype.remove = function (key) {
                if (goog.structs.Map.hasKey_(this.map_, key)) {
                    delete this.map_[key];
                    this.count_--;
                    this.version_++;
                    // clean up the keys array if the threshold is hit
                    if (this.keys_.length > 2 * this.count_) {
                        this.cleanupKeysArray_();
                    }
                    return true;
                }
                return false;
            };
            ;
            /**
             * Cleans up the temp keys array by removing entries that are no longer in the
             * map.
             * @private
             */
            Map.prototype.cleanupKeysArray_ = function () {
                if (this.count_ != this.keys_.length) {
                    // First remove keys that are no longer in the map.
                    var srcIndex = 0;
                    var destIndex = 0;
                    while (srcIndex < this.keys_.length) {
                        var key = this.keys_[srcIndex];
                        if (goog.structs.Map.hasKey_(this.map_, key)) {
                            this.keys_[destIndex++] = key;
                        }
                        srcIndex++;
                    }
                    this.keys_.length = destIndex;
                }
                if (this.count_ != this.keys_.length) {
                    // If the count still isn't correct, that means we have duplicates. This can
                    // happen when the same key is added and removed multiple times. Now we have
                    // to allocate one extra Object to remove the duplicates. This could have
                    // been done in the first pass, but in the common case, we can avoid
                    // allocating an extra object by only doing this when necessary.
                    var seen = {};
                    var srcIndex = 0;
                    var destIndex = 0;
                    while (srcIndex < this.keys_.length) {
                        var key = this.keys_[srcIndex];
                        if (!(goog.structs.Map.hasKey_(seen, key))) {
                            this.keys_[destIndex++] = key;
                            seen[key] = 1;
                        }
                        srcIndex++;
                    }
                    this.keys_.length = destIndex;
                }
            };
            ;
            /**
             * Returns the value for the given key.  If the key is not found and the default
             * value is not given this will return {@code undefined}.
             * @param {*} key The key to get the value for.
             * @param {DEFAULT=} opt_val The value to return if no item is found for the
             *     given key, defaults to undefined.
             * @return {V|DEFAULT} The value for the given key.
             * @template DEFAULT
             */
            Map.prototype.get = function (key, opt_val) {
                if (goog.structs.Map.hasKey_(this.map_, key)) {
                    return this.map_[key];
                }
                return opt_val;
            };
            ;
            /**
             * Adds a key-value pair to the map.
             * @param {*} key The key.
             * @param {V} value The value to add.
             * @return {*} Some subclasses return a value.
             */
            Map.prototype.set = function (key, value) {
                if (!(goog.structs.Map.hasKey_(this.map_, key))) {
                    this.count_++;
                    // TODO(johnlenz): This class lies, it claims to return an array of string
                    // keys, but instead returns the original object used.
                    this.keys_.push(/** @type {?} */ (key));
                    // Only change the version if we add a new key.
                    this.version_++;
                }
                this.map_[key] = value;
            };
            ;
            /**
             * Adds multiple key-value pairs from another goog.structs.Map or Object.
             * @param {Object} map  Object containing the data to add.
             */
            Map.prototype.addAll = function (map) {
                var keys, values;
                if (map instanceof goog.structs.Map) {
                    keys = map.getKeys();
                    values = map.getValues();
                }
                else {
                    keys = goog.object.getKeys(map);
                    values = goog.object.getValues(map);
                }
                // we could use goog.array.forEach here but I don't want to introduce that
                // dependency just for this.
                for (var i = 0; i < keys.length; i++) {
                    this.set(keys[i], values[i]);
                }
            };
            ;
            /**
             * Calls the given function on each entry in the map.
             * @param {function(this:T, V, K, goog.structs.Map<K,V>)} f
             * @param {T=} opt_obj The value of "this" inside f.
             * @template T
             */
            Map.prototype.forEach = function (f, opt_obj) {
                var keys = this.getKeys();
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var value = this.get(key);
                    f.call(opt_obj, value, key, this);
                }
            };
            ;
            /**
             * Clones a map and returns a new map.
             * @return {!goog.structs.Map} A new map with the same key-value pairs.
             */
            Map.prototype.clone = function () {
                return new goog.structs.Map(this);
            };
            ;
            /**
             * Returns a new map in which all the keys and values are interchanged
             * (keys become values and values become keys). If multiple keys map to the
             * same value, the chosen transposed value is implementation-dependent.
             *
             * It acts very similarly to {goog.object.transpose(Object)}.
             *
             * @return {!goog.structs.Map} The transposed map.
             */
            Map.prototype.transpose = function () {
                var transposed = new goog.structs.Map();
                for (var i = 0; i < this.keys_.length; i++) {
                    var key = this.keys_[i];
                    var value = this.map_[key];
                    transposed.set(value, key);
                }
                return transposed;
            };
            ;
            /**
             * @return {!Object} Object representation of the map.
             */
            Map.prototype.toObject = function () {
                this.cleanupKeysArray_();
                var obj = {};
                for (var i = 0; i < this.keys_.length; i++) {
                    var key = this.keys_[i];
                    obj[key] = this.map_[key];
                }
                return obj;
            };
            ;
            /**
             * Returns an iterator that iterates over the keys in the map.  Removal of keys
             * while iterating might have undesired side effects.
             * @return {!goog.iter.Iterator} An iterator over the keys in the map.
             */
            Map.prototype.getKeyIterator = function () {
                return this.__iterator__(true);
            };
            ;
            /**
             * Returns an iterator that iterates over the values in the map.  Removal of
             * keys while iterating might have undesired side effects.
             * @return {!goog.iter.Iterator} An iterator over the values in the map.
             */
            Map.prototype.getValueIterator = function () {
                return this.__iterator__(false);
            };
            ;
            /**
             * Returns an iterator that iterates over the values or the keys in the map.
             * This throws an exception if the map was mutated since the iterator was
             * created.
             * @param {boolean=} opt_keys True to iterate over the keys. False to iterate
             *     over the values.  The default value is false.
             * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.
             */
            Map.prototype.__iterator__ = function (opt_keys) {
                // Clean up keys to minimize the risk of iterating over dead keys.
                this.cleanupKeysArray_();
                var i = 0;
                var version = this.version_;
                var selfObj = this;
                var newIter = new goog.iter.Iterator;
                newIter.next = function () {
                    if (version != selfObj.version_) {
                        throw new Error('The map has changed since the iterator was created');
                    }
                    if (i >= selfObj.keys_.length) {
                        throw goog.iter.StopIteration;
                    }
                    var key = selfObj.keys_[i++];
                    return opt_keys ? key : selfObj.map_[key];
                };
                return newIter;
            };
            ;
            /**
             * Safe way to test for hasOwnProperty.  It even allows testing for
             * 'hasOwnProperty'.
             * @param {Object} obj The object to test for presence of the given key.
             * @param {*} key The key to check for.
             * @return {boolean} Whether the object has the key.
             * @private
             */
            Map.hasKey_ = function (obj, key) {
                return Object.prototype.hasOwnProperty.call(obj, key);
            };
            ;
            return Map;
        }());
        structs.Map = Map;
    })(structs = goog.structs || (goog.structs = {}));
})(goog || (goog = {}));
/// <reference path="../disposable/Disposable" />
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Datastructure: Pool.
 *
 *
 * A generic class for handling pools of objects that is more efficient than
 * goog.structs.Pool because it doesn't maintain a list of objects that are in
 * use. See constructor comment.
 */
goog.provide('goog.structs.SimplePool');
goog.require('goog.Disposable');
var goog;
(function (goog) {
    var structs;
    (function (structs) {
        var SimplePool = /** @class */ (function (_super) {
            __extends(SimplePool, _super);
            /**
             * A generic pool class. Simpler and more efficient than goog.structs.Pool
             * because it doesn't maintain a list of objects that are in use. This class
             * has constant overhead and doesn't create any additional objects as part of
             * the pool management after construction time.
             *
             * IMPORTANT: If the objects being pooled are arrays or maps that can have
             * unlimited number of properties, they need to be cleaned before being
             * returned to the pool.
             *
             * Also note that {@see goog.object.clean} actually allocates an array to clean
             * the object passed to it, so simply using this function would defy the
             * purpose of using the pool.
             *
             * @param {number} initialCount Initial number of objects to populate the free
             *     pool at construction time.
             * @param {number} maxCount Maximum number of objects to keep in the free pool.
             * @constructor
             * @extends {goog.Disposable}
             * @template T
             */
            function SimplePool(initialCount, maxCount) {
                var _this = _super.call(this) || this;
                goog.Disposable.call(_this);
                /**
                 * Function for overriding createObject. The avoids a common case requiring
                 * subclassing this class.
                 * @private {Function}
                 */
                _this.createObjectFn_ = null;
                /**
                 * Function for overriding disposeObject. The avoids a common case requiring
                 * subclassing this class.
                 * @private {Function}
                 */
                _this.disposeObjectFn_ = null;
                /**
                 * Maximum number of objects allowed
                 * @private {number}
                 */
                _this.maxCount_ = maxCount;
                /**
                 * Queue used to store objects that are currently in the pool and available
                 * to be used.
                 * @private {Array<T>}
                 */
                _this.freeQueue_ = [];
                _this.createInitial_(initialCount);
                return _this;
            }
            /**
             * Sets the {@code createObject} function which is used for creating a new
             * object in the pool.
             * @param {Function} createObjectFn Create object function which returns the
             *     newly created object.
             */
            SimplePool.prototype.setCreateObjectFn = function (createObjectFn) {
                this.createObjectFn_ = createObjectFn;
            };
            ;
            /**
             * Sets the {@code disposeObject} function which is used for disposing of an
             * object in the pool.
             * @param {Function} disposeObjectFn Dispose object function which takes the
             *     object to dispose as a parameter.
             */
            SimplePool.prototype.setDisposeObjectFn = function (disposeObjectFn) {
                this.disposeObjectFn_ = disposeObjectFn;
            };
            ;
            /**
             * Gets an unused object from the the pool, if there is one available,
             * otherwise creates a new one.
             * @return {T} An object from the pool or a new one if necessary.
             */
            SimplePool.prototype.getObject = function () {
                if (this.freeQueue_.length) {
                    return this.freeQueue_.pop();
                }
                return this.createObject();
            };
            ;
            /**
             * Returns an object to the pool so that it can be reused. If the pool is
             * already full, the object is disposed instead.
             * @param {T} obj The object to release.
             */
            SimplePool.prototype.releaseObject = function (obj) {
                if (this.freeQueue_.length < this.maxCount_) {
                    this.freeQueue_.push(obj);
                }
                else {
                    this.disposeObject(obj);
                }
            };
            ;
            /**
             * Populates the pool with initialCount objects.
             * @param {number} initialCount The number of objects to add to the pool.
             * @private
             */
            SimplePool.prototype.createInitial_ = function (initialCount) {
                if (initialCount > this.maxCount_) {
                    throw new Error('[goog.structs.SimplePool] Initial cannot be greater than max');
                }
                for (var i = 0; i < initialCount; i++) {
                    this.freeQueue_.push(this.createObject());
                }
            };
            ;
            /**
             * Should be overridden by sub-classes to return an instance of the object type
             * that is expected in the pool.
             * @return {T} The created object.
             */
            SimplePool.prototype.createObject = function () {
                if (this.createObjectFn_) {
                    return this.createObjectFn_();
                }
                else {
                    return {};
                }
            };
            ;
            /**
             * Should be overrideen to dispose of an object. Default implementation is to
             * remove all of the object's members, which should render it useless. Calls the
             *  object's dispose method, if available.
             * @param {T} obj The object to dispose.
             */
            SimplePool.prototype.disposeObject = function (obj) {
                if (this.disposeObjectFn_) {
                    this.disposeObjectFn_(obj);
                }
                else if (goog.isObject(obj)) {
                    if (goog.isFunction(obj.dispose)) {
                        obj.dispose();
                    }
                    else {
                        for (var i in obj) {
                            delete obj[i];
                        }
                    }
                }
            };
            ;
            /**
             * Disposes of the pool and all objects currently held in the pool.
             * @override
             * @protected
             */
            SimplePool.prototype.disposeInternal = function () {
                // goog.structs.SimplePool.superClass_.disposeInternal.call(this);
                _super.prototype.disposeInternal.call(this);
                // Call disposeObject on each object held by the pool.
                var freeQueue = this.freeQueue_;
                while (freeQueue.length) {
                    this.disposeObject(freeQueue.pop());
                }
                delete this.freeQueue_;
            };
            ;
            return SimplePool;
        }(goog.Disposable));
        structs.SimplePool = SimplePool;
    })(structs = goog.structs || (goog.structs = {}));
})(goog || (goog = {}));
/// <reference path="../array/array" />
/// <reference path="../asserts/asserts" />
/// <reference path="../debug/Logger" />
/// <reference path="../iter/iter" />
/// <reference path="../log/log" />
/// <reference path="../structs/Map" />
/// <reference path="../structs/SimplePool" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Definition of the Tracer class and associated classes.
 *
 * @see ../demos/tracer.html
 */
goog.provide('goog.debug.Trace');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug.Logger');
goog.require('goog.iter');
goog.require('goog.log');
goog.require('goog.structs.Map');
goog.require('goog.structs.SimplePool');
var goog;
(function (goog) {
    var debug;
    (function (debug) {
        var Trace_ = /** @class */ (function () {
            /**
             * Class used for singleton goog.debug.Trace.  Used for timing slow points in
             * the code. Based on the java Tracer class but optimized for javascript.
             * See com.google.common.tracing.Tracer.
             * It is also possible to bridge from this class to other tracer classes via
             * adding listeners.
             * @constructor
             * @private
             */
            function Trace_() {
                /**
                 * Logger for the tracer
                 * @private @const {?goog.log.Logger}
                 */
                this.logger_ = goog.log.getLogger('goog.debug.Trace');
                /**
                 * Maximum size of the trace before we discard events
                 * @type {number}
                 */
                this.MAX_TRACE_SIZE = 1000;
                /**
                 * Events in order.
                 * @private {!Array<!goog.debug.Trace_.Event_>}
                 */
                this.events_ = [];
                /**
                 * Outstanding events that have started but haven't yet ended. The keys are
                 * numeric ids and the values are goog.debug.Trace_.Event_ objects.
                 * @private {!goog.structs.Map<number, !goog.debug.Trace_.Event_>}
                 */
                this.outstandingEvents_ = new goog.structs.Map();
                /**
                 * Start time of the event trace
                 * @private {number}
                 */
                this.startTime_ = 0;
                /**
                 * Cummulative overhead of calls to startTracer
                 * @private {number}
                 */
                this.tracerOverheadStart_ = 0;
                /**
                 * Cummulative overhead of calls to endTracer
                 * @private {number}
                 */
                this.tracerOverheadEnd_ = 0;
                /**
                 * Cummulative overhead of calls to addComment
                 * @private {number}
                 */
                this.tracerOverheadComment_ = 0;
                /**
                 * Keeps stats on different types of tracers. The keys are strings and the
                 * values are goog.debug.Stat
                 * @private {!goog.structs.Map}
                 */
                this.stats_ = new goog.structs.Map();
                /**
                 * Total number of traces created in the trace.
                 * @private {number}
                 */
                this.tracerCount_ = 0;
                /**
                 * Total number of comments created in the trace.
                 * @private {number}
                 */
                this.commentCount_ = 0;
                /**
                 * Next id to use for the trace.
                 * @private {number}
                 */
                this.nextId_ = 1;
                /**
                 * A pool for goog.debug.Trace_.Event_ objects so we don't keep creating and
                 * garbage collecting these (which is very expensive in IE6).
                 * @private {!goog.structs.SimplePool}
                 */
                this.eventPool_ = new goog.structs.SimplePool(0, 4000);
                this.eventPool_.createObject = function () {
                    return new goog.debug.Trace_.Event_();
                };
                /**
                 * A pool for goog.debug.Trace_.Stat_ objects so we don't keep creating and
                 * garbage collecting these (which is very expensive in IE6).
                 * @private {!goog.structs.SimplePool}
                 */
                this.statPool_ = new goog.structs.SimplePool(0, 50);
                this.statPool_.createObject = function () {
                    return new goog.debug.Trace_.Stat_();
                };
                var self = this;
                /** @private {!goog.structs.SimplePool} */
                this.idPool_ = new goog.structs.SimplePool(0, 2000);
                // TODO(nicksantos): SimplePool is supposed to only return objects.
                // Reconcile this so that we don't have to cast to number below.
                this.idPool_.createObject = function () { return String(self.nextId_++); };
                this.idPool_.disposeObject = function (obj) { };
                /**
                 * Default threshold below which a tracer shouldn't be reported
                 * @private {number}
                 */
                this.defaultThreshold_ = 3;
                /**
                 * An object containing three callback functions to be called when starting or
                 * stopping a trace, or creating a comment trace.
                 * @private {!goog.debug.Trace_.TracerCallbacks}
                 */
                this.traceCallbacks_ = {};
            }
            /**
             * Removes all registered callback functions. Mainly used for testing.
             */
            Trace_.prototype.removeAllListeners = function () {
                this.traceCallbacks_ = {};
            };
            ;
            /**
             * Adds up to three callback functions which are called on {@code startTracer},
             * {@code stopTracer} and {@code addComment} in order to bridge from the Closure
             * tracer singleton object to any tracer class.
             * @param {!goog.debug.Trace_.TracerCallbacks} callbacks An object literal
             *   containing the callback functions.
             */
            Trace_.prototype.addTraceCallbacks = function (callbacks) {
                this.traceCallbacks_.start = goog.debug.Trace_.TracerCallbacks.sequence_(this.traceCallbacks_.start, callbacks.start);
                this.traceCallbacks_.stop = goog.debug.Trace_.TracerCallbacks.sequence_(this.traceCallbacks_.stop, callbacks.stop);
                this.traceCallbacks_.comment = goog.debug.Trace_.TracerCallbacks.sequence_(this.traceCallbacks_.comment, callbacks.comment);
            };
            ;
            /**
             * Add the ability to explicitly set the start time. This is useful for example
             * for measuring initial load time where you can set a variable as soon as the
             * main page of the app is loaded and then later call this function when the
             * Tracer code has been loaded.
             * @param {number} startTime The start time to set.
             */
            Trace_.prototype.setStartTime = function (startTime) {
                this.startTime_ = startTime;
            };
            ;
            /**
             * Initializes and resets the current trace
             * @param {number} defaultThreshold The default threshold below which the
             * tracer output will be suppressed. Can be overridden on a per-Tracer basis.
             */
            Trace_.prototype.initCurrentTrace = function (defaultThreshold) {
                this.reset(defaultThreshold);
            };
            ;
            /**
             * Clears the current trace
             */
            Trace_.prototype.clearCurrentTrace = function () {
                this.reset(0);
            };
            ;
            /**
             * Resets the trace.
             * @param {number} defaultThreshold The default threshold below which the
             * tracer output will be suppressed. Can be overridden on a per-Tracer basis.
             */
            Trace_.prototype.reset = function (defaultThreshold) {
                this.defaultThreshold_ = defaultThreshold;
                this.releaseEvents_();
                this.outstandingEvents_.clear();
                this.startTime_ = goog.debug.Trace_.now();
                this.tracerOverheadStart_ = 0;
                this.tracerOverheadEnd_ = 0;
                this.tracerOverheadComment_ = 0;
                this.tracerCount_ = 0;
                this.commentCount_ = 0;
                var keys = this.stats_.getKeys();
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var stat = this.stats_.get(key);
                    stat.count = 0;
                    stat.time = 0;
                    stat.varAlloc = 0;
                    this.statPool_.releaseObject(/** @type {Object} */ (stat));
                }
                this.stats_.clear();
            };
            ;
            /**
             * @private
             */
            Trace_.prototype.releaseEvents_ = function () {
                for (var i = 0; i < this.events_.length; i++) {
                    var event = this.events_[i];
                    if (event.id) {
                        this.idPool_.releaseObject(event.id);
                    }
                    this.eventPool_.releaseObject(event);
                }
                this.events_.length = 0;
            };
            ;
            /**
             * Starts a tracer
             * @param {string} comment A comment used to identify the tracer. Does not
             *     need to be unique.
             * @param {string=} opt_type Type used to identify the tracer. If a Trace is
             *     given a type (the first argument to the constructor) and multiple Traces
             *     are done on that type then a "TOTAL line will be produced showing the
             *     total number of traces and the sum of the time
             *     ("TOTAL Database 2 (37 ms)" in our example). These traces should be
             *     mutually exclusive or else the sum won't make sense (the time will
             *     be double counted if the second starts before the first ends).
             * @return {number} The identifier for the tracer that should be passed to the
             *     the stopTracer method.
             */
            Trace_.prototype.startTracer = function (comment, opt_type) {
                var tracerStartTime = goog.debug.Trace_.now();
                var varAlloc = this.getTotalVarAlloc();
                var outstandingEventCount = this.outstandingEvents_.getCount();
                if (this.events_.length + outstandingEventCount > this.MAX_TRACE_SIZE) {
                    goog.log.warning(this.logger_, 'Giant thread trace. Clearing to avoid memory leak.');
                    // This is the more likely case. This usually means that we
                    // either forgot to clear the trace or else we are performing a
                    // very large number of events
                    if (this.events_.length > this.MAX_TRACE_SIZE / 2) {
                        this.releaseEvents_();
                    }
                    // This is less likely and probably indicates that a lot of traces
                    // aren't being closed. We want to avoid unnecessarily clearing
                    // this though in case the events do eventually finish.
                    if (outstandingEventCount > this.MAX_TRACE_SIZE / 2) {
                        this.outstandingEvents_.clear();
                    }
                }
                goog.debug.Logger.logToProfilers('Start : ' + comment);
                /** @const */
                var event = 
                /** @type {!goog.debug.Trace_.Event_} */ (this.eventPool_.getObject());
                event.stopTime = undefined;
                event.totalVarAlloc = varAlloc;
                event.eventType = goog.debug.Trace_.EventType.START;
                event.id = Number(this.idPool_.getObject());
                event.comment = comment;
                event.type = opt_type;
                this.events_.push(event);
                this.outstandingEvents_.set(String(event.id), event);
                this.tracerCount_++;
                var now = goog.debug.Trace_.now();
                event.startTime = event.eventTime = now;
                this.tracerOverheadStart_ += now - tracerStartTime;
                if (this.traceCallbacks_.start) {
                    this.traceCallbacks_.start(event.id, event.toString());
                }
                return event.id;
            };
            ;
            /**
             * Stops a tracer
             * @param {number|undefined|null} id The id of the tracer that is ending.
             * @param {number=} opt_silenceThreshold Threshold below which the tracer is
             *    silenced.
             * @return {?number} The elapsed time for the tracer or null if the tracer
             *    identitifer was not recognized.
             */
            Trace_.prototype.stopTracer = function (id, opt_silenceThreshold) {
                // this used to call goog.isDef(opt_silenceThreshold) but that causes an
                // object allocation in IE for some reason (doh!). The following code doesn't
                // cause an allocation
                var now = goog.debug.Trace_.now();
                var silenceThreshold;
                if (opt_silenceThreshold === 0) {
                    silenceThreshold = 0;
                }
                else if (opt_silenceThreshold) {
                    silenceThreshold = opt_silenceThreshold;
                }
                else {
                    silenceThreshold = this.defaultThreshold_;
                }
                var startEvent = this.outstandingEvents_.get(String(id));
                if (startEvent == null) {
                    return null;
                }
                goog.asserts.assertNumber(id);
                if (this.traceCallbacks_.stop) {
                    this.traceCallbacks_.stop(Number(id));
                }
                this.outstandingEvents_.remove(String(id));
                var stopEvent;
                var elapsed = now - startEvent.startTime;
                if (elapsed < silenceThreshold) {
                    var count = this.events_.length;
                    for (var i = count - 1; i >= 0; i--) {
                        var nextEvent = this.events_[i];
                        if (nextEvent == startEvent) {
                            this.events_.splice(i, 1);
                            this.idPool_.releaseObject(startEvent.id);
                            this.eventPool_.releaseObject(/** @type {Object} */ (startEvent));
                            break;
                        }
                    }
                }
                else {
                    stopEvent =
                        /** @type {goog.debug.Trace_.Event_} */ (this.eventPool_.getObject());
                    stopEvent.id = undefined;
                    stopEvent.eventType = goog.debug.Trace_.EventType.STOP;
                    stopEvent.startTime = startEvent.startTime;
                    stopEvent.comment = startEvent.comment;
                    stopEvent.type = startEvent.type;
                    stopEvent.stopTime = stopEvent.eventTime = now;
                    this.events_.push(stopEvent);
                }
                var type = startEvent.type;
                var stat = null;
                if (type) {
                    stat = this.getStat_(type);
                    stat.count++;
                    stat.time += elapsed;
                }
                if (stopEvent) {
                    goog.debug.Logger.logToProfilers('Stop : ' + stopEvent.comment);
                    stopEvent.totalVarAlloc = this.getTotalVarAlloc();
                    if (stat) {
                        stat.varAlloc += (stopEvent.totalVarAlloc - startEvent.totalVarAlloc);
                    }
                }
                var tracerFinishTime = goog.debug.Trace_.now();
                this.tracerOverheadEnd_ += tracerFinishTime - now;
                return elapsed;
            };
            ;
            /**
             * Sets the ActiveX object that can be used to get GC tracing in IE6.
             * @param {Object} gcTracer GCTracer ActiveX object.
             */
            Trace_.prototype.setGcTracer = function (gcTracer) {
                this.gcTracer_ = gcTracer;
            };
            ;
            /**
             * Returns the total number of allocations since the GC stats were reset. Only
             * works in IE.
             * @return {number} The number of allocaitons or -1 if not supported.
             */
            Trace_.prototype.getTotalVarAlloc = function () {
                var gcTracer = this.gcTracer_;
                // isTracing is defined on the ActiveX object.
                if (gcTracer && gcTracer['isTracing']()) {
                    return gcTracer['totalVarAlloc'];
                }
                return -1;
            };
            ;
            /**
             * Adds a comment to the trace. Makes it possible to see when a specific event
             * happened in relation to the traces.
             * @param {string} comment A comment that is inserted into the trace.
             * @param {?string=} opt_type Type used to identify the tracer. If a comment is
             *     given a type and multiple comments are done on that type then a "TOTAL
             *     line will be produced showing the total number of comments of that type.
             * @param {?number=} opt_timeStamp The timestamp to insert the comment. If not
             *    specified, the current time wil be used.
             */
            Trace_.prototype.addComment = function (comment, opt_type, opt_timeStamp) {
                var now = goog.debug.Trace_.now();
                var timeStamp = opt_timeStamp ? opt_timeStamp : now;
                var eventComment = 
                /** @type {goog.debug.Trace_.Event_} */ (this.eventPool_.getObject());
                eventComment.startTime = undefined;
                eventComment.stopTime = undefined;
                eventComment.id = undefined;
                eventComment.eventType = goog.debug.Trace_.EventType.COMMENT;
                eventComment.eventTime = timeStamp;
                eventComment.type = opt_type;
                eventComment.comment = comment;
                eventComment.totalVarAlloc = this.getTotalVarAlloc();
                this.commentCount_++;
                if (opt_timeStamp) {
                    if (this.traceCallbacks_.comment) {
                        this.traceCallbacks_.comment(eventComment.toString(), opt_timeStamp);
                    }
                    var numEvents = this.events_.length;
                    for (var i = 0; i < numEvents; i++) {
                        var event = this.events_[i];
                        var eventTime = event.eventTime;
                        if (eventTime > timeStamp) {
                            goog.array.insertAt(this.events_, eventComment, i);
                            break;
                        }
                    }
                    if (i == numEvents) {
                        this.events_.push(eventComment);
                    }
                }
                else {
                    if (this.traceCallbacks_.comment) {
                        this.traceCallbacks_.comment(eventComment.toString());
                    }
                    this.events_.push(eventComment);
                }
                var type = eventComment.type;
                if (type) {
                    var stat = this.getStat_(type);
                    stat.count++;
                }
                this.tracerOverheadComment_ += goog.debug.Trace_.now() - now;
            };
            ;
            /**
             * Gets a stat object for a particular type. The stat object is created if it
             * hasn't yet been.
             * @param {string} type The type of stat.
             * @return {goog.debug.Trace_.Stat_} The stat object.
             * @private
             */
            Trace_.prototype.getStat_ = function (type) {
                var stat = this.stats_.get(type);
                if (!stat) {
                    stat = /** @type {goog.debug.Trace_.Event_} */ (this.statPool_.getObject());
                    stat.type = type;
                    this.stats_.set(type, stat);
                }
                return /** @type {goog.debug.Trace_.Stat_} */ (stat);
            };
            ;
            /**
             * Returns a formatted string for the current trace
             * @return {string} A formatted string that shows the timings of the current
             *     trace.
             */
            Trace_.prototype.getFormattedTrace = function () {
                return this.toString();
            };
            ;
            /**
             * Returns a formatted string that describes the thread trace.
             * @return {string} A formatted string.
             * @override
             */
            Trace_.prototype.toString = function () {
                var sb = [];
                var etime = -1;
                var indent = [];
                for (var i = 0; i < this.events_.length; i++) {
                    var e = this.events_[i];
                    if (e.eventType == goog.debug.Trace_.EventType.STOP) {
                        indent.pop();
                    }
                    sb.push(' ', e.toTraceString(this.startTime_, etime, indent.join('')));
                    etime = e.eventTime;
                    sb.push('\n');
                    if (e.eventType == goog.debug.Trace_.EventType.START) {
                        indent.push('|  ');
                    }
                }
                if (this.outstandingEvents_.getCount() != 0) {
                    var now = goog.debug.Trace_.now();
                    sb.push(' Unstopped timers:\n');
                    goog.iter.forEach(this.outstandingEvents_, function (startEvent) {
                        sb.push('  ', startEvent, ' (', now - startEvent.startTime, ' ms, started at ', goog.debug.Trace_.formatTime_(startEvent.startTime), ')\n');
                    });
                }
                var statKeys = this.stats_.getKeys();
                for (var i = 0; i < statKeys.length; i++) {
                    var stat = this.stats_.get(statKeys[i]);
                    if (stat.count > 1) {
                        sb.push(' TOTAL ', stat, '\n');
                    }
                }
                sb.push('Total tracers created ', this.tracerCount_, '\n', 'Total comments created ', this.commentCount_, '\n', 'Overhead start: ', this.tracerOverheadStart_, ' ms\n', 'Overhead end: ', this.tracerOverheadEnd_, ' ms\n', 'Overhead comment: ', this.tracerOverheadComment_, ' ms\n');
                return sb.join('');
            };
            ;
            /**
             * Converts 'v' to a string and pads it with up to 3 spaces for
             * improved alignment. TODO there must be a better way
             * @param {number} v A number.
             * @return {string} A padded string.
             * @private
             */
            Trace_.longToPaddedString_ = function (v) {
                v = Math.round(v);
                // todo (pupius) - there should be a generic string in goog.string for this
                var space = '';
                if (v < 1000)
                    space = ' ';
                if (v < 100)
                    space = '  ';
                if (v < 10)
                    space = '   ';
                return space + v;
            };
            ;
            /**
             * Return the sec.ms part of time (if time = "20:06:11.566",  "11.566
             * @param {number} time The time in MS.
             * @return {string} A formatted string as sec.ms'.
             * @private
             */
            Trace_.formatTime_ = function (time) {
                time = Math.round(time);
                var sec = (time / 1000) % 60;
                var ms = time % 1000;
                // TODO their must be a nicer way to get zero padded integers
                return String(100 + sec).substring(1, 3) + '.' +
                    String(1000 + ms).substring(1, 4);
            };
            ;
            /**
             * Returns the current time. Done through a wrapper function so it can be
             * overridden by application code. Gmail has an ActiveX extension that provides
             * higher precision timing info.
             * @return {number} The current time in milliseconds.
             */
            Trace_.now = function () {
                return goog.now();
            };
            ;
            return Trace_;
        }());
        debug.Trace_ = Trace_;
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        var Trace_;
        (function (Trace_) {
            /**
             * Event type supported by tracer
             * @enum {number}
             */
            var EventType;
            (function (EventType) {
                /**
                 * Start event type
                 */
                EventType[EventType["START"] = 0] = "START";
                /**
                 * Stop event type
                 */
                EventType[EventType["STOP"] = 1] = "STOP";
                /**
                 * Comment event type
                 */
                EventType[EventType["COMMENT"] = 2] = "COMMENT";
            })(EventType = Trace_.EventType || (Trace_.EventType = {}));
        })(Trace_ = debug.Trace_ || (debug.Trace_ = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        var Trace_;
        (function (Trace_) {
            var Stat_ = /** @class */ (function () {
                /**
                 * Class to keep track of a stat of a single tracer type. Stores the count
                 * and cumulative time.
                 * @constructor
                 * @private
                 */
                function Stat_() {
                    /**
                     * Number of tracers
                     * @type {number}
                     */
                    this.count = 0;
                    /**
                     * Cumulative time of traces
                     * @type {number}
                     */
                    this.time = 0;
                    /**
                     * Total number of allocations for this tracer type
                     * @type {number}
                     */
                    this.varAlloc = 0;
                }
                /**
                 * @return {string} A string describing the tracer stat.
                 * @override
                 */
                Stat_.prototype.toString = function () {
                    var sb = [];
                    sb.push(this.type, ' ', this.count, ' (', Math.round(this.time * 10) / 10, ' ms)');
                    if (this.varAlloc) {
                        sb.push(' [VarAlloc = ', this.varAlloc, ']');
                    }
                    return sb.join('');
                };
                ;
                return Stat_;
            }());
            Trace_.Stat_ = Stat_;
        })(Trace_ = debug.Trace_ || (debug.Trace_ = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        var Trace_;
        (function (Trace_) {
            var Event_ = /** @class */ (function () {
                /**
                 * Private class used to encapsulate a single event, either the start or stop
                 * of a tracer.
                 * @constructor
                 * @private
                 */
                function Event_() {
                    // the fields are different for different events - see usage in code
                }
                /**
                 * Returns a formatted string for the event.
                 * @param {number} startTime The start time of the trace to generate relative
                 * times.
                 * @param {number} prevTime The completion time of the previous event or -1.
                 * @param {string} indent Extra indent for the message
                 *     if there was no previous event.
                 * @return {string} The formatted tracer string.
                 */
                Event_.prototype.toTraceString = function (startTime, prevTime, indent) {
                    var sb = [];
                    if (prevTime == -1) {
                        sb.push('    ');
                    }
                    else {
                        sb.push(goog.debug.Trace_.longToPaddedString_(this.eventTime - prevTime));
                    }
                    sb.push(' ', goog.debug.Trace_.formatTime_(this.eventTime - startTime));
                    if (this.eventType == goog.debug.Trace_.EventType.START) {
                        sb.push(' Start        ');
                    }
                    else if (this.eventType == goog.debug.Trace_.EventType.STOP) {
                        sb.push(' Done ');
                        var delta = this.stopTime - this.startTime;
                        sb.push(goog.debug.Trace_.longToPaddedString_(delta), ' ms ');
                    }
                    else {
                        sb.push(' Comment      ');
                    }
                    sb.push(indent, this);
                    if (this.totalVarAlloc > 0) {
                        sb.push('[VarAlloc ', this.totalVarAlloc, '] ');
                    }
                    return sb.join('');
                };
                ;
                /**
                 * @return {string} A string describing the tracer event.
                 * @override
                 */
                Event_.prototype.toString = function () {
                    if (this.type == null) {
                        return this.comment;
                    }
                    else {
                        return '[' + this.type + '] ' + this.comment;
                    }
                };
                ;
                return Event_;
            }());
            Trace_.Event_ = Event_;
        })(Trace_ = debug.Trace_ || (debug.Trace_ = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        var Trace_;
        (function (Trace_) {
            /**
             * A class to specify the types of the callback functions used by
             * {@code addTraceCallbacks}.
             * @record
             */
            var TracerCallbacks = /** @class */ (function () {
                function TracerCallbacks() {
                    /**
                     * A callback function to be called at {@code startTrace} with two parameters:
                     * a number as the started trace id and a string as the comment on the trace.
                     * @type {function(number, string)|undefined}
                     */
                    this.start;
                    /**
                     * A callback function to be called at {@code stopTrace} with one parameter:
                     * a number as the trace id being stopped.
                     * @type {function(number)|undefined}
                     */
                    this.stop;
                    /**
                     * A callback function to be called at {@code addComment} with two parameters:
                     * a string as the comment on the trace and an optional time stamp number (in
                     * milliseconds since epoch) when the comment should be added as a trace.
                     * @type {function(string, ?number=)|undefined}
                     */
                    this.comment;
                }
                /**
                 * A function that combines two function with the same parameters in a sequence.
                 * @param {!Function|undefined} fn1 The first function to be combined.
                 * @param {!Function|undefined} fn2 The second function to be combined.
                 * @return {!Function|undefined} A function that calls the inputs in sequence.
                 * @private
                 */
                TracerCallbacks.sequence_ = function (fn1, fn2) {
                    return !fn1 ? fn2 : !fn2 ? fn1 : function () {
                        fn1.apply(undefined, arguments);
                        fn2.apply(undefined, arguments);
                    };
                };
                ;
                return TracerCallbacks;
            }());
            Trace_.TracerCallbacks = TracerCallbacks;
        })(Trace_ = debug.Trace_ || (debug.Trace_ = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        /**
         * Singleton trace object
         * @type {goog.debug.Trace_}
         */
        debug.Trace = new goog.debug.Trace_();
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
/// <reference path="../disposable/Disposable" />
/// <reference path="../asserts/asserts" />
/// <reference path="../debug/debug" />
/// <reference path="../debug/entryPointRegistry" />
/// <reference path="../debug/Error" />
/// <reference path="../debug/Tracer" />
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Error handling utilities.
 *
 */
goog.provide('goog.debug.ErrorHandler');
goog.provide('goog.debug.ErrorHandler.ProtectedFunctionError');
goog.require('goog.Disposable');
goog.require('goog.asserts');
goog.require('goog.debug');
goog.require('goog.debug.EntryPointMonitor');
goog.require('goog.debug.Error');
goog.require('goog.debug.Trace');
var goog;
(function (goog) {
    var debug;
    (function (debug) {
        var ErrorHandler = /** @class */ (function (_super) {
            __extends(ErrorHandler, _super);
            /**
             * The ErrorHandler can be used to to wrap functions with a try/catch
             * statement. If an exception is thrown, the given error handler function will
             * be called.
             *
             * When this object is disposed, it will stop handling exceptions and tracing.
             * It will also try to restore window.setTimeout and window.setInterval
             * if it wrapped them. Notice that in the general case, it is not technically
             * possible to remove the wrapper, because functions have no knowledge of
             * what they have been assigned to. So the app is responsible for other
             * forms of unwrapping.
             *
             * @param {Function} handler Handler for exceptions.
             * @constructor
             * @extends {goog.Disposable}
             * @implements {goog.debug.EntryPointMonitor}
             */
            function ErrorHandler(handler) {
                var _this = 
                // goog.debug.ErrorHandler.base(this, 'constructor');
                _super.call(this) || this;
                /**
                 * Whether to add tracers when instrumenting entry points.
                 * @type {boolean}
                 * @private
                 */
                _this.addTracersToProtectedFunctions_ = false;
                /**
                 * Install exception protection for window.requestAnimationFrame to handle
                 * exceptions.
                 */
                _this.protectWindowRequestAnimationFrame = function () {
                    var win = goog.getObjectByName('window');
                    var fnNames = [
                        'requestAnimationFrame', 'mozRequestAnimationFrame', 'webkitAnimationFrame',
                        'msRequestAnimationFrame'
                    ];
                    for (var i = 0; i < fnNames.length; i++) {
                        var fnName = fnNames[i];
                        if (fnNames[i] in win) {
                            this.protectWindowFunctionsHelper_(fnName);
                        }
                    }
                };
                /**
                 * Handler for exceptions, which can do logging, reporting, etc.
                 * @type {Function}
                 * @private
                 */
                _this.errorHandlerFn_ = handler;
                /**
                 * Whether errors should be wrapped in
                 * goog.debug.ErrorHandler.ProtectedFunctionError before rethrowing.
                 * @type {boolean}
                 * @private
                 */
                _this.wrapErrors_ = true; // TODO(user) Change default.
                /**
                 * Whether to add a prefix to all error messages. The prefix is
                 * goog.debug.ErrorHandler.ProtectedFunctionError.MESSAGE_PREFIX. This option
                 * only has an effect if this.wrapErrors_  is set to false.
                 * @type {boolean}
                 * @private
                 */
                _this.prefixErrorMessages_ = false;
                return _this;
            }
            /**
             * Enable tracers when instrumenting entry points.
             * @param {boolean} newVal See above.
             */
            ErrorHandler.prototype.setAddTracersToProtectedFunctions = function (newVal) {
                this.addTracersToProtectedFunctions_ = newVal;
            };
            ;
            /** @override */
            ErrorHandler.prototype.wrap = function (fn) {
                return this.protectEntryPoint(goog.asserts.assertFunction(fn));
            };
            ;
            /** @override */
            ErrorHandler.prototype.unwrap = function (fn) {
                goog.asserts.assertFunction(fn);
                return fn[this.getFunctionIndex_(false)] || fn;
            };
            ;
            /**
             * Private helper function to return a span that can be clicked on to display
             * an alert with the current stack trace. Newlines are replaced with a
             * placeholder so that they will not be html-escaped.
             * @param {string} stackTrace The stack trace to create a span for.
             * @return {string} A span which can be clicked on to show the stack trace.
             * @private
             */
            ErrorHandler.prototype.getStackTraceHolder_ = function (stackTrace) {
                var buffer = [];
                buffer.push('##PE_STACK_START##');
                buffer.push(stackTrace.replace(/(\r\n|\r|\n)/g, '##STACK_BR##'));
                buffer.push('##PE_STACK_END##');
                return buffer.join('');
            };
            ;
            /**
             * Get the index for a function. Used for internal indexing.
             * @param {boolean} wrapper True for the wrapper; false for the wrapped.
             * @return {string} The index where we should store the function in its
             *     wrapper/wrapped function.
             * @private
             */
            ErrorHandler.prototype.getFunctionIndex_ = function (wrapper) {
                return (wrapper ? '__wrapper_' : '__protected_') + goog.getUid(this) + '__';
            };
            ;
            /**
             * Installs exception protection for an entry point function. When an exception
             * is thrown from a protected function, a handler will be invoked to handle it.
             *
             * @param {Function} fn An entry point function to be protected.
             * @return {!Function} A protected wrapper function that calls the entry point
             *     function.
             */
            ErrorHandler.prototype.protectEntryPoint = function (fn) {
                var protectedFnName = this.getFunctionIndex_(true);
                if (!fn[protectedFnName]) {
                    var wrapper = fn[protectedFnName] = this.getProtectedFunction(fn);
                    wrapper[this.getFunctionIndex_(false)] = fn;
                }
                return fn[protectedFnName];
            };
            ;
            /**
             * Helps {@link #protectEntryPoint} by actually creating the protected
             * wrapper function, after {@link #protectEntryPoint} determines that one does
             * not already exist for the given function.  Can be overriden by subclasses
             * that may want to implement different error handling, or add additional
             * entry point hooks.
             * @param {!Function} fn An entry point function to be protected.
             * @return {!Function} protected wrapper function.
             * @protected
             */
            ErrorHandler.prototype.getProtectedFunction = function (fn) {
                var that = this;
                var tracers = this.addTracersToProtectedFunctions_;
                if (tracers) {
                    var stackTrace = goog.debug.getStacktraceSimple(15);
                }
                var googDebugErrorHandlerProtectedFunction = function () {
                    if (that.isDisposed()) {
                        return fn.apply(this, arguments);
                    }
                    if (tracers) {
                        var tracer = goog.debug.Trace.startTracer('protectedEntryPoint: ' + that.getStackTraceHolder_(stackTrace));
                    }
                    try {
                        return fn.apply(this, arguments);
                    }
                    catch (e) {
                        // Don't re-report errors that have already been handled by this code.
                        var MESSAGE_PREFIX = goog.debug.ErrorHandler.ProtectedFunctionError.MESSAGE_PREFIX;
                        if ((e && typeof e === 'object' && e.message &&
                            e.message.indexOf(MESSAGE_PREFIX) == 0) ||
                            (typeof e === 'string' && e.indexOf(MESSAGE_PREFIX) == 0)) {
                            return;
                        }
                        that.errorHandlerFn_(e);
                        if (!that.wrapErrors_) {
                            // Add the prefix to the existing message.
                            if (that.prefixErrorMessages_) {
                                if (typeof e === 'object' && e && 'message' in e) {
                                    e.message = MESSAGE_PREFIX + e.message;
                                }
                                else {
                                    e = MESSAGE_PREFIX + e;
                                }
                            }
                            if (goog.DEBUG) {
                                // Work around for https://code.google.com/p/v8/issues/detail?id=2625
                                // and https://code.google.com/p/chromium/issues/detail?id=237059
                                // Custom errors and errors with custom stack traces show the wrong
                                // stack trace
                                // If it has a stack and Error.captureStackTrace is supported (only
                                // supported in V8 as of May 2013) log the stack to the console.
                                if (e && e.stack && goog.global.Error.captureStackTrace &&
                                    goog.global['console']) {
                                    goog.global['console']['error'](e.message, e.stack);
                                }
                            }
                            // Re-throw original error. This is great for debugging as it makes
                            // browser JS dev consoles show the correct error and stack trace.
                            throw e;
                        }
                        // Re-throw it since this may be expected by the caller.
                        throw new goog.debug.ErrorHandler.ProtectedFunctionError(e);
                    }
                    finally {
                        if (tracers) {
                            goog.debug.Trace.stopTracer(tracer);
                        }
                    }
                };
                googDebugErrorHandlerProtectedFunction[this.getFunctionIndex_(false)] = fn;
                return googDebugErrorHandlerProtectedFunction;
            };
            ;
            // TODO(mknichel): Allow these functions to take in the window to protect.
            /**
             * Installs exception protection for window.setTimeout to handle exceptions.
             */
            ErrorHandler.prototype.protectWindowSetTimeout = function () {
                this.protectWindowFunctionsHelper_('setTimeout');
            };
            ;
            /**
             * Install exception protection for window.setInterval to handle exceptions.
             */
            ErrorHandler.prototype.protectWindowSetInterval = function () {
                this.protectWindowFunctionsHelper_('setInterval');
            };
            ;
            /**
             * Helper function for protecting a function that causes a function to be
             * asynchronously called, for example setTimeout or requestAnimationFrame.
             * @param {string} fnName The name of the function to protect.
             * @private
             */
            ErrorHandler.prototype.protectWindowFunctionsHelper_ = function (fnName) {
                var win = goog.getObjectByName('window');
                var originalFn = win[fnName];
                var that = this;
                win[fnName] = function (fn, time) {
                    // Don't try to protect strings. In theory, we could try to globalEval
                    // the string, but this seems to lead to permission errors on IE6.
                    if (goog.isString(fn)) {
                        fn = goog.partial(goog.globalEval, fn);
                    }
                    arguments[0] = fn = that.protectEntryPoint(fn);
                    // IE doesn't support .call for setInterval/setTimeout, but it
                    // also doesn't care what "this" is, so we can just call the
                    // original function directly
                    if (originalFn.apply) {
                        return originalFn.apply(this, arguments);
                    }
                    else {
                        var callback = fn;
                        if (arguments.length > 2) {
                            var args = Array.prototype.slice.call(arguments, 2);
                            callback = function () { fn.apply(this, args); };
                        }
                        return originalFn(callback, time);
                    }
                };
                win[fnName][this.getFunctionIndex_(false)] = originalFn;
            };
            ;
            /**
             * Set whether to wrap errors that occur in protected functions in a
             * goog.debug.ErrorHandler.ProtectedFunctionError.
             * @param {boolean} wrapErrors Whether to wrap errors.
             */
            ErrorHandler.prototype.setWrapErrors = function (wrapErrors) {
                this.wrapErrors_ = wrapErrors;
            };
            ;
            /**
             * Set whether to add a prefix to all error messages that occur in protected
             * functions.
             * @param {boolean} prefixErrorMessages Whether to add a prefix to error
             *     messages.
             */
            ErrorHandler.prototype.setPrefixErrorMessages = function (prefixErrorMessages) {
                this.prefixErrorMessages_ = prefixErrorMessages;
            };
            ;
            /** @override */
            ErrorHandler.prototype.disposeInternal = function () {
                // Try to unwrap window.setTimeout and window.setInterval.
                var win = goog.getObjectByName('window');
                win.setTimeout = this.unwrap(win.setTimeout);
                win.setInterval = this.unwrap(win.setInterval);
                // goog.debug.ErrorHandler.base(this, 'disposeInternal');
                _super.prototype.disposeInternal.call(this);
            };
            ;
            return ErrorHandler;
        }(goog.Disposable));
        debug.ErrorHandler = ErrorHandler;
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
(function (goog) {
    var debug;
    (function (debug) {
        var ErrorHandler;
        (function (ErrorHandler) {
            var ProtectedFunctionError = /** @class */ (function (_super) {
                __extends(ProtectedFunctionError, _super);
                /**
                 * Error thrown to the caller of a protected entry point if the entry point
                 * throws an error.
                 * @param {*} cause The error thrown by the entry point.
                 * @constructor
                 * @extends {goog.debug.Error}
                 * @final
                 */
                function ProtectedFunctionError(cause) {
                    var _this = this;
                    var message = goog.debug.ErrorHandler.ProtectedFunctionError.MESSAGE_PREFIX +
                        (cause && cause.message ? String(cause.message) : String(cause));
                    // goog.debug.ErrorHandler.ProtectedFunctionError.base(
                    //     this, 'constructor', message);
                    _this = _super.call(this, message) || this;
                    /**
                     * The error thrown by the entry point.
                     * @type {*}
                     */
                    _this.cause = cause;
                    var stack = cause && cause.stack;
                    if (stack && goog.isString(stack)) {
                        _this.stack = /** @type {string} */ (stack);
                    }
                    return _this;
                }
                /**
                 * Text to prefix the message with.
                 * @type {string}
                 */
                ProtectedFunctionError.MESSAGE_PREFIX = 'Error in protected function: ';
                return ProtectedFunctionError;
            }(goog.debug.Error));
            ErrorHandler.ProtectedFunctionError = ProtectedFunctionError;
        })(ErrorHandler = debug.ErrorHandler || (debug.ErrorHandler = {}));
    })(debug = goog.debug || (goog.debug = {}));
})(goog || (goog = {}));
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Definition of the goog.events.EventWrapper interface.
 *
 * @author eae@google.com (Emil A Eklund)
 */
goog.provide('goog.events.EventWrapper');
/// <reference path="../asserts/asserts" />
/// <reference path="../debug/entryPointRegistry" />
/// <reference path="../events/BrowserEvent" />
/// <reference path="../events/BrowserFeature" />
/// <reference path="../events/Listenable" />
/// <reference path="../events/ListenerMap" />
/// <reference path="../debug/ErrorHandler" />
/// <reference path="../events/EventWrapper" />
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview An event manager for both native browser event
 * targets and custom JavaScript event targets
 * ({@code goog.events.Listenable}). This provides an abstraction
 * over browsers' event systems.
 *
 * It also provides a simulation of W3C event model's capture phase in
 * Internet Explorer (IE 8 and below). Caveat: the simulation does not
 * interact well with listeners registered directly on the elements
 * (bypassing goog.events) or even with listeners registered via
 * goog.events in a separate JS binary. In these cases, we provide
 * no ordering guarantees.
 *
 * The listeners will receive a "patched" event object. Such event object
 * contains normalized values for certain event properties that differs in
 * different browsers.
 *
 * Example usage:
 * <pre>
 * goog.events.listen(myNode, 'click', function(e) { alert('woo') });
 * goog.events.listen(myNode, 'mouseover', mouseHandler, true);
 * goog.events.unlisten(myNode, 'mouseover', mouseHandler, true);
 * goog.events.removeAll(myNode);
 * </pre>
 *
 *                                            in IE and event object patching]
 * @author arv@google.com (Erik Arvidsson)
 *
 * @see ../demos/events.html
 * @see ../demos/event-propagation.html
 * @see ../demos/stopevent.html
 */
// IMPLEMENTATION NOTES:
// goog.events stores an auxiliary data structure on each EventTarget
// source being listened on. This allows us to take advantage of GC,
// having the data structure GC'd when the EventTarget is GC'd. This
// GC behavior is equivalent to using W3C DOM Events directly.
goog.provide('goog.events');
goog.provide('goog.events.CaptureSimulationMode');
goog.provide('goog.events.Key');
goog.provide('goog.events.ListenableType');
goog.require('goog.asserts');
goog.require('goog.debug.entryPointRegistry');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.BrowserFeature');
goog.require('goog.events.Listenable');
goog.require('goog.events.ListenerMap');
goog.forwardDeclare('goog.debug.ErrorHandler');
goog.forwardDeclare('goog.events.EventWrapper');
var goog;
(function (goog) {
    var events;
    (function (events) {
        /**
         * Property name on a native event target for the listener map
         * associated with the event target.
         * @private @const {string}
         */
        events.LISTENER_MAP_PROP_ = 'closure_lm_' + ((Math.random() * 1e6) | 0);
        /**
         * String used to prepend to IE event types.
         * @const
         * @private
         */
        events.onString_ = 'on';
        /**
         * Map of computed "on<eventname>" strings for IE event types. Caching
         * this removes an extra object allocation in goog.events.listen which
         * improves IE6 performance.
         * @const
         * @dict
         * @private
         */
        events.onStringMap_ = {};
        /**
         * @enum {number} Different capture simulation mode for IE8-.
         */
        var CaptureSimulationMode;
        (function (CaptureSimulationMode) {
            /**
             * Does not perform capture simulation. Will asserts in IE8- when you
             * add capture listeners.
             */
            CaptureSimulationMode[CaptureSimulationMode["OFF_AND_FAIL"] = 0] = "OFF_AND_FAIL";
            /**
             * Does not perform capture simulation, silently ignore capture
             * listeners.
             */
            CaptureSimulationMode[CaptureSimulationMode["OFF_AND_SILENT"] = 1] = "OFF_AND_SILENT";
            /**
             * Performs capture simulation.
             */
            CaptureSimulationMode[CaptureSimulationMode["ON"] = 2] = "ON";
        })(CaptureSimulationMode = events.CaptureSimulationMode || (events.CaptureSimulationMode = {}));
        ;
        events.CAPTURE_SIMULATION_MODE = 2;
        /**
         * Estimated count of total native listeners.
         * @private {number}
         */
        events.listenerCountEstimate_ = 0;
        /**
         * Adds an event listener for a specific event on a native event
         * target (such as a DOM element) or an object that has implemented
         * {@link goog.events.Listenable}. A listener can only be added once
         * to an object and if it is added again the key for the listener is
         * returned. Note that if the existing listener is a one-off listener
         * (registered via listenOnce), it will no longer be a one-off
         * listener after a call to listen().
         *
         * @param {EventTarget|goog.events.Listenable} src The node to listen
         *     to events on.
         * @param {string|Array<string>|
         *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
         *     type Event type or array of event types.
         * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}
         *     listener Callback method, or an object with a handleEvent function.
         *     WARNING: passing an Object is now softly deprecated.
         * @param {(boolean|!AddEventListenerOptions)=} opt_options
         * @param {T=} opt_handler Element in whose scope to call the listener.
         * @return {goog.events.Key} Unique key for the listener.
         * @template T,EVENTOBJ
         */
        function listen(src, type, listener, opt_options, opt_handler) {
            if (opt_options && opt_options.once) {
                return goog.events.listenOnce(src, type, listener, opt_options, opt_handler);
            }
            if (goog.isArray(type)) {
                for (var i = 0; i < type.length; i++) {
                    goog.events.listen(src, type[i], listener, opt_options, opt_handler);
                }
                return null;
            }
            listener = goog.events.wrapListener(listener);
            if (goog.events.Listenable.isImplementedBy(src)) {
                var capture = goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
                return src.listen(
                /** @type {string|!goog.events.EventId} */ (type), listener, capture, opt_handler);
            }
            else {
                return goog.events.listen_(
                /** @type {!EventTarget} */ (src), type, listener, 
                /* callOnce */ false, opt_options, opt_handler);
            }
        }
        events.listen = listen;
        ;
        /**
         * Adds an event listener for a specific event on a native event
         * target. A listener can only be added once to an object and if it
         * is added again the key for the listener is returned.
         *
         * Note that a one-off listener will not change an existing listener,
         * if any. On the other hand a normal listener will change existing
         * one-off listener to become a normal listener.
         *
         * @param {EventTarget} src The node to listen to events on.
         * @param {string|?goog.events.EventId<EVENTOBJ>} type Event type.
         * @param {!Function} listener Callback function.
         * @param {boolean} callOnce Whether the listener is a one-off
         *     listener or otherwise.
         * @param {(boolean|!AddEventListenerOptions)=} opt_options
         * @param {Object=} opt_handler Element in whose scope to call the listener.
         * @return {goog.events.ListenableKey} Unique key for the listener.
         * @template EVENTOBJ
         * @private
         */
        function listen_(src, type, listener, callOnce, opt_options, opt_handler) {
            if (!type) {
                throw new Error('Invalid event type');
            }
            var capture = goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
            if (capture && !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
                if (goog.events.CAPTURE_SIMULATION_MODE ==
                    goog.events.CaptureSimulationMode.OFF_AND_FAIL) {
                    goog.asserts.fail('Can not register capture listener in IE8-.');
                    return null;
                }
                else if (goog.events.CAPTURE_SIMULATION_MODE ==
                    goog.events.CaptureSimulationMode.OFF_AND_SILENT) {
                    return null;
                }
            }
            var listenerMap = goog.events.getListenerMap_(src);
            if (!listenerMap) {
                src[goog.events.LISTENER_MAP_PROP_] = listenerMap =
                    new goog.events.ListenerMap(src);
            }
            var listenerObj = listenerMap.add(type, listener, callOnce, capture, opt_handler);
            // If the listenerObj already has a proxy, it has been set up
            // previously. We simply return.
            if (listenerObj.proxy) {
                return listenerObj;
            }
            var proxy = goog.events.getProxy();
            listenerObj.proxy = proxy;
            proxy.src = src;
            proxy.listener = listenerObj;
            // Attach the proxy through the browser's API
            if (src.addEventListener) {
                // Don't pass an object as `capture` if the browser doesn't support that.
                if (!goog.events.BrowserFeature.PASSIVE_EVENTS) {
                    opt_options = capture;
                }
                // Don't break tests that expect a boolean.
                if (opt_options === undefined)
                    opt_options = false;
                src.addEventListener(type.toString(), proxy, opt_options);
            }
            else if (src.attachEvent) {
                // The else if above used to be an unconditional else. It would call
                // exception on IE11, spoiling the day of some callers. The previous
                // incarnation of this code, from 2007, indicates that it replaced an
                // earlier still version that caused excess allocations on IE6.
                src.attachEvent(goog.events.getOnString_(type.toString()), proxy);
            }
            else if (src.addListener && src.removeListener) {
                // In IE, MediaQueryList uses addListener() insteadd of addEventListener. In
                // Safari, there is no global for the MediaQueryList constructor, so we just
                // check whether the object "looks like" MediaQueryList.
                goog.asserts.assert(type === 'change', 'MediaQueryList only has a change event');
                src.addListener(proxy);
            }
            else {
                throw new Error('addEventListener and attachEvent are unavailable.');
            }
            goog.events.listenerCountEstimate_++;
            return listenerObj;
        }
        events.listen_ = listen_;
        ;
        /**
         * Helper function for returning a proxy function.
         * @return {!Function} A new or reused function object.
         */
        function getProxy() {
            var proxyCallbackFunction = goog.events.handleBrowserEvent_;
            // Use a local var f to prevent one allocation.
            var f = goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ? function (eventObject) {
                return proxyCallbackFunction.call(f.src, f.listener, eventObject);
            } : function (eventObject) {
                var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);
                // NOTE(chrishenry): In IE, we hack in a capture phase. However, if
                // there is inline event handler which tries to prevent default (for
                // example <a href="..." onclick="return false">...</a>) in a
                // descendant element, the prevent default will be overridden
                // by this listener if this listener were to return true. Hence, we
                // return undefined.
                if (!v)
                    return v;
            };
            return f;
        }
        events.getProxy = getProxy;
        ;
        /**
         * Adds an event listener for a specific event on a native event
         * target (such as a DOM element) or an object that has implemented
         * {@link goog.events.Listenable}. After the event has fired the event
         * listener is removed from the target.
         *
         * If an existing listener already exists, listenOnce will do
         * nothing. In particular, if the listener was previously registered
         * via listen(), listenOnce() will not turn the listener into a
         * one-off listener. Similarly, if there is already an existing
         * one-off listener, listenOnce does not modify the listeners (it is
         * still a once listener).
         *
         * @param {EventTarget|goog.events.Listenable} src The node to listen
         *     to events on.
         * @param {string|Array<string>|
         *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
         *     type Event type or array of event types.
         * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}
         *     listener Callback method.
         * @param {(boolean|!AddEventListenerOptions)=} opt_options
         * @param {T=} opt_handler Element in whose scope to call the listener.
         * @return {goog.events.Key} Unique key for the listener.
         * @template T,EVENTOBJ
         */
        function listenOnce(src, type, listener, opt_options, opt_handler) {
            if (goog.isArray(type)) {
                for (var i = 0; i < type.length; i++) {
                    goog.events.listenOnce(src, type[i], listener, opt_options, opt_handler);
                }
                return null;
            }
            listener = goog.events.wrapListener(listener);
            if (goog.events.Listenable.isImplementedBy(src)) {
                var capture = goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
                return src.listenOnce(
                /** @type {string|!goog.events.EventId} */ (type), listener, capture, opt_handler);
            }
            else {
                return goog.events.listen_(
                /** @type {!EventTarget} */ (src), type, listener, 
                /* callOnce */ true, opt_options, opt_handler);
            }
        }
        events.listenOnce = listenOnce;
        ;
        /**
         * Adds an event listener with a specific event wrapper on a DOM Node or an
         * object that has implemented {@link goog.events.Listenable}. A listener can
         * only be added once to an object.
         *
         * @param {EventTarget|goog.events.Listenable} src The target to
         *     listen to events on.
         * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
         * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener
         *     Callback method, or an object with a handleEvent function.
         * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
         *     false).
         * @param {T=} opt_handler Element in whose scope to call the listener.
         * @template T
         */
        function listenWithWrapper(src, wrapper, listener, opt_capt, opt_handler) {
            wrapper.listen(src, listener, opt_capt, opt_handler);
        }
        events.listenWithWrapper = listenWithWrapper;
        ;
        /**
         * Removes an event listener which was added with listen().
         *
         * @param {EventTarget|goog.events.Listenable} src The target to stop
         *     listening to events on.
         * @param {string|Array<string>|
         *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
         *     type Event type or array of event types to unlisten to.
         * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
         *     listener function to remove.
         * @param {(boolean|!EventListenerOptions)=} opt_options
         *     whether the listener is fired during the capture or bubble phase of the
         *     event.
         * @param {Object=} opt_handler Element in whose scope to call the listener.
         * @return {?boolean} indicating whether the listener was there to remove.
         * @template EVENTOBJ
         */
        function unlisten(src, type, listener, opt_options, opt_handler) {
            if (goog.isArray(type)) {
                for (var i = 0; i < type.length; i++) {
                    goog.events.unlisten(src, type[i], listener, opt_options, opt_handler);
                }
                return null;
            }
            var capture = goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
            listener = goog.events.wrapListener(listener);
            if (goog.events.Listenable.isImplementedBy(src)) {
                return src.unlisten(
                /** @type {string|!goog.events.EventId} */ (type), listener, capture, opt_handler);
            }
            if (!src) {
                // TODO(chrishenry): We should tighten the API to only accept
                // non-null objects, or add an assertion here.
                return false;
            }
            var listenerMap = goog.events.getListenerMap_(
            /** @type {!EventTarget} */ (src));
            if (listenerMap) {
                var listenerObj = listenerMap.getListener(
                /** @type {string|!goog.events.EventId} */ (type), listener, capture, opt_handler);
                if (listenerObj) {
                    return goog.events.unlistenByKey(listenerObj);
                }
            }
            return false;
        }
        events.unlisten = unlisten;
        ;
        /**
         * Removes an event listener which was added with listen() by the key
         * returned by listen().
         *
         * @param {goog.events.Key} key The key returned by listen() for this
         *     event listener.
         * @return {boolean} indicating whether the listener was there to remove.
         */
        function unlistenByKey(key) {
            // TODO(chrishenry): Remove this check when tests that rely on this
            // are fixed.
            if (goog.isNumber(key)) {
                return false;
            }
            var listener = key;
            if (!listener || listener.removed) {
                return false;
            }
            var src = listener.src;
            if (goog.events.Listenable.isImplementedBy(src)) {
                return /** @type {!goog.events.Listenable} */ (src).unlistenByKey(listener);
            }
            var type = listener.type;
            var proxy = listener.proxy;
            if (src.removeEventListener) {
                src.removeEventListener(type, proxy, listener.capture);
            }
            else if (src.detachEvent) {
                src.detachEvent(goog.events.getOnString_(type), proxy);
            }
            else if (src.addListener && src.removeListener) {
                src.removeListener(proxy);
            }
            goog.events.listenerCountEstimate_--;
            var listenerMap = goog.events.getListenerMap_(
            /** @type {!EventTarget} */ (src));
            // TODO(chrishenry): Try to remove this conditional and execute the
            // first branch always. This should be safe.
            if (listenerMap) {
                listenerMap.removeByKey(listener);
                if (listenerMap.getTypeCount() == 0) {
                    // Null the src, just because this is simple to do (and useful
                    // for IE <= 7).
                    listenerMap.src = null;
                    // We don't use delete here because IE does not allow delete
                    // on a window object.
                    src[goog.events.LISTENER_MAP_PROP_] = null;
                }
            }
            else {
                /** @type {!goog.events.Listener} */ (listener).markAsRemoved();
            }
            return true;
        }
        events.unlistenByKey = unlistenByKey;
        ;
        /**
         * Removes an event listener which was added with listenWithWrapper().
         *
         * @param {EventTarget|goog.events.Listenable} src The target to stop
         *     listening to events on.
         * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
         * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
         *     listener function to remove.
         * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
         *     whether the listener is fired during the capture or bubble phase of the
         *     event.
         * @param {Object=} opt_handler Element in whose scope to call the listener.
         */
        function unlistenWithWrapper(src, wrapper, listener, opt_capt, opt_handler) {
            wrapper.unlisten(src, listener, opt_capt, opt_handler);
        }
        events.unlistenWithWrapper = unlistenWithWrapper;
        ;
        /**
         * Removes all listeners from an object. You can also optionally
         * remove listeners of a particular type.
         *
         * @param {Object|undefined} obj Object to remove listeners from. Must be an
         *     EventTarget or a goog.events.Listenable.
         * @param {string|!goog.events.EventId=} opt_type Type of event to remove.
         *     Default is all types.
         * @return {number} Number of listeners removed.
         */
        function removeAll(obj, opt_type) {
            // TODO(chrishenry): Change the type of obj to
            // (!EventTarget|!goog.events.Listenable).
            if (!obj) {
                return 0;
            }
            if (goog.events.Listenable.isImplementedBy(obj)) {
                return /** @type {?} */ (obj).removeAllListeners(opt_type);
            }
            var listenerMap = goog.events.getListenerMap_(
            /** @type {!EventTarget} */ (obj));
            if (!listenerMap) {
                return 0;
            }
            var count = 0;
            var typeStr = opt_type && opt_type.toString();
            for (var type in listenerMap.listeners) {
                if (!typeStr || type == typeStr) {
                    // Clone so that we don't need to worry about unlistenByKey
                    // changing the content of the ListenerMap.
                    var listeners = listenerMap.listeners[type].concat();
                    for (var i = 0; i < listeners.length; ++i) {
                        if (goog.events.unlistenByKey(listeners[i])) {
                            ++count;
                        }
                    }
                }
            }
            return count;
        }
        events.removeAll = removeAll;
        ;
        /**
         * Gets the listeners for a given object, type and capture phase.
         *
         * @param {Object} obj Object to get listeners for.
         * @param {string|!goog.events.EventId} type Event type.
         * @param {boolean} capture Capture phase?.
         * @return {Array<!goog.events.Listener>} Array of listener objects.
         */
        function getListeners(obj, type, capture) {
            if (goog.events.Listenable.isImplementedBy(obj)) {
                return /** @type {!goog.events.Listenable} */ (obj).getListeners(type, capture);
            }
            else {
                if (!obj) {
                    // TODO(chrishenry): We should tighten the API to accept
                    // !EventTarget|goog.events.Listenable, and add an assertion here.
                    return [];
                }
                var listenerMap = goog.events.getListenerMap_(
                /** @type {!EventTarget} */ (obj));
                return listenerMap ? listenerMap.getListeners(type, capture) : [];
            }
        }
        events.getListeners = getListeners;
        ;
        /**
         * Gets the goog.events.Listener for the event or null if no such listener is
         * in use.
         *
         * @param {EventTarget|goog.events.Listenable} src The target from
         *     which to get listeners.
         * @param {?string|!goog.events.EventId<EVENTOBJ>} type The type of the event.
         * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null} listener The
         *     listener function to get.
         * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
         *                            whether the listener is fired during the
         *                            capture or bubble phase of the event.
         * @param {Object=} opt_handler Element in whose scope to call the listener.
         * @return {goog.events.ListenableKey} the found listener or null if not found.
         * @template EVENTOBJ
         */
        function getListener(src, type, listener, opt_capt, opt_handler) {
            // TODO(chrishenry): Change type from ?string to string, or add assertion.
            type = /** @type {string} */ (type);
            listener = goog.events.wrapListener(listener);
            var capture = !!opt_capt;
            if (goog.events.Listenable.isImplementedBy(src)) {
                return src.getListener(type, listener, capture, opt_handler);
            }
            if (!src) {
                // TODO(chrishenry): We should tighten the API to only accept
                // non-null objects, or add an assertion here.
                return null;
            }
            var listenerMap = goog.events.getListenerMap_(
            /** @type {!EventTarget} */ (src));
            if (listenerMap) {
                return listenerMap.getListener(type, listener, capture, opt_handler);
            }
            return null;
        }
        events.getListener = getListener;
        ;
        /**
         * Returns whether an event target has any active listeners matching the
         * specified signature. If either the type or capture parameters are
         * unspecified, the function will match on the remaining criteria.
         *
         * @param {EventTarget|goog.events.Listenable} obj Target to get
         *     listeners for.
         * @param {string|!goog.events.EventId=} opt_type Event type.
         * @param {boolean=} opt_capture Whether to check for capture or bubble-phase
         *     listeners.
         * @return {boolean} Whether an event target has one or more listeners matching
         *     the requested type and/or capture phase.
         */
        function hasListener(obj, opt_type, opt_capture) {
            if (goog.events.Listenable.isImplementedBy(obj)) {
                return obj.hasListener(opt_type, opt_capture);
            }
            var listenerMap = goog.events.getListenerMap_(
            /** @type {!EventTarget} */ (obj));
            return !!listenerMap && listenerMap.hasListener(opt_type, opt_capture);
        }
        events.hasListener = hasListener;
        ;
        /**
         * Provides a nice string showing the normalized event objects public members
         * @param {Object} e Event Object.
         * @return {string} String of the public members of the normalized event object.
         */
        function expose(e) {
            var str = [];
            for (var key in e) {
                if (e[key] && e[key].id) {
                    str.push(key + ' = ' + e[key] + ' (' + e[key].id + ')');
                }
                else {
                    str.push(key + ' = ' + e[key]);
                }
            }
            return str.join('\n');
        }
        events.expose = expose;
        ;
        /**
         * Returns a string with on prepended to the specified type. This is used for IE
         * which expects "on" to be prepended. This function caches the string in order
         * to avoid extra allocations in steady state.
         * @param {string} type Event type.
         * @return {string} The type string with 'on' prepended.
         * @private
         */
        function getOnString_(type) {
            if (type in goog.events.onStringMap_) {
                return goog.events.onStringMap_[type];
            }
            return goog.events.onStringMap_[type] = goog.events.onString_ + type;
        }
        events.getOnString_ = getOnString_;
        ;
        /**
         * Fires an object's listeners of a particular type and phase
         *
         * @param {Object} obj Object whose listeners to call.
         * @param {string|!goog.events.EventId} type Event type.
         * @param {boolean} capture Which event phase.
         * @param {Object} eventObject Event object to be passed to listener.
         * @return {boolean} True if all listeners returned true else false.
         */
        function fireListeners(obj, type, capture, eventObject) {
            if (goog.events.Listenable.isImplementedBy(obj)) {
                return /** @type {!goog.events.Listenable} */ (obj).fireListeners(type, capture, eventObject);
            }
            return goog.events.fireListeners_(obj, type, capture, eventObject);
        }
        events.fireListeners = fireListeners;
        ;
        /**
         * Fires an object's listeners of a particular type and phase.
         * @param {Object} obj Object whose listeners to call.
         * @param {string|!goog.events.EventId} type Event type.
         * @param {boolean} capture Which event phase.
         * @param {Object} eventObject Event object to be passed to listener.
         * @return {boolean} True if all listeners returned true else false.
         * @private
         */
        function fireListeners_(obj, type, capture, eventObject) {
            /** @type {boolean} */
            var retval = true;
            var listenerMap = goog.events.getListenerMap_(
            /** @type {EventTarget} */ (obj));
            if (listenerMap) {
                // TODO(chrishenry): Original code avoids array creation when there
                // is no listener, so we do the same. If this optimization turns
                // out to be not required, we can replace this with
                // listenerMap.getListeners(type, capture) instead, which is simpler.
                var listenerArray = listenerMap.listeners[type.toString()];
                if (listenerArray) {
                    listenerArray = listenerArray.concat();
                    for (var i = 0; i < listenerArray.length; i++) {
                        var listener = listenerArray[i];
                        // We might not have a listener if the listener was removed.
                        if (listener && listener.capture == capture && !listener.removed) {
                            var result = goog.events.fireListener(listener, eventObject);
                            retval = retval && (result !== false);
                        }
                    }
                }
            }
            return retval;
        }
        events.fireListeners_ = fireListeners_;
        ;
        /**
         * Fires a listener with a set of arguments
         *
         * @param {goog.events.Listener} listener The listener object to call.
         * @param {Object} eventObject The event object to pass to the listener.
         * @return {*} Result of listener.
         */
        function fireListener(listener, eventObject) {
            var listenerFn = listener.listener;
            var listenerHandler = listener.handler || listener.src;
            if (listener.callOnce) {
                goog.events.unlistenByKey(listener);
            }
            return listenerFn.call(listenerHandler, eventObject);
        }
        events.fireListener = fireListener;
        ;
        /**
         * Gets the total number of listeners currently in the system.
         * @return {number} Number of listeners.
         * @deprecated This returns estimated count, now that Closure no longer
         * stores a central listener registry. We still return an estimation
         * to keep existing listener-related tests passing. In the near future,
         * this function will be removed.
         */
        function getTotalListenerCount() {
            return goog.events.listenerCountEstimate_;
        }
        events.getTotalListenerCount = getTotalListenerCount;
        ;
        /**
         * Dispatches an event (or event like object) and calls all listeners
         * listening for events of this type. The type of the event is decided by the
         * type property on the event object.
         *
         * If any of the listeners returns false OR calls preventDefault then this
         * function will return false.  If one of the capture listeners calls
         * stopPropagation, then the bubble listeners won't fire.
         *
         * @param {goog.events.Listenable} src The event target.
         * @param {goog.events.EventLike} e Event object.
         * @return {boolean} If anyone called preventDefault on the event object (or
         *     if any of the handlers returns false) this will also return false.
         *     If there are no handlers, or if all handlers return true, this returns
         *     true.
         */
        function dispatchEvent(src, e) {
            goog.asserts.assert(goog.events.Listenable.isImplementedBy(src), 'Can not use goog.events.dispatchEvent with ' +
                'non-goog.events.Listenable instance.');
            return src.dispatchEvent(e);
        }
        events.dispatchEvent = dispatchEvent;
        ;
        /**
         * Installs exception protection for the browser event entry point using the
         * given error handler.
         *
         * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to
         *     protect the entry point.
         */
        function protectBrowserEventEntryPoint(errorHandler) {
            goog.events.handleBrowserEvent_ =
                errorHandler.protectEntryPoint(goog.events.handleBrowserEvent_);
        }
        events.protectBrowserEventEntryPoint = protectBrowserEventEntryPoint;
        ;
        /**
         * Handles an event and dispatches it to the correct listeners. This
         * function is a proxy for the real listener the user specified.
         *
         * @param {goog.events.Listener} listener The listener object.
         * @param {Event=} opt_evt Optional event object that gets passed in via the
         *     native event handlers.
         * @return {*} Result of the event handler.
         * @this {EventTarget} The object or Element that fired the event.
         * @private
         */
        function handleBrowserEvent_(listener, opt_evt) {
            if (listener.removed) {
                return true;
            }
            // Synthesize event propagation if the browser does not support W3C
            // event model.
            if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
                var ieEvent = opt_evt ||
                    /** @type {Event} */ (goog.getObjectByName('window.event'));
                var evt = new goog.events.BrowserEvent(ieEvent, this);
                /** @type {*} */
                var retval = true;
                if (goog.events.CAPTURE_SIMULATION_MODE ==
                    goog.events.CaptureSimulationMode.ON) {
                    // If we have not marked this event yet, we should perform capture
                    // simulation.
                    if (!goog.events.isMarkedIeEvent_(ieEvent)) {
                        goog.events.markIeEvent_(ieEvent);
                        var ancestors = [];
                        for (var parent = evt.currentTarget; parent; parent = parent.parentNode) {
                            ancestors.push(parent);
                        }
                        // Fire capture listeners.
                        var type = listener.type;
                        for (var i = ancestors.length - 1; !evt.propagationStopped_ && i >= 0; i--) {
                            evt.currentTarget = ancestors[i];
                            var result = goog.events.fireListeners_(ancestors[i], type, true, evt);
                            retval = retval && result;
                        }
                        // Fire bubble listeners.
                        //
                        // We can technically rely on IE to perform bubble event
                        // propagation. However, it turns out that IE fires events in
                        // opposite order of attachEvent registration, which broke
                        // some code and tests that rely on the order. (While W3C DOM
                        // Level 2 Events TR leaves the event ordering unspecified,
                        // modern browsers and W3C DOM Level 3 Events Working Draft
                        // actually specify the order as the registration order.)
                        for (var i = 0; !evt.propagationStopped_ && i < ancestors.length; i++) {
                            evt.currentTarget = ancestors[i];
                            var result = goog.events.fireListeners_(ancestors[i], type, false, evt);
                            retval = retval && result;
                        }
                    }
                }
                else {
                    retval = goog.events.fireListener(listener, evt);
                }
                return retval;
            }
            // Otherwise, simply fire the listener.
            return goog.events.fireListener(listener, new goog.events.BrowserEvent(opt_evt, this));
        }
        events.handleBrowserEvent_ = handleBrowserEvent_;
        ;
        /**
         * This is used to mark the IE event object so we do not do the Closure pass
         * twice for a bubbling event.
         * @param {Event} e The IE browser event.
         * @private
         */
        function markIeEvent_(e) {
            // Only the keyCode and the returnValue can be changed. We use keyCode for
            // non keyboard events.
            // event.returnValue is a bit more tricky. It is undefined by default. A
            // boolean false prevents the default action. In a window.onbeforeunload and
            // the returnValue is non undefined it will be alerted. However, we will only
            // modify the returnValue for keyboard events. We can get a problem if non
            // closure events sets the keyCode or the returnValue
            var useReturnValue = false;
            if (e.keyCode == 0) {
                // We cannot change the keyCode in case that srcElement is input[type=file].
                // We could test that that is the case but that would allocate 3 objects.
                // If we use try/catch we will only allocate extra objects in the case of a
                // failure.
                try {
                    e.keyCode = -1;
                    return;
                }
                catch (ex) {
                    useReturnValue = true;
                }
            }
            if (useReturnValue ||
                /** @type {boolean|undefined} */ (e.returnValue) == undefined) {
                e.returnValue = true;
            }
        }
        events.markIeEvent_ = markIeEvent_;
        ;
        /**
         * This is used to check if an IE event has already been handled by the Closure
         * system so we do not do the Closure pass twice for a bubbling event.
         * @param {Event} e  The IE browser event.
         * @return {boolean} True if the event object has been marked.
         * @private
         */
        function isMarkedIeEvent_(e) {
            return e.keyCode < 0 || e.returnValue != undefined;
        }
        events.isMarkedIeEvent_ = isMarkedIeEvent_;
        ;
        /**
         * Counter to create unique event ids.
         * @private {number}
         */
        events.uniqueIdCounter_ = 0;
        /**
         * Creates a unique event id.
         *
         * @param {string} identifier The identifier.
         * @return {string} A unique identifier.
         * @idGenerator {unique}
         */
        function getUniqueId(identifier) {
            return identifier + '_' + goog.events.uniqueIdCounter_++;
        }
        events.getUniqueId = getUniqueId;
        ;
        /**
         * @param {EventTarget} src The source object.
         * @return {goog.events.ListenerMap} A listener map for the given
         *     source object, or null if none exists.
         * @private
         */
        function getListenerMap_(src) {
            var listenerMap = src[goog.events.LISTENER_MAP_PROP_];
            // IE serializes the property as well (e.g. when serializing outer
            // HTML). So we must check that the value is of the correct type.
            return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;
        }
        events.getListenerMap_ = getListenerMap_;
        ;
        /**
         * Expando property for listener function wrapper for Object with
         * handleEvent.
         * @private @const {string}
         */
        events.LISTENER_WRAPPER_PROP_ = '__closure_events_fn_' + ((Math.random() * 1e9) >>> 0);
        /**
         * @param {Object|Function} listener The listener function or an
         *     object that contains handleEvent method.
         * @return {!Function} Either the original function or a function that
         *     calls obj.handleEvent. If the same listener is passed to this
         *     function more than once, the same function is guaranteed to be
         *     returned.
         */
        function wrapListener(listener) {
            goog.asserts.assert(listener, 'Listener can not be null.');
            if (goog.isFunction(listener)) {
                return listener;
            }
            goog.asserts.assert(listener.handleEvent, 'An object listener must have handleEvent method.');
            if (!listener[goog.events.LISTENER_WRAPPER_PROP_]) {
                listener[goog.events.LISTENER_WRAPPER_PROP_] = function (e) {
                    return /** @type {?} */ (listener).handleEvent(e);
                };
            }
            return listener[goog.events.LISTENER_WRAPPER_PROP_];
        }
        events.wrapListener = wrapListener;
        ;
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
/**
 * @define {number} The capture simulation mode for IE8-. By default,
 *     this is ON.
 */
goog.define('goog.events.CAPTURE_SIMULATION_MODE', 2);
// Register the browser event handler as an entry point, so that
// it can be monitored for exception handling, etc.
goog.debug.entryPointRegistry.register(
/**
 * @param {function(!Function): !Function} transformer The transforming
 *     function.
 */
function (transformer) {
    goog.events.handleBrowserEvent_ =
        transformer(goog.events.handleBrowserEvent_);
});
/// <reference path="../disposable/Disposable" />
/// <reference path="../events/events" />
/// <reference path="../object/object" />
/// <reference path="../events/EventWrapper" />
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Class to create objects which want to handle multiple events
 * and have their listeners easily cleaned up via a dispose method.
 *
 * Example:
 * <pre>
 * function Something() {
 *   Something.base(this);
 *
 *   ... set up object ...
 *
 *   // Add event listeners
 *   this.listen(this.starEl, goog.events.EventType.CLICK, this.handleStar);
 *   this.listen(this.headerEl, goog.events.EventType.CLICK, this.expand);
 *   this.listen(this.collapseEl, goog.events.EventType.CLICK, this.collapse);
 *   this.listen(this.infoEl, goog.events.EventType.MOUSEOVER, this.showHover);
 *   this.listen(this.infoEl, goog.events.EventType.MOUSEOUT, this.hideHover);
 * }
 * goog.inherits(Something, goog.events.EventHandler);
 *
 * Something.prototype.disposeInternal = function() {
 *   Something.base(this, 'disposeInternal');
 *   goog.dom.removeNode(this.container);
 * };
 *
 *
 * // Then elsewhere:
 *
 * var activeSomething = null;
 * function openSomething() {
 *   activeSomething = new Something();
 * }
 *
 * function closeSomething() {
 *   if (activeSomething) {
 *     activeSomething.dispose();  // Remove event listeners
 *     activeSomething = null;
 *   }
 * }
 * </pre>
 *
 */
goog.provide('goog.events.EventHandler');
goog.require('goog.Disposable');
goog.require('goog.events');
goog.require('goog.object');
goog.forwardDeclare('goog.events.EventWrapper');
var goog;
(function (goog) {
    var events;
    (function (events) {
        var EventHandler = /** @class */ (function (_super) {
            __extends(EventHandler, _super);
            /**
             * Super class for objects that want to easily manage a number of event
             * listeners.  It allows a short cut to listen and also provides a quick way
             * to remove all events listeners belonging to this object.
             * @param {SCOPE=} opt_scope Object in whose scope to call the listeners.
             * @constructor
             * @extends {goog.Disposable}
             * @template SCOPE
             */
            function EventHandler(opt_scope) {
                var _this = _super.call(this) || this;
                goog.Disposable.call(_this);
                // TODO(mknichel): Rename this to this.scope_ and fix the classes in google3
                // that access this private variable. :(
                _this.handler_ = opt_scope;
                /**
                 * Keys for events that are being listened to.
                 * @type {!Object<!goog.events.Key>}
                 * @private
                 */
                _this.keys_ = {};
                return _this;
            }
            /**
             * Listen to an event on a Listenable.  If the function is omitted then the
             * EventHandler's handleEvent method will be used.
             * @param {goog.events.ListenableType} src Event source.
             * @param {string|Array<string>|
             *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
             *     type Event type to listen for or array of event types.
             * @param {function(this:SCOPE, EVENTOBJ):?|{handleEvent:function(?):?}|null=}
             *     opt_fn Optional callback function to be used as the listener or an object
             *     with handleEvent function.
             * @param {(boolean|!AddEventListenerOptions)=} opt_options
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template EVENTOBJ, THIS
             */
            EventHandler.prototype.listen = function (src, type, opt_fn, opt_options) {
                var self = (this);
                return self.listen_(src, type, opt_fn, opt_options);
            };
            ;
            /**
             * Listen to an event on a Listenable.  If the function is omitted then the
             * EventHandler's handleEvent method will be used.
             * @param {goog.events.ListenableType} src Event source.
             * @param {string|Array<string>|
             *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
             *     type Event type to listen for or array of event types.
             * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(this:T, ?):?}|
             *     null|undefined} fn Optional callback function to be used as the
             *     listener or an object with handleEvent function.
             * @param {boolean|!AddEventListenerOptions|undefined} options
             * @param {T} scope Object in whose scope to call the listener.
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template T, EVENTOBJ, THIS
             */
            EventHandler.prototype.listenWithScope = function (src, type, fn, options, scope) {
                var self = (this);
                // TODO(mknichel): Deprecate this function.
                return self.listen_(src, type, fn, options, scope);
            };
            ;
            /**
             * Listen to an event on a Listenable.  If the function is omitted then the
             * EventHandler's handleEvent method will be used.
             * @param {goog.events.ListenableType} src Event source.
             * @param {string|Array<string>|
             *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
             *     type Event type to listen for or array of event types.
             * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null=} opt_fn
             *     Optional callback function to be used as the listener or an object with
             *     handleEvent function.
             * @param {(boolean|!AddEventListenerOptions)=} opt_options
             * @param {Object=} opt_scope Object in whose scope to call the listener.
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template EVENTOBJ, THIS
             * @private
             */
            EventHandler.prototype.listen_ = function (src, type, opt_fn, opt_options, opt_scope) {
                var self = (this);
                if (!goog.isArray(type)) {
                    if (type) {
                        goog.events.EventHandler.typeArray_[0] = type.toString();
                    }
                    type = goog.events.EventHandler.typeArray_;
                }
                for (var i = 0; i < type.length; i++) {
                    var listenerObj = goog.events.listen(src, type[i], opt_fn || self.handleEvent, opt_options || false, opt_scope || self.handler_ || self);
                    if (!listenerObj) {
                        // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT
                        // (goog.events.CaptureSimulationMode) in IE8-, it will return null
                        // value.
                        return self;
                    }
                    var key = listenerObj.key;
                    self.keys_[key] = listenerObj;
                }
                return self;
            };
            ;
            /**
             * Listen to an event on a Listenable.  If the function is omitted, then the
             * EventHandler's handleEvent method will be used. After the event has fired the
             * event listener is removed from the target. If an array of event types is
             * provided, each event type will be listened to once.
             * @param {goog.events.ListenableType} src Event source.
             * @param {string|Array<string>|
             *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
             *     type Event type to listen for or array of event types.
             * @param {function(this:SCOPE, EVENTOBJ):?|{handleEvent:function(?):?}|null=}
             * opt_fn
             *    Optional callback function to be used as the listener or an object with
             *    handleEvent function.
             * @param {(boolean|!AddEventListenerOptions)=} opt_options
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template EVENTOBJ, THIS
             */
            EventHandler.prototype.listenOnce = function (src, type, opt_fn, opt_options) {
                var self = (this);
                return self.listenOnce_(src, type, opt_fn, opt_options);
            };
            ;
            /**
             * Listen to an event on a Listenable.  If the function is omitted, then the
             * EventHandler's handleEvent method will be used. After the event has fired the
             * event listener is removed from the target. If an array of event types is
             * provided, each event type will be listened to once.
             * @param {goog.events.ListenableType} src Event source.
             * @param {string|Array<string>|
             *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
             *     type Event type to listen for or array of event types.
             * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(this:T, ?):?}|
             *     null|undefined} fn Optional callback function to be used as the
             *     listener or an object with handleEvent function.
             * @param {boolean|undefined} capture Optional whether to use capture phase.
             * @param {T} scope Object in whose scope to call the listener.
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template T, EVENTOBJ, THIS
             */
            EventHandler.prototype.listenOnceWithScope = function (src, type, fn, capture, scope) {
                var self = (this);
                // TODO(mknichel): Deprecate this function.
                return self.listenOnce_(src, type, fn, capture, scope);
            };
            ;
            /**
             * Listen to an event on a Listenable.  If the function is omitted, then the
             * EventHandler's handleEvent method will be used. After the event has fired
             * the event listener is removed from the target. If an array of event types is
             * provided, each event type will be listened to once.
             * @param {goog.events.ListenableType} src Event source.
             * @param {string|Array<string>|
             *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
             *     type Event type to listen for or array of event types.
             * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null=} opt_fn
             *    Optional callback function to be used as the listener or an object with
             *    handleEvent function.
             * @param {(boolean|!AddEventListenerOptions)=} opt_options
             * @param {Object=} opt_scope Object in whose scope to call the listener.
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template EVENTOBJ, THIS
             * @private
             */
            EventHandler.prototype.listenOnce_ = function (src, type, opt_fn, opt_options, opt_scope) {
                var self = (this);
                if (goog.isArray(type)) {
                    for (var i = 0; i < type.length; i++) {
                        self.listenOnce_(src, type[i], opt_fn, opt_options, opt_scope);
                    }
                }
                else {
                    var listenerObj = goog.events.listenOnce(src, type, opt_fn || self.handleEvent, opt_options, opt_scope || self.handler_ || self);
                    if (!listenerObj) {
                        // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT
                        // (goog.events.CaptureSimulationMode) in IE8-, it will return null
                        // value.
                        return self;
                    }
                    var key = listenerObj.key;
                    self.keys_[key] = listenerObj;
                }
                return self;
            };
            ;
            /**
             * Adds an event listener with a specific event wrapper on a DOM Node or an
             * object that has implemented {@link goog.events.EventTarget}. A listener can
             * only be added once to an object.
             *
             * @param {EventTarget|goog.events.EventTarget} src The node to listen to
             *     events on.
             * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
             * @param {function(this:SCOPE, ?):?|{handleEvent:function(?):?}|null} listener
             *     Callback method, or an object with a handleEvent function.
             * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
             *     false).
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template THIS
             */
            EventHandler.prototype.listenWithWrapper = function (src, wrapper, listener, opt_capt) {
                var self = (this);
                // TODO(mknichel): Remove the opt_scope from this function and then
                // templatize it.
                return self.listenWithWrapper_(src, wrapper, listener, opt_capt);
            };
            ;
            /**
             * Adds an event listener with a specific event wrapper on a DOM Node or an
             * object that has implemented {@link goog.events.EventTarget}. A listener can
             * only be added once to an object.
             *
             * @param {EventTarget|goog.events.EventTarget} src The node to listen to
             *     events on.
             * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
             * @param {function(this:T, ?):?|{handleEvent:function(this:T, ?):?}|null}
             *     listener Optional callback function to be used as the
             *     listener or an object with handleEvent function.
             * @param {boolean|undefined} capture Optional whether to use capture phase.
             * @param {T} scope Object in whose scope to call the listener.
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template T, THIS
             */
            EventHandler.prototype.listenWithWrapperAndScope = function (src, wrapper, listener, capture, scope) {
                var self = (this);
                // TODO(mknichel): Deprecate this function.
                return self.listenWithWrapper_(src, wrapper, listener, capture, scope);
            };
            ;
            /**
             * Adds an event listener with a specific event wrapper on a DOM Node or an
             * object that has implemented {@link goog.events.EventTarget}. A listener can
             * only be added once to an object.
             *
             * @param {EventTarget|goog.events.EventTarget} src The node to listen to
             *     events on.
             * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
             * @param {function(?):?|{handleEvent:function(?):?}|null} listener Callback
             *     method, or an object with a handleEvent function.
             * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
             *     false).
             * @param {Object=} opt_scope Element in whose scope to call the listener.
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template THIS
             * @private
             */
            EventHandler.prototype.listenWithWrapper_ = function (src, wrapper, listener, opt_capt, opt_scope) {
                var self = (this);
                wrapper.listen(src, listener, opt_capt, opt_scope || self.handler_ || self, self);
                return self;
            };
            ;
            /**
             * @return {number} Number of listeners registered by this handler.
             */
            EventHandler.prototype.getListenerCount = function () {
                var count = 0;
                for (var key in this.keys_) {
                    if (Object.prototype.hasOwnProperty.call(this.keys_, key)) {
                        count++;
                    }
                }
                return count;
            };
            ;
            /**
             * Unlistens on an event.
             * @param {goog.events.ListenableType} src Event source.
             * @param {string|Array<string>|
             *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
             *     type Event type or array of event types to unlisten to.
             * @param {function(this:?, EVENTOBJ):?|{handleEvent:function(?):?}|null=}
             *     opt_fn Optional callback function to be used as the listener or an object
             *     with handleEvent function.
             * @param {(boolean|!EventListenerOptions)=} opt_options
             * @param {Object=} opt_scope Object in whose scope to call the listener.
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template EVENTOBJ, THIS
             */
            EventHandler.prototype.unlisten = function (src, type, opt_fn, opt_options, opt_scope) {
                var self = (this);
                if (goog.isArray(type)) {
                    for (var i = 0; i < type.length; i++) {
                        self.unlisten(src, type[i], opt_fn, opt_options, opt_scope);
                    }
                }
                else {
                    var capture = goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
                    var listener = goog.events.getListener(src, type, opt_fn || self.handleEvent, capture, opt_scope || self.handler_ || self);
                    if (listener) {
                        goog.events.unlistenByKey(listener);
                        delete self.keys_[listener.key];
                    }
                }
                return self;
            };
            ;
            /**
             * Removes an event listener which was added with listenWithWrapper().
             *
             * @param {EventTarget|goog.events.EventTarget} src The target to stop
             *     listening to events on.
             * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
             * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
             *     listener function to remove.
             * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
             *     whether the listener is fired during the capture or bubble phase of the
             *     event.
             * @param {Object=} opt_scope Element in whose scope to call the listener.
             * @return {THIS} This object, allowing for chaining of calls.
             * @this {THIS}
             * @template THIS
             */
            EventHandler.prototype.unlistenWithWrapper = function (src, wrapper, listener, opt_capt, opt_scope) {
                var self = (this);
                wrapper.unlisten(src, listener, opt_capt, opt_scope || self.handler_ || self, self);
                return self;
            };
            ;
            /**
             * Unlistens to all events.
             */
            EventHandler.prototype.removeAll = function () {
                goog.object.forEach(this.keys_, function (listenerObj, key) {
                    if (this.keys_.hasOwnProperty(key)) {
                        goog.events.unlistenByKey(listenerObj);
                    }
                }, this);
                this.keys_ = {};
            };
            ;
            /**
             * Disposes of this EventHandler and removes all listeners that it registered.
             * @override
             * @protected
             */
            EventHandler.prototype.disposeInternal = function () {
                _super.prototype.disposeInternal.call(this);
                // goog.events.EventHandler.superClass_.disposeInternal.call(this);
                this.removeAll();
            };
            ;
            /**
             * Default event handler
             * @param {goog.events.Event} e Event object.
             */
            EventHandler.prototype.handleEvent = function (e) {
                throw new Error('EventHandler.handleEvent not implemented');
            };
            ;
            return EventHandler;
        }(goog.Disposable));
        events.EventHandler = EventHandler;
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
(function (goog) {
    var events;
    (function (events) {
        var EventHandler;
        (function (EventHandler) {
            /**
             * Utility array used to unify the cases of listening for an array of types
             * and listening for a single event, without using recursion or allocating
             * an array each time.
             * @type {!Array<string>}
             * @const
             * @private
             */
            EventHandler.typeArray_ = [];
        })(EventHandler = events.EventHandler || (events.EventHandler = {}));
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
/// <reference path="../disposable/Disposable" />
/// <reference path="../asserts/asserts" />
/// <reference path="../events/events" />
/// <reference path="../events/Event" />
/// <reference path="../events/Listenable" />
/// <reference path="../events/ListenerMap" />
/// <reference path="../object/object" />
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A disposable implementation of a custom
 * listenable/event target. See also: documentation for
 * {@code goog.events.Listenable}.
 *
 * @author arv@google.com (Erik Arvidsson) [Original implementation]
 * @see ../demos/eventtarget.html
 * @see goog.events.Listenable
 */
goog.provide('goog.events.EventTarget');
goog.require('goog.Disposable');
goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.Event');
goog.require('goog.events.Listenable');
goog.require('goog.events.ListenerMap');
goog.require('goog.object');
var goog;
(function (goog) {
    var events;
    (function (events) {
        var EventTarget = /** @class */ (function (_super) {
            __extends(EventTarget, _super);
            /**
             * An implementation of {@code goog.events.Listenable} with full W3C
             * EventTarget-like support (capture/bubble mechanism, stopping event
             * propagation, preventing default actions).
             *
             * You may subclass this class to turn your class into a Listenable.
             *
             * Unless propagation is stopped, an event dispatched by an
             * EventTarget will bubble to the parent returned by
             * {@code getParentEventTarget}. To set the parent, call
             * {@code setParentEventTarget}. Subclasses that don't support
             * changing the parent can override the setter to throw an error.
             *
             * Example usage:
             * <pre>
             *   var source = new goog.events.EventTarget();
             *   function handleEvent(e) {
             *     alert('Type: ' + e.type + '; Target: ' + e.target);
             *   }
             *   source.listen('foo', handleEvent);
             *   // Or: goog.events.listen(source, 'foo', handleEvent);
             *   ...
             *   source.dispatchEvent('foo');  // will call handleEvent
             *   ...
             *   source.unlisten('foo', handleEvent);
             *   // Or: goog.events.unlisten(source, 'foo', handleEvent);
             * </pre>
             *
             * @constructor
             * @extends {goog.Disposable}
             * @implements {goog.events.Listenable}
             */
            function EventTarget() {
                var _this = _super.call(this) || this;
                goog.Disposable.call(_this);
                /**
                 * Maps of event type to an array of listeners.
                 * @private {!goog.events.ListenerMap}
                 */
                _this.eventTargetListeners_ = new goog.events.ListenerMap(_this);
                /**
                 * The object to use for event.target. Useful when mixing in an
                 * EventTarget to another object.
                 * @private {!Object}
                 */
                _this.actualEventTarget_ = _this;
                /**
                 * Parent event target, used during event bubbling.
                 *
                 * TODO(chrishenry): Change this to goog.events.Listenable. This
                 * currently breaks people who expect getParentEventTarget to return
                 * goog.events.EventTarget.
                 *
                 * @private {goog.events.EventTarget}
                 */
                _this.parentEventTarget_ = null;
                return _this;
            }
            /**
             * Returns the parent of this event target to use for bubbling.
             *
             * @return {goog.events.EventTarget} The parent EventTarget or null if
             *     there is no parent.
             * @override
             */
            EventTarget.prototype.getParentEventTarget = function () {
                return this.parentEventTarget_;
            };
            ;
            /**
             * Sets the parent of this event target to use for capture/bubble
             * mechanism.
             * @param {goog.events.EventTarget} parent Parent listenable (null if none).
             */
            EventTarget.prototype.setParentEventTarget = function (parent) {
                this.parentEventTarget_ = parent;
            };
            ;
            /**
             * Adds an event listener to the event target. The same handler can only be
             * added once per the type. Even if you add the same handler multiple times
             * using the same type then it will only be called once when the event is
             * dispatched.
             *
             * @param {string|!goog.events.EventId} type The type of the event to listen for
             * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function
             *     to handle the event. The handler can also be an object that implements
             *     the handleEvent method which takes the event object as argument.
             * @param {boolean=} opt_capture In DOM-compliant browsers, this determines
             *     whether the listener is fired during the capture or bubble phase
             *     of the event.
             * @param {Object=} opt_handlerScope Object in whose scope to call
             *     the listener.
             * @deprecated Use {@code #listen} instead, when possible. Otherwise, use
             *     {@code goog.events.listen} if you are passing Object
             *     (instead of Function) as handler.
             */
            EventTarget.prototype.addEventListener = function (type, handler, opt_capture, opt_handlerScope) {
                goog.events.listen(this, type, handler, opt_capture, opt_handlerScope);
            };
            ;
            /**
             * Removes an event listener from the event target. The handler must be the
             * same object as the one added. If the handler has not been added then
             * nothing is done.
             *
             * @param {string} type The type of the event to listen for.
             * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function
             *     to handle the event. The handler can also be an object that implements
             *     the handleEvent method which takes the event object as argument.
             * @param {boolean=} opt_capture In DOM-compliant browsers, this determines
             *     whether the listener is fired during the capture or bubble phase
             *     of the event.
             * @param {Object=} opt_handlerScope Object in whose scope to call
             *     the listener.
             * @deprecated Use {@code #unlisten} instead, when possible. Otherwise, use
             *     {@code goog.events.unlisten} if you are passing Object
             *     (instead of Function) as handler.
             */
            EventTarget.prototype.removeEventListener = function (type, handler, opt_capture, opt_handlerScope) {
                goog.events.unlisten(this, type, handler, opt_capture, opt_handlerScope);
            };
            ;
            /** @override */
            EventTarget.prototype.dispatchEvent = function (e) {
                this.assertInitialized_();
                var ancestorsTree, ancestor = this.getParentEventTarget();
                if (ancestor) {
                    ancestorsTree = [];
                    var ancestorCount = 1;
                    for (; ancestor; ancestor = ancestor.getParentEventTarget()) {
                        ancestorsTree.push(ancestor);
                        goog.asserts.assert((++ancestorCount < goog.events.EventTarget.MAX_ANCESTORS_), 'infinite loop');
                    }
                }
                return goog.events.EventTarget.dispatchEventInternal_(this.actualEventTarget_, e, ancestorsTree);
            };
            ;
            /**
             * Removes listeners from this object.  Classes that extend EventTarget may
             * need to override this method in order to remove references to DOM Elements
             * and additional listeners.
             * @override
             */
            EventTarget.prototype.disposeInternal = function () {
                _super.prototype.disposeInternal.call(this);
                // goog.events.EventTarget.superClass_.disposeInternal.call(this);
                this.removeAllListeners();
                this.parentEventTarget_ = null;
            };
            ;
            /** @override */
            EventTarget.prototype.listen = function (type, listener, opt_useCapture, opt_listenerScope) {
                this.assertInitialized_();
                return this.eventTargetListeners_.add(String(type), listener, false /* callOnce */, opt_useCapture, opt_listenerScope);
            };
            ;
            /** @override */
            EventTarget.prototype.listenOnce = function (type, listener, opt_useCapture, opt_listenerScope) {
                return this.eventTargetListeners_.add(String(type), listener, true /* callOnce */, opt_useCapture, opt_listenerScope);
            };
            ;
            /** @override */
            EventTarget.prototype.unlisten = function (type, listener, opt_useCapture, opt_listenerScope) {
                return this.eventTargetListeners_.remove(String(type), listener, opt_useCapture, opt_listenerScope);
            };
            ;
            /** @override */
            EventTarget.prototype.unlistenByKey = function (key) {
                return this.eventTargetListeners_.removeByKey(key);
            };
            ;
            /** @override */
            EventTarget.prototype.removeAllListeners = function (opt_type) {
                // TODO(chrishenry): Previously, removeAllListeners can be called on
                // uninitialized EventTarget, so we preserve that behavior. We
                // should remove this when usages that rely on that fact are purged.
                if (!this.eventTargetListeners_) {
                    return 0;
                }
                return this.eventTargetListeners_.removeAll(opt_type);
            };
            ;
            /** @override */
            EventTarget.prototype.fireListeners = function (type, capture, eventObject) {
                // TODO(chrishenry): Original code avoids array creation when there
                // is no listener, so we do the same. If this optimization turns
                // out to be not required, we can replace this with
                // getListeners(type, capture) instead, which is simpler.
                var listenerArray = this.eventTargetListeners_.listeners[String(type)];
                if (!listenerArray) {
                    return true;
                }
                listenerArray = listenerArray.concat();
                var rv = true;
                for (var i = 0; i < listenerArray.length; ++i) {
                    var listener = listenerArray[i];
                    // We might not have a listener if the listener was removed.
                    if (listener && !listener.removed && listener.capture == capture) {
                        var listenerFn = listener.listener;
                        var listenerHandler = listener.handler || listener.src;
                        if (listener.callOnce) {
                            this.unlistenByKey(listener);
                        }
                        rv = listenerFn.call(listenerHandler, eventObject) !== false && rv;
                    }
                }
                return rv && eventObject.returnValue_ != false;
            };
            ;
            /** @override */
            EventTarget.prototype.getListeners = function (type, capture) {
                return this.eventTargetListeners_.getListeners(String(type), capture);
            };
            ;
            /** @override */
            EventTarget.prototype.getListener = function (type, listener, capture, opt_listenerScope) {
                return this.eventTargetListeners_.getListener(String(type), listener, capture, opt_listenerScope);
            };
            ;
            /** @override */
            EventTarget.prototype.hasListener = function (opt_type, opt_capture) {
                var id = goog.isDef(opt_type) ? String(opt_type) : undefined;
                return this.eventTargetListeners_.hasListener(id, opt_capture);
            };
            ;
            /**
             * Sets the target to be used for {@code event.target} when firing
             * event. Mainly used for testing. For example, see
             * {@code goog.testing.events.mixinListenable}.
             * @param {!Object} target The target.
             */
            EventTarget.prototype.setTargetForTesting = function (target) {
                this.actualEventTarget_ = target;
            };
            ;
            /**
             * Asserts that the event target instance is initialized properly.
             * @private
             */
            EventTarget.prototype.assertInitialized_ = function () {
                goog.asserts.assert(this.eventTargetListeners_, 'Event target is not initialized. Did you call the superclass ' +
                    '(goog.events.EventTarget) constructor?');
            };
            ;
            return EventTarget;
        }(goog.Disposable));
        events.EventTarget = EventTarget;
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
(function (goog) {
    var events;
    (function (events) {
        var EventTarget;
        (function (EventTarget) {
            /**
             * An artificial cap on the number of ancestors you can have. This is mainly
             * for loop detection.
             * @const {number}
             * @private
             */
            EventTarget.MAX_ANCESTORS_ = 1000;
            /**
             * Dispatches the given event on the ancestorsTree.
             *
             * @param {!Object} target The target to dispatch on.
             * @param {goog.events.Event|Object|string} e The event object.
             * @param {Array<goog.events.Listenable>=} opt_ancestorsTree The ancestors
             *     tree of the target, in reverse order from the closest ancestor
             *     to the root event target. May be null if the target has no ancestor.
             * @return {boolean} If anyone called preventDefault on the event object (or
             *     if any of the listeners returns false) this will also return false.
             * @private
             */
            function dispatchEventInternal_(target, e, opt_ancestorsTree) {
                var type = e.type || /** @type {string} */ (e);
                // If accepting a string or object, create a custom event object so that
                // preventDefault and stopPropagation work with the event.
                if (goog.isString(e)) {
                    e = new goog.events.Event(e, target);
                }
                else if (!(e instanceof goog.events.Event)) {
                    var oldEvent = e;
                    e = new goog.events.Event(type, target);
                    goog.object.extend(e, oldEvent);
                }
                else {
                    e.target = e.target || target;
                }
                var rv = true, currentTarget;
                // Executes all capture listeners on the ancestors, if any.
                if (opt_ancestorsTree) {
                    for (var i = opt_ancestorsTree.length - 1; !e.propagationStopped_ && i >= 0; i--) {
                        currentTarget = e.currentTarget = opt_ancestorsTree[i];
                        rv = currentTarget.fireListeners(type, true, e) && rv;
                    }
                }
                // Executes capture and bubble listeners on the target.
                if (!e.propagationStopped_) {
                    currentTarget = /** @type {?} */ (e.currentTarget = target);
                    rv = currentTarget.fireListeners(type, true, e) && rv;
                    if (!e.propagationStopped_) {
                        rv = currentTarget.fireListeners(type, false, e) && rv;
                    }
                }
                // Executes all bubble listeners on the ancestors, if any.
                if (opt_ancestorsTree) {
                    for (i = 0; !e.propagationStopped_ && i < opt_ancestorsTree.length; i++) {
                        currentTarget = e.currentTarget = opt_ancestorsTree[i];
                        rv = currentTarget.fireListeners(type, false, e) && rv;
                    }
                }
                return rv;
            }
            EventTarget.dispatchEventInternal_ = dispatchEventInternal_;
            ;
        })(EventTarget = events.EventTarget || (events.EventTarget = {}));
    })(events = goog.events || (goog.events = {}));
})(goog || (goog = {}));
goog.inherits(goog.events.EventTarget, goog.Disposable);
goog.events.Listenable.addImplementation(goog.events.EventTarget);
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Vendor prefix getters.
 */
goog.provide('goog.dom.vendor');
goog.require('goog.string');
goog.require('goog.userAgent');
var goog;
(function (goog) {
    var dom;
    (function (dom) {
        var vendor;
        (function (vendor) {
            /**
             * Returns the JS vendor prefix used in CSS properties. Different vendors
             * use different methods of changing the case of the property names.
             *
             * @return {?string} The JS vendor prefix or null if there is none.
             */
            function getVendorJsPrefix() {
                if (goog.userAgent.WEBKIT) {
                    return 'Webkit';
                }
                else if (goog.userAgent.GECKO) {
                    return 'Moz';
                }
                else if (goog.userAgent.IE) {
                    return 'ms';
                }
                else if (goog.userAgent.OPERA) {
                    return 'O';
                }
                return null;
            }
            vendor.getVendorJsPrefix = getVendorJsPrefix;
            ;
            /**
             * Returns the vendor prefix used in CSS properties.
             *
             * @return {?string} The vendor prefix or null if there is none.
             */
            function getVendorPrefix() {
                if (goog.userAgent.WEBKIT) {
                    return '-webkit';
                }
                else if (goog.userAgent.GECKO) {
                    return '-moz';
                }
                else if (goog.userAgent.IE) {
                    return '-ms';
                }
                else if (goog.userAgent.OPERA) {
                    return '-o';
                }
                return null;
            }
            vendor.getVendorPrefix = getVendorPrefix;
            ;
            /**
             * @param {string} propertyName A property name.
             * @param {!Object=} opt_object If provided, we verify if the property exists in
             *     the object.
             * @return {?string} A vendor prefixed property name, or null if it does not
             *     exist.
             */
            function getPrefixedPropertyName(propertyName, opt_object) {
                // We first check for a non-prefixed property, if available.
                if (opt_object && propertyName in opt_object) {
                    return propertyName;
                }
                var prefix = goog.dom.vendor.getVendorJsPrefix();
                if (prefix) {
                    prefix = prefix.toLowerCase();
                    var prefixedPropertyName = prefix + goog.string.toTitleCase(propertyName);
                    return (!goog.isDef(opt_object) || prefixedPropertyName in opt_object) ?
                        prefixedPropertyName :
                        null;
                }
                return null;
            }
            vendor.getPrefixedPropertyName = getPrefixedPropertyName;
            ;
            /**
             * @param {string} eventType An event type.
             * @return {string} A lower-cased vendor prefixed event type.
             */
            function getPrefixedEventType(eventType) {
                var prefix = goog.dom.vendor.getVendorJsPrefix() || '';
                return (prefix + eventType).toLowerCase();
            }
            vendor.getPrefixedEventType = getPrefixedEventType;
            ;
        })(vendor = dom.vendor || (dom.vendor = {}));
    })(dom = goog.dom || (goog.dom = {}));
})(goog || (goog = {}));
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A utility class for representing a numeric box.
 */
goog.provide('goog.math.Box');
goog.require('goog.asserts');
goog.require('goog.math.Coordinate');
var goog;
(function (goog) {
    var math;
    (function (math) {
        /**
          * Class for representing a box. A box is specified as a top, right, bottom,
          * and left. A box is useful for representing margins and padding.
          *
          * This class assumes 'screen coordinates': larger Y coordinates are further
          * from the top of the screen.
         */
        var Box = /** @class */ (function () {
            /**
        
             *
             * @param {number} top Top.
             * @param {number} right Right.
             * @param {number} bottom Bottom.
             * @param {number} left Left.
             * @struct
             * @constructor
             */
            function Box(top, right, bottom, left) {
                /**
                 * Rounds the fields to the next larger integer values.
                 *
                 * @return {!goog.math.Box} This box with ceil'd fields.
                 */
                this.ceil = function () {
                    this.top = Math.ceil(this.top);
                    this.right = Math.ceil(this.right);
                    this.bottom = Math.ceil(this.bottom);
                    this.left = Math.ceil(this.left);
                    return this;
                };
                /**
                 * Top
                 * @type {number}
                 */
                this.top = top;
                /**
                 * Right
                 * @type {number}
                 */
                this.right = right;
                /**
                 * Bottom
                 * @type {number}
                 */
                this.bottom = bottom;
                /**
                 * Left
                 * @type {number}
                 */
                this.left = left;
            }
            /**
             * @return {number} width The width of this Box.
             */
            Box.prototype.getWidth = function () {
                return this.right - this.left;
            };
            ;
            /**
             * @return {number} height The height of this Box.
             */
            Box.prototype.getHeight = function () {
                return this.bottom - this.top;
            };
            ;
            /**
             * Creates a copy of the box with the same dimensions.
             * @return {!goog.math.Box} A clone of this Box.
             */
            Box.prototype.clone = function () {
                return new goog.math.Box(this.top, this.right, this.bottom, this.left);
            };
            ;
            // if (goog.DEBUG) {
            /**
             * Returns a nice string representing the box.
             * @return {string} In the form (50t, 73r, 24b, 13l).
             * @override
             */
            Box.prototype.toString = function () {
                return '(' + this.top + 't, ' + this.right + 'r, ' + this.bottom + 'b, ' +
                    this.left + 'l)';
            };
            ;
            // }
            /**
             * Returns whether the box contains a coordinate or another box.
             *
             * @param {goog.math.Coordinate|goog.math.Box} other A Coordinate or a Box.
             * @return {boolean} Whether the box contains the coordinate or other box.
             */
            Box.prototype.contains = function (other) {
                return goog.math.Box.contains(this, other);
            };
            ;
            /**
             * Expands box with the given margins.
             *
             * @param {number|goog.math.Box} top Top margin or box with all margins.
             * @param {number=} opt_right Right margin.
             * @param {number=} opt_bottom Bottom margin.
             * @param {number=} opt_left Left margin.
             * @return {!goog.math.Box} A reference to this Box.
             */
            Box.prototype.expand = function (top, opt_right, opt_bottom, opt_left) {
                if (goog.isObject(top)) {
                    this.top -= top.top;
                    this.right += top.right;
                    this.bottom += top.bottom;
                    this.left -= top.left;
                }
                else {
                    this.top -= /** @type {number} */ (top);
                    this.right += Number(opt_right);
                    this.bottom += Number(opt_bottom);
                    this.left -= Number(opt_left);
                }
                return this;
            };
            ;
            /**
             * Expand this box to include another box.
             * NOTE(user): This is used in code that needs to be very fast, please don't
             * add functionality to this function at the expense of speed (variable
             * arguments, accepting multiple argument types, etc).
             * @param {goog.math.Box} box The box to include in this one.
             */
            Box.prototype.expandToInclude = function (box) {
                this.left = Math.min(this.left, box.left);
                this.top = Math.min(this.top, box.top);
                this.right = Math.max(this.right, box.right);
                this.bottom = Math.max(this.bottom, box.bottom);
            };
            ;
            /**
             * Expand this box to include the coordinate.
             * @param {!goog.math.Coordinate} coord The coordinate to be included
             *     inside the box.
             */
            Box.prototype.expandToIncludeCoordinate = function (coord) {
                this.top = Math.min(this.top, coord.y);
                this.right = Math.max(this.right, coord.x);
                this.bottom = Math.max(this.bottom, coord.y);
                this.left = Math.min(this.left, coord.x);
            };
            ;
            /**
             * Rounds the fields to the next smaller integer values.
             *
             * @return {!goog.math.Box} This box with floored fields.
             */
            Box.prototype.floor = function () {
                this.top = Math.floor(this.top);
                this.right = Math.floor(this.right);
                this.bottom = Math.floor(this.bottom);
                this.left = Math.floor(this.left);
                return this;
            };
            ;
            /**
             * Rounds the fields to nearest integer values.
             *
             * @return {!goog.math.Box} This box with rounded fields.
             */
            Box.prototype.round = function () {
                this.top = Math.round(this.top);
                this.right = Math.round(this.right);
                this.bottom = Math.round(this.bottom);
                this.left = Math.round(this.left);
                return this;
            };
            ;
            /**
             * Translates this box by the given offsets. If a {@code goog.math.Coordinate}
             * is given, then the left and right values are translated by the coordinate's
             * x value and the top and bottom values are translated by the coordinate's y
             * value.  Otherwise, {@code tx} and {@code opt_ty} are used to translate the x
             * and y dimension values.
             *
             * @param {number|goog.math.Coordinate} tx The value to translate the x
             *     dimension values by or the the coordinate to translate this box by.
             * @param {number=} opt_ty The value to translate y dimension values by.
             * @return {!goog.math.Box} This box after translating.
             */
            Box.prototype.translate = function (tx, opt_ty) {
                if (tx instanceof goog.math.Coordinate) {
                    this.left += tx.x;
                    this.right += tx.x;
                    this.top += tx.y;
                    this.bottom += tx.y;
                }
                else {
                    goog.asserts.assertNumber(tx);
                    this.left += tx;
                    this.right += tx;
                    if (goog.isNumber(opt_ty)) {
                        this.top += opt_ty;
                        this.bottom += opt_ty;
                    }
                }
                return this;
            };
            ;
            /**
             * Scales this coordinate by the given scale factors. The x and y dimension
             * values are scaled by {@code sx} and {@code opt_sy} respectively.
             * If {@code opt_sy} is not given, then {@code sx} is used for both x and y.
             *
             * @param {number} sx The scale factor to use for the x dimension.
             * @param {number=} opt_sy The scale factor to use for the y dimension.
             * @return {!goog.math.Box} This box after scaling.
             */
            Box.prototype.scale = function (sx, opt_sy) {
                var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
                this.left *= sx;
                this.right *= sx;
                this.top *= sy;
                this.bottom *= sy;
                return this;
            };
            ;
            return Box;
        }());
        math.Box = Box;
    })(math = goog.math || (goog.math = {}));
})(goog || (goog = {}));
(function (goog) {
    var math;
    (function (math) {
        var Box;
        (function (Box) {
            /**
             * Creates a Box by bounding a collection of goog.math.Coordinate objects
             * @param {...goog.math.Coordinate} var_args Coordinates to be included inside
             *     the box.
             * @return {!goog.math.Box} A Box containing all the specified Coordinates.
             */
            function boundingBox(var_args) {
                var box = new goog.math.Box(arguments[0].y, arguments[0].x, arguments[0].y, arguments[0].x);
                for (var i = 1; i < arguments.length; i++) {
                    box.expandToIncludeCoordinate(arguments[i]);
                }
                return box;
            }
            Box.boundingBox = boundingBox;
            ;
            /**
             * Compares boxes for equality.
             * @param {goog.math.Box} a A Box.
             * @param {goog.math.Box} b A Box.
             * @return {boolean} True iff the boxes are equal, or if both are null.
             */
            function equals(a, b) {
                if (a == b) {
                    return true;
                }
                if (!a || !b) {
                    return false;
                }
                return a.top == b.top && a.right == b.right && a.bottom == b.bottom &&
                    a.left == b.left;
            }
            Box.equals = equals;
            ;
            /**
             * Returns whether a box contains a coordinate or another box.
             *
             * @param {goog.math.Box} box A Box.
             * @param {goog.math.Coordinate|goog.math.Box} other A Coordinate or a Box.
             * @return {boolean} Whether the box contains the coordinate or other box.
             */
            function contains(box, other) {
                if (!box || !other) {
                    return false;
                }
                if (other instanceof goog.math.Box) {
                    return other.left >= box.left && other.right <= box.right &&
                        other.top >= box.top && other.bottom <= box.bottom;
                }
                // other is a Coordinate.
                return other.x >= box.left && other.x <= box.right && other.y >= box.top &&
                    other.y <= box.bottom;
            }
            Box.contains = contains;
            ;
            /**
             * Returns the relative x position of a coordinate compared to a box.  Returns
             * zero if the coordinate is inside the box.
             *
             * @param {goog.math.Box} box A Box.
             * @param {goog.math.Coordinate} coord A Coordinate.
             * @return {number} The x position of {@code coord} relative to the nearest
             *     side of {@code box}, or zero if {@code coord} is inside {@code box}.
             */
            function relativePositionX(box, coord) {
                if (coord.x < box.left) {
                    return coord.x - box.left;
                }
                else if (coord.x > box.right) {
                    return coord.x - box.right;
                }
                return 0;
            }
            Box.relativePositionX = relativePositionX;
            ;
            /**
             * Returns the relative y position of a coordinate compared to a box.  Returns
             * zero if the coordinate is inside the box.
             *
             * @param {goog.math.Box} box A Box.
             * @param {goog.math.Coordinate} coord A Coordinate.
             * @return {number} The y position of {@code coord} relative to the nearest
             *     side of {@code box}, or zero if {@code coord} is inside {@code box}.
             */
            function relativePositionY(box, coord) {
                if (coord.y < box.top) {
                    return coord.y - box.top;
                }
                else if (coord.y > box.bottom) {
                    return coord.y - box.bottom;
                }
                return 0;
            }
            Box.relativePositionY = relativePositionY;
            ;
            /**
             * Returns the distance between a coordinate and the nearest corner/side of a
             * box. Returns zero if the coordinate is inside the box.
             *
             * @param {goog.math.Box} box A Box.
             * @param {goog.math.Coordinate} coord A Coordinate.
             * @return {number} The distance between {@code coord} and the nearest
             *     corner/side of {@code box}, or zero if {@code coord} is inside
             *     {@code box}.
             */
            function distance(box, coord) {
                var x = goog.math.Box.relativePositionX(box, coord);
                var y = goog.math.Box.relativePositionY(box, coord);
                return Math.sqrt(x * x + y * y);
            }
            Box.distance = distance;
            ;
            /**
             * Returns whether two boxes intersect.
             *
             * @param {goog.math.Box} a A Box.
             * @param {goog.math.Box} b A second Box.
             * @return {boolean} Whether the boxes intersect.
             */
            function intersects(a, b) {
                return (a.left <= b.right && b.left <= a.right && a.top <= b.bottom &&
                    b.top <= a.bottom);
            }
            Box.intersects = intersects;
            ;
            /**
             * Returns whether two boxes would intersect with additional padding.
             *
             * @param {goog.math.Box} a A Box.
             * @param {goog.math.Box} b A second Box.
             * @param {number} padding The additional padding.
             * @return {boolean} Whether the boxes intersect.
             */
            function intersectsWithPadding(a, b, padding) {
                return (a.left <= b.right + padding && b.left <= a.right + padding &&
                    a.top <= b.bottom + padding && b.top <= a.bottom + padding);
            }
            Box.intersectsWithPadding = intersectsWithPadding;
            ;
        })(Box = math.Box || (math.Box = {}));
    })(math = goog.math || (goog.math = {}));
})(goog || (goog = {}));
// Copyright 2016 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A record declaration to allow ClientRect and other rectangle
 * like objects to be used with goog.math.Rect.
 */
goog.provide('goog.math.IRect');
/// <reference path="../asserts/asserts" />
/// <reference path="../math/Box" />
/// <reference path="../math/Coordinate" />
/// <reference path="../math/IRect" />
/// <reference path="../math/Size" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A utility class for representing rectangles. Some of these
 * functions should be migrated over to non-nullable params.
 */
goog.provide('goog.math.Rect');
goog.require('goog.asserts');
goog.require('goog.math.Box');
goog.require('goog.math.Coordinate');
goog.require('goog.math.IRect');
goog.require('goog.math.Size');
var goog;
(function (goog) {
    var math;
    (function (math) {
        var Rect = /** @class */ (function () {
            /**
             * Class for representing rectangular regions.
             * @param {number} x Left.
             * @param {number} y Top.
             * @param {number} w Width.
             * @param {number} h Height.
             * @struct
             * @constructor
             * @implements {goog.math.IRect}
             */
            function Rect(x, y, w, h) {
                /** @type {number} */
                this.left = x;
                /** @type {number} */
                this.top = y;
                /** @type {number} */
                this.width = w;
                /** @type {number} */
                this.height = h;
            }
            /**
             * @return {!goog.math.Rect} A new copy of this Rectangle.
             */
            Rect.prototype.clone = function () {
                return new goog.math.Rect(this.left, this.top, this.width, this.height);
            };
            ;
            /**
             * Returns a new Box object with the same position and dimensions as this
             * rectangle.
             * @return {!goog.math.Box} A new Box representation of this Rectangle.
             */
            Rect.prototype.toBox = function () {
                var right = this.left + this.width;
                var bottom = this.top + this.height;
                return new goog.math.Box(this.top, right, bottom, this.left);
            };
            ;
            // if (goog.DEBUG) {
            /**
             * Returns a nice string representing size and dimensions of rectangle.
             * @return {string} In the form (50, 73 - 75w x 25h).
             * @override
             */
            Rect.prototype.toString = function () {
                return '(' + this.left + ', ' + this.top + ' - ' + this.width + 'w x ' +
                    this.height + 'h)';
            };
            ;
            // }
            /**
             * Computes the intersection of this rectangle and the rectangle parameter.  If
             * there is no intersection, returns false and leaves this rectangle as is.
             * @param {goog.math.IRect} rect A Rectangle.
             * @return {boolean} True iff this rectangle intersects with the parameter.
             */
            Rect.prototype.intersection = function (rect) {
                var x0 = Math.max(this.left, rect.left);
                var x1 = Math.min(this.left + this.width, rect.left + rect.width);
                if (x0 <= x1) {
                    var y0 = Math.max(this.top, rect.top);
                    var y1 = Math.min(this.top + this.height, rect.top + rect.height);
                    if (y0 <= y1) {
                        this.left = x0;
                        this.top = y0;
                        this.width = x1 - x0;
                        this.height = y1 - y0;
                        return true;
                    }
                }
                return false;
            };
            ;
            /**
             * Returns whether a rectangle intersects this rectangle.
             * @param {goog.math.IRect} rect A rectangle.
             * @return {boolean} Whether rect intersects this rectangle.
             */
            Rect.prototype.intersects = function (rect) {
                return goog.math.Rect.intersects(this, rect);
            };
            ;
            /**
             * Computes the difference regions between this rectangle and {@code rect}. The
             * return value is an array of 0 to 4 rectangles defining the remaining regions
             * of this rectangle after the other has been subtracted.
             * @param {goog.math.IRect} rect A Rectangle.
             * @return {!Array<!goog.math.Rect>} An array with 0 to 4 rectangles which
             *     together define the difference area of rectangle a minus rectangle b.
             */
            Rect.prototype.difference = function (rect) {
                return goog.math.Rect.difference(this, rect);
            };
            ;
            /**
             * Expand this rectangle to also include the area of the given rectangle.
             * @param {goog.math.IRect} rect The other rectangle.
             */
            Rect.prototype.boundingRect = function (rect) {
                // We compute right and bottom before we change left and top below.
                var right = Math.max(this.left + this.width, rect.left + rect.width);
                var bottom = Math.max(this.top + this.height, rect.top + rect.height);
                this.left = Math.min(this.left, rect.left);
                this.top = Math.min(this.top, rect.top);
                this.width = right - this.left;
                this.height = bottom - this.top;
            };
            ;
            /**
             * Tests whether this rectangle entirely contains another rectangle or
             * coordinate.
             *
             * @param {goog.math.IRect|goog.math.Coordinate} another The rectangle or
             *     coordinate to test for containment.
             * @return {boolean} Whether this rectangle contains given rectangle or
             *     coordinate.
             */
            Rect.prototype.contains = function (another) {
                if (another instanceof goog.math.Coordinate) {
                    return another.x >= this.left && another.x <= this.left + this.width &&
                        another.y >= this.top && another.y <= this.top + this.height;
                }
                else {
                    return this.left <= another.left &&
                        this.left + this.width >= another.left + another.width &&
                        this.top <= another.top &&
                        this.top + this.height >= another.top + another.height;
                }
            };
            ;
            /**
             * @param {!goog.math.Coordinate} point A coordinate.
             * @return {number} The squared distance between the point and the closest
             *     point inside the rectangle. Returns 0 if the point is inside the
             *     rectangle.
             */
            Rect.prototype.squaredDistance = function (point) {
                var dx = point.x < this.left ?
                    this.left - point.x :
                    Math.max(point.x - (this.left + this.width), 0);
                var dy = point.y < this.top ? this.top - point.y :
                    Math.max(point.y - (this.top + this.height), 0);
                return dx * dx + dy * dy;
            };
            ;
            /**
             * @param {!goog.math.Coordinate} point A coordinate.
             * @return {number} The distance between the point and the closest point
             *     inside the rectangle. Returns 0 if the point is inside the rectangle.
             */
            Rect.prototype.distance = function (point) {
                return Math.sqrt(this.squaredDistance(point));
            };
            ;
            /**
             * @return {!goog.math.Size} The size of this rectangle.
             */
            Rect.prototype.getSize = function () {
                return new goog.math.Size(this.width, this.height);
            };
            ;
            /**
             * @return {!goog.math.Coordinate} A new coordinate for the top-left corner of
             *     the rectangle.
             */
            Rect.prototype.getTopLeft = function () {
                return new goog.math.Coordinate(this.left, this.top);
            };
            ;
            /**
             * @return {!goog.math.Coordinate} A new coordinate for the center of the
             *     rectangle.
             */
            Rect.prototype.getCenter = function () {
                return new goog.math.Coordinate(this.left + this.width / 2, this.top + this.height / 2);
            };
            ;
            /**
             * @return {!goog.math.Coordinate} A new coordinate for the bottom-right corner
             *     of the rectangle.
             */
            Rect.prototype.getBottomRight = function () {
                return new goog.math.Coordinate(this.left + this.width, this.top + this.height);
            };
            ;
            /**
             * Rounds the fields to the next larger integer values.
             * @return {!goog.math.Rect} This rectangle with ceil'd fields.
             */
            Rect.prototype.ceil = function () {
                this.left = Math.ceil(this.left);
                this.top = Math.ceil(this.top);
                this.width = Math.ceil(this.width);
                this.height = Math.ceil(this.height);
                return this;
            };
            ;
            /**
             * Rounds the fields to the next smaller integer values.
             * @return {!goog.math.Rect} This rectangle with floored fields.
             */
            Rect.prototype.floor = function () {
                this.left = Math.floor(this.left);
                this.top = Math.floor(this.top);
                this.width = Math.floor(this.width);
                this.height = Math.floor(this.height);
                return this;
            };
            ;
            /**
             * Rounds the fields to nearest integer values.
             * @return {!goog.math.Rect} This rectangle with rounded fields.
             */
            Rect.prototype.round = function () {
                this.left = Math.round(this.left);
                this.top = Math.round(this.top);
                this.width = Math.round(this.width);
                this.height = Math.round(this.height);
                return this;
            };
            ;
            /**
             * Translates this rectangle by the given offsets. If a
             * {@code goog.math.Coordinate} is given, then the left and top values are
             * translated by the coordinate's x and y values. Otherwise, top and left are
             * translated by {@code tx} and {@code opt_ty} respectively.
             * @param {number|goog.math.Coordinate} tx The value to translate left by or the
             *     the coordinate to translate this rect by.
             * @param {number=} opt_ty The value to translate top by.
             * @return {!goog.math.Rect} This rectangle after translating.
             */
            Rect.prototype.translate = function (tx, opt_ty) {
                if (tx instanceof goog.math.Coordinate) {
                    this.left += tx.x;
                    this.top += tx.y;
                }
                else {
                    this.left += goog.asserts.assertNumber(tx);
                    if (goog.isNumber(opt_ty)) {
                        this.top += opt_ty;
                    }
                }
                return this;
            };
            ;
            /**
             * Scales this rectangle by the given scale factors. The left and width values
             * are scaled by {@code sx} and the top and height values are scaled by
             * {@code opt_sy}.  If {@code opt_sy} is not given, then all fields are scaled
             * by {@code sx}.
             * @param {number} sx The scale factor to use for the x dimension.
             * @param {number=} opt_sy The scale factor to use for the y dimension.
             * @return {!goog.math.Rect} This rectangle after scaling.
             */
            Rect.prototype.scale = function (sx, opt_sy) {
                var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
                this.left *= sx;
                this.width *= sx;
                this.top *= sy;
                this.height *= sy;
                return this;
            };
            ;
            return Rect;
        }());
        math.Rect = Rect;
    })(math = goog.math || (goog.math = {}));
})(goog || (goog = {}));
(function (goog) {
    var math;
    (function (math) {
        var Rect;
        (function (Rect) {
            /**
             * Creates a new Rect object with the position and size given.
             * @param {!goog.math.Coordinate} position The top-left coordinate of the Rect
             * @param {!goog.math.Size} size The size of the Rect
             * @return {!goog.math.Rect} A new Rect initialized with the given position and
             *     size.
             */
            function createFromPositionAndSize(position, size) {
                return new goog.math.Rect(position.x, position.y, size.width, size.height);
            }
            Rect.createFromPositionAndSize = createFromPositionAndSize;
            ;
            /**
             * Creates a new Rect object with the same position and dimensions as a given
             * Box.  Note that this is only the inverse of toBox if left/top are defined.
             * @param {goog.math.Box} box A box.
             * @return {!goog.math.Rect} A new Rect initialized with the box's position
             *     and size.
             */
            function createFromBox(box) {
                return new goog.math.Rect(box.left, box.top, box.right - box.left, box.bottom - box.top);
            }
            Rect.createFromBox = createFromBox;
            ;
            /**
             * Compares rectangles for equality.
             * @param {goog.math.IRect} a A Rectangle.
             * @param {goog.math.IRect} b A Rectangle.
             * @return {boolean} True iff the rectangles have the same left, top, width,
             *     and height, or if both are null.
             */
            function equals(a, b) {
                if (a == b) {
                    return true;
                }
                if (!a || !b) {
                    return false;
                }
                return a.left == b.left && a.width == b.width && a.top == b.top &&
                    a.height == b.height;
            }
            Rect.equals = equals;
            ;
            /**
             * Returns the intersection of two rectangles. Two rectangles intersect if they
             * touch at all, for example, two zero width and height rectangles would
             * intersect if they had the same top and left.
             * @param {goog.math.IRect} a A Rectangle.
             * @param {goog.math.IRect} b A Rectangle.
             * @return {goog.math.Rect} A new intersection rect (even if width and height
             *     are 0), or null if there is no intersection.
             */
            function intersection(a, b) {
                // There is no nice way to do intersection via a clone, because any such
                // clone might be unnecessary if this function returns null.  So, we duplicate
                // code from above.
                var x0 = Math.max(a.left, b.left);
                var x1 = Math.min(a.left + a.width, b.left + b.width);
                if (x0 <= x1) {
                    var y0 = Math.max(a.top, b.top);
                    var y1 = Math.min(a.top + a.height, b.top + b.height);
                    if (y0 <= y1) {
                        return new goog.math.Rect(x0, y0, x1 - x0, y1 - y0);
                    }
                }
                return null;
            }
            Rect.intersection = intersection;
            ;
            /**
             * Returns whether two rectangles intersect. Two rectangles intersect if they
             * touch at all, for example, two zero width and height rectangles would
             * intersect if they had the same top and left.
             * @param {goog.math.IRect} a A Rectangle.
             * @param {goog.math.IRect} b A Rectangle.
             * @return {boolean} Whether a and b intersect.
             */
            function intersects(a, b) {
                return (a.left <= b.left + b.width && b.left <= a.left + a.width &&
                    a.top <= b.top + b.height && b.top <= a.top + a.height);
            }
            Rect.intersects = intersects;
            ;
            /**
             * Computes the difference regions between two rectangles. The return value is
             * an array of 0 to 4 rectangles defining the remaining regions of the first
             * rectangle after the second has been subtracted.
             * @param {goog.math.Rect} a A Rectangle.
             * @param {goog.math.IRect} b A Rectangle.
             * @return {!Array<!goog.math.Rect>} An array with 0 to 4 rectangles which
             *     together define the difference area of rectangle a minus rectangle b.
             */
            function difference(a, b) {
                var intersection = goog.math.Rect.intersection(a, b);
                if (!intersection || !intersection.height || !intersection.width) {
                    return [a.clone()];
                }
                var result = [];
                var top = a.top;
                var height = a.height;
                var ar = a.left + a.width;
                var ab = a.top + a.height;
                var br = b.left + b.width;
                var bb = b.top + b.height;
                // Subtract off any area on top where A extends past B
                if (b.top > a.top) {
                    result.push(new goog.math.Rect(a.left, a.top, a.width, b.top - a.top));
                    top = b.top;
                    // If we're moving the top down, we also need to subtract the height diff.
                    height -= b.top - a.top;
                }
                // Subtract off any area on bottom where A extends past B
                if (bb < ab) {
                    result.push(new goog.math.Rect(a.left, bb, a.width, ab - bb));
                    height = bb - top;
                }
                // Subtract any area on left where A extends past B
                if (b.left > a.left) {
                    result.push(new goog.math.Rect(a.left, top, b.left - a.left, height));
                }
                // Subtract any area on right where A extends past B
                if (br < ar) {
                    result.push(new goog.math.Rect(br, top, ar - br, height));
                }
                return result;
            }
            Rect.difference = difference;
            ;
            /**
             * Returns a new rectangle which completely contains both input rectangles.
             * @param {goog.math.IRect} a A rectangle.
             * @param {goog.math.IRect} b A rectangle.
             * @return {goog.math.Rect} A new bounding rect, or null if either rect is
             *     null.
             */
            function boundingRect(a, b) {
                if (!a || !b) {
                    return null;
                }
                var newRect = new goog.math.Rect(a.left, a.top, a.width, a.height);
                newRect.boundingRect(b);
                return newRect;
            }
            Rect.boundingRect = boundingRect;
            ;
        })(Rect = math.Rect || (math.Rect = {}));
    })(math = goog.math || (goog.math = {}));
})(goog || (goog = {}));
/// <reference path="../array/array" />
/// <reference path="../asserts/asserts" />
/// <reference path="../dom/dom" />
/// <reference path="../dom/NodeType" />
/// <reference path="../dom/TagName" />
/// <reference path="../dom/vendor" />
/// <reference path="../html/SafeStyleSheet" />
/// <reference path="../math/Box" />
/// <reference path="../math/Coordinate" />
/// <reference path="../math/Rect" />
/// <reference path="../math/Size" />
/// <reference path="../object/object" />
/// <reference path="../reflect/reflect" />
/// <reference path="../string/string" />
/// <reference path="../userAgent/useragent" />
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utilities for element styles.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author eae@google.com (Emil A Eklund)
 * @see ../demos/inline_block_quirks.html
 * @see ../demos/inline_block_standards.html
 * @see ../demos/style_viewport.html
 */
goog.provide('goog.style');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.vendor');
goog.require('goog.html.SafeStyleSheet');
goog.require('goog.math.Box');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Rect');
goog.require('goog.math.Size');
goog.require('goog.object');
goog.require('goog.reflect');
goog.require('goog.string');
goog.require('goog.userAgent');
goog.forwardDeclare('goog.events.Event');
var goog;
(function (goog) {
    var style;
    (function (style_1) {
        /**
         * Sets a style value on an element.
         *
         * This function is not indended to patch issues in the browser's style
         * handling, but to allow easy programmatic access to setting dash-separated
         * style properties.  An example is setting a batch of properties from a data
         * object without overwriting old styles.  When possible, use native APIs:
         * elem.style.propertyKey = 'value' or (if obliterating old styles is fine)
         * elem.style.cssText = 'property1: value1; property2: value2'.
         *
         * @param {Element} element The element to change.
         * @param {string|Object} style If a string, a style name. If an object, a hash
         *     of style names to style values.
         * @param {string|number|boolean=} opt_value If style was a string, then this
         *     should be the value.
         */
        function setStyle(element, style, opt_value) {
            if (goog.isString(style)) {
                goog.style.setStyle_(element, opt_value, style);
            }
            else {
                for (var key in style) {
                    goog.style.setStyle_(element, style[key], key);
                }
            }
        }
        style_1.setStyle = setStyle;
        ;
        /**
         * Sets a style value on an element, with parameters swapped to work with
         * {@code goog.object.forEach()}. Prepends a vendor-specific prefix when
         * necessary.
         * @param {Element} element The element to change.
         * @param {string|number|boolean|undefined} value Style value.
         * @param {string} style Style name.
         * @private
         */
        function setStyle_(element, value, style) {
            var propertyName = goog.style.getVendorJsStyleName_(element, style);
            if (propertyName) {
                // TODO(johnlenz): coerce to string?
                element.style[propertyName] = /** @type {?} */ (value);
            }
        }
        style_1.setStyle_ = setStyle_;
        ;
        /**
         * Style name cache that stores previous property name lookups.
         *
         * This is used by setStyle to speed up property lookups, entries look like:
         *   { StyleName: ActualPropertyName }
         *
         * @private {!Object<string, string>}
         */
        style_1.styleNameCache_ = {};
        /**
         * Returns the style property name in camel-case. If it does not exist and a
         * vendor-specific version of the property does exist, then return the vendor-
         * specific property name instead.
         * @param {Element} element The element to change.
         * @param {string} style Style name.
         * @return {string} Vendor-specific style.
         * @private
         */
        function getVendorJsStyleName_(element, style) {
            var propertyName = goog.style.styleNameCache_[style];
            if (!propertyName) {
                var camelStyle = goog.string.toCamelCase(style);
                propertyName = camelStyle;
                if (element.style[camelStyle] === undefined) {
                    var prefixedStyle = goog.dom.vendor.getVendorJsPrefix() +
                        goog.string.toTitleCase(camelStyle);
                    if (element.style[prefixedStyle] !== undefined) {
                        propertyName = prefixedStyle;
                    }
                }
                goog.style.styleNameCache_[style] = propertyName;
            }
            return propertyName;
        }
        style_1.getVendorJsStyleName_ = getVendorJsStyleName_;
        ;
        /**
         * Returns the style property name in CSS notation. If it does not exist and a
         * vendor-specific version of the property does exist, then return the vendor-
         * specific property name instead.
         * @param {Element} element The element to change.
         * @param {string} style Style name.
         * @return {string} Vendor-specific style.
         * @private
         */
        function getVendorStyleName_(element, style) {
            var camelStyle = goog.string.toCamelCase(style);
            if (element.style[camelStyle] === undefined) {
                var prefixedStyle = goog.dom.vendor.getVendorJsPrefix() +
                    goog.string.toTitleCase(camelStyle);
                if (element.style[prefixedStyle] !== undefined) {
                    return goog.dom.vendor.getVendorPrefix() + '-' + style;
                }
            }
            return style;
        }
        style_1.getVendorStyleName_ = getVendorStyleName_;
        ;
        /**
         * Retrieves an explicitly-set style value of a node. This returns '' if there
         * isn't a style attribute on the element or if this style property has not been
         * explicitly set in script.
         *
         * @param {Element} element Element to get style of.
         * @param {string} property Property to get, css-style (if you have a camel-case
         * property, use element.style[style]).
         * @return {string} Style value.
         */
        function getStyle(element, property) {
            // element.style is '' for well-known properties which are unset.
            // For for browser specific styles as 'filter' is undefined
            // so we need to return '' explicitly to make it consistent across
            // browsers.
            var styleValue = element.style[goog.string.toCamelCase(property)];
            // Using typeof here because of a bug in Safari 5.1, where this value
            // was undefined, but === undefined returned false.
            if (typeof (styleValue) !== 'undefined') {
                return styleValue;
            }
            return element.style[goog.style.getVendorJsStyleName_(element, property)] ||
                '';
        }
        style_1.getStyle = getStyle;
        ;
        /**
         * Retrieves a computed style value of a node. It returns empty string if the
         * value cannot be computed (which will be the case in Internet Explorer) or
         * "none" if the property requested is an SVG one and it has not been
         * explicitly set (firefox and webkit).
         *
         * @param {Element} element Element to get style of.
         * @param {string} property Property to get (camel-case).
         * @return {string} Style value.
         */
        function getComputedStyle(element, property) {
            var doc = goog.dom.getOwnerDocument(element);
            if (doc.defaultView && doc.defaultView.getComputedStyle) {
                var styles = doc.defaultView.getComputedStyle(element, null);
                if (styles) {
                    // element.style[..] is undefined for browser specific styles
                    // as 'filter'.
                    return styles[property] || styles.getPropertyValue(property) || '';
                }
            }
            return '';
        }
        style_1.getComputedStyle = getComputedStyle;
        ;
        /**
         * Gets the cascaded style value of a node, or null if the value cannot be
         * computed (only Internet Explorer can do this).
         *
         * @param {Element} element Element to get style of.
         * @param {string} style Property to get (camel-case).
         * @return {string} Style value.
         */
        function getCascadedStyle(element, style) {
            // TODO(nicksantos): This should be documented to return null. #fixTypes
            return /** @type {string} */ (element.currentStyle ? element.currentStyle[style] : null);
        }
        style_1.getCascadedStyle = getCascadedStyle;
        ;
        /**
         * Cross-browser pseudo get computed style. It returns the computed style where
         * available. If not available it tries the cascaded style value (IE
         * currentStyle) and in worst case the inline style value.  It shouldn't be
         * called directly, see http://wiki/Main/ComputedStyleVsCascadedStyle for
         * discussion.
         *
         * @param {Element} element Element to get style of.
         * @param {string} style Property to get (must be camelCase, not css-style.).
         * @return {string} Style value.
         * @private
         */
        function getStyle_(element, style) {
            return goog.style.getComputedStyle(element, style) ||
                goog.style.getCascadedStyle(element, style) ||
                (element.style && element.style[style]);
        }
        style_1.getStyle_ = getStyle_;
        ;
        /**
         * Retrieves the computed value of the box-sizing CSS attribute.
         * Browser support: http://caniuse.com/css3-boxsizing.
         * @param {!Element} element The element whose box-sizing to get.
         * @return {?string} 'content-box', 'border-box' or 'padding-box'. null if
         *     box-sizing is not supported (IE7 and below).
         */
        function getComputedBoxSizing(element) {
            return goog.style.getStyle_(element, 'boxSizing') ||
                goog.style.getStyle_(element, 'MozBoxSizing') ||
                goog.style.getStyle_(element, 'WebkitBoxSizing') || null;
        }
        style_1.getComputedBoxSizing = getComputedBoxSizing;
        ;
        /**
         * Retrieves the computed value of the position CSS attribute.
         * @param {Element} element The element to get the position of.
         * @return {string} Position value.
         */
        function getComputedPosition(element) {
            return goog.style.getStyle_(element, 'position');
        }
        style_1.getComputedPosition = getComputedPosition;
        ;
        /**
         * Retrieves the computed background color string for a given element. The
         * string returned is suitable for assigning to another element's
         * background-color, but is not guaranteed to be in any particular string
         * format. Accessing the color in a numeric form may not be possible in all
         * browsers or with all input.
         *
         * If the background color for the element is defined as a hexadecimal value,
         * the resulting string can be parsed by goog.color.parse in all supported
         * browsers.
         *
         * Whether named colors like "red" or "lightblue" get translated into a
         * format which can be parsed is browser dependent. Calling this function on
         * transparent elements will return "transparent" in most browsers or
         * "rgba(0, 0, 0, 0)" in WebKit.
         * @param {Element} element The element to get the background color of.
         * @return {string} The computed string value of the background color.
         */
        function getBackgroundColor(element) {
            return goog.style.getStyle_(element, 'backgroundColor');
        }
        style_1.getBackgroundColor = getBackgroundColor;
        ;
        /**
         * Retrieves the computed value of the overflow-x CSS attribute.
         * @param {Element} element The element to get the overflow-x of.
         * @return {string} The computed string value of the overflow-x attribute.
         */
        function getComputedOverflowX(element) {
            return goog.style.getStyle_(element, 'overflowX');
        }
        style_1.getComputedOverflowX = getComputedOverflowX;
        ;
        /**
         * Retrieves the computed value of the overflow-y CSS attribute.
         * @param {Element} element The element to get the overflow-y of.
         * @return {string} The computed string value of the overflow-y attribute.
         */
        function getComputedOverflowY(element) {
            return goog.style.getStyle_(element, 'overflowY');
        }
        style_1.getComputedOverflowY = getComputedOverflowY;
        ;
        /**
         * Retrieves the computed value of the z-index CSS attribute.
         * @param {Element} element The element to get the z-index of.
         * @return {string|number} The computed value of the z-index attribute.
         */
        function getComputedZIndex(element) {
            return goog.style.getStyle_(element, 'zIndex');
        }
        style_1.getComputedZIndex = getComputedZIndex;
        ;
        /**
         * Retrieves the computed value of the text-align CSS attribute.
         * @param {Element} element The element to get the text-align of.
         * @return {string} The computed string value of the text-align attribute.
         */
        function getComputedTextAlign(element) {
            return goog.style.getStyle_(element, 'textAlign');
        }
        style_1.getComputedTextAlign = getComputedTextAlign;
        ;
        /**
         * Retrieves the computed value of the cursor CSS attribute.
         * @param {Element} element The element to get the cursor of.
         * @return {string} The computed string value of the cursor attribute.
         */
        function getComputedCursor(element) {
            return goog.style.getStyle_(element, 'cursor');
        }
        style_1.getComputedCursor = getComputedCursor;
        ;
        /**
         * Retrieves the computed value of the CSS transform attribute.
         * @param {Element} element The element to get the transform of.
         * @return {string} The computed string representation of the transform matrix.
         */
        function getComputedTransform(element) {
            var property = goog.style.getVendorStyleName_(element, 'transform');
            return goog.style.getStyle_(element, property) ||
                goog.style.getStyle_(element, 'transform');
        }
        style_1.getComputedTransform = getComputedTransform;
        ;
        /**
         * Sets the top/left values of an element.  If no unit is specified in the
         * argument then it will add px. The second argument is required if the first
         * argument is a string or number and is ignored if the first argument
         * is a coordinate.
         * @param {Element} el Element to move.
         * @param {string|number|goog.math.Coordinate} arg1 Left position or coordinate.
         * @param {string|number=} opt_arg2 Top position.
         */
        function setPosition(el, arg1, opt_arg2) {
            var x, y;
            if (arg1 instanceof goog.math.Coordinate) {
                x = arg1.x;
                y = arg1.y;
            }
            else {
                x = arg1;
                y = opt_arg2;
            }
            el.style.left = goog.style.getPixelStyleValue_(
            /** @type {number|string} */ (x), false);
            el.style.top = goog.style.getPixelStyleValue_(
            /** @type {number|string} */ (y), false);
        }
        style_1.setPosition = setPosition;
        ;
        /**
         * Gets the offsetLeft and offsetTop properties of an element and returns them
         * in a Coordinate object
         * @param {Element} element Element.
         * @return {!goog.math.Coordinate} The position.
         */
        function getPosition(element) {
            return new goog.math.Coordinate(
            /** @type {!HTMLElement} */ (element).offsetLeft, 
            /** @type {!HTMLElement} */ (element).offsetTop);
        }
        style_1.getPosition = getPosition;
        ;
        /**
         * Returns the viewport element for a particular document
         * @param {Node=} opt_node DOM node (Document is OK) to get the viewport element
         *     of.
         * @return {Element} document.documentElement or document.body.
         */
        function getClientViewportElement(opt_node) {
            var doc;
            if (opt_node) {
                doc = goog.dom.getOwnerDocument(opt_node);
            }
            else {
                doc = goog.dom.getDocument();
            }
            // In old IE versions the document.body represented the viewport
            if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9) &&
                !goog.dom.getDomHelper(doc).isCss1CompatMode()) {
                return doc.body;
            }
            return doc.documentElement;
        }
        style_1.getClientViewportElement = getClientViewportElement;
        ;
        /**
         * Calculates the viewport coordinates relative to the page/document
         * containing the node. The viewport may be the browser viewport for
         * non-iframe document, or the iframe container for iframe'd document.
         * @param {!Document} doc The document to use as the reference point.
         * @return {!goog.math.Coordinate} The page offset of the viewport.
         */
        function getViewportPageOffset(doc) {
            var body = doc.body;
            var documentElement = doc.documentElement;
            var scrollLeft = body.scrollLeft || documentElement.scrollLeft;
            var scrollTop = body.scrollTop || documentElement.scrollTop;
            return new goog.math.Coordinate(scrollLeft, scrollTop);
        }
        style_1.getViewportPageOffset = getViewportPageOffset;
        ;
        /**
         * Gets the client rectangle of the DOM element.
         *
         * getBoundingClientRect is part of a new CSS object model draft (with a
         * long-time presence in IE), replacing the error-prone parent offset
         * computation and the now-deprecated Gecko getBoxObjectFor.
         *
         * This utility patches common browser bugs in getBoundingClientRect. It
         * will fail if getBoundingClientRect is unsupported.
         *
         * If the element is not in the DOM, the result is undefined, and an error may
         * be thrown depending on user agent.
         *
         * @param {!Element} el The element whose bounding rectangle is being queried.
         * @return {Object} A native bounding rectangle with numerical left, top,
         *     right, and bottom.  Reported by Firefox to be of object type ClientRect.
         * @private
         */
        function getBoundingClientRect_(el) {
            var rect;
            try {
                rect = el.getBoundingClientRect();
            }
            catch (e) {
                // In IE < 9, calling getBoundingClientRect on an orphan element raises an
                // "Unspecified Error". All other browsers return zeros.
                return { 'left': 0, 'top': 0, 'right': 0, 'bottom': 0 };
            }
            // Patch the result in IE only, so that this function can be inlined if
            // compiled for non-IE.
            if (goog.userAgent.IE && el.ownerDocument.body) {
                // In IE, most of the time, 2 extra pixels are added to the top and left
                // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
                // IE6 standards mode, this border can be overridden by setting the
                // document element's border to zero -- thus, we cannot rely on the
                // offset always being 2 pixels.
                // In quirks mode, the offset can be determined by querying the body's
                // clientLeft/clientTop, but in standards mode, it is found by querying
                // the document element's clientLeft/clientTop.  Since we already called
                // getBoundingClientRect we have already forced a reflow, so it is not
                // too expensive just to query them all.
                // See: http://msdn.microsoft.com/en-us/library/ms536433(VS.85).aspx
                var doc = el.ownerDocument;
                rect.left -= doc.documentElement.clientLeft + doc.body.clientLeft;
                rect.top -= doc.documentElement.clientTop + doc.body.clientTop;
            }
            return rect;
        }
        style_1.getBoundingClientRect_ = getBoundingClientRect_;
        ;
        /**
         * Returns the first parent that could affect the position of a given element.
         * @param {Element} element The element to get the offset parent for.
         * @return {Element} The first offset parent or null if one cannot be found.
         */
        function getOffsetParent(element) {
            // element.offsetParent does the right thing in IE7 and below.  In other
            // browsers it only includes elements with position absolute, relative or
            // fixed, not elements with overflow set to auto or scroll.
            if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(8)) {
                goog.asserts.assert(element && 'offsetParent' in element);
                return element.offsetParent;
            }
            var doc = goog.dom.getOwnerDocument(element);
            var positionStyle = goog.style.getStyle_(element, 'position');
            var skipStatic = positionStyle == 'fixed' || positionStyle == 'absolute';
            for (var parent = element.parentNode; parent && parent != doc; parent = parent.parentNode) {
                // Skip shadowDOM roots.
                if (parent.nodeType == goog.dom.NodeType.DOCUMENT_FRAGMENT && parent.host) {
                    // Cast because the assignment is not type safe, and without a cast we
                    // start typing parent loosely and get bad disambiguation.
                    parent = /** @type {!Element} */ (parent.host);
                }
                positionStyle =
                    goog.style.getStyle_(/** @type {!Element} */ (parent), 'position');
                skipStatic = skipStatic && positionStyle == 'static' &&
                    parent != doc.documentElement && parent != doc.body;
                if (!skipStatic &&
                    (parent.scrollWidth > parent.clientWidth ||
                        parent.scrollHeight > parent.clientHeight ||
                        positionStyle == 'fixed' || positionStyle == 'absolute' ||
                        positionStyle == 'relative')) {
                    return /** @type {!Element} */ (parent);
                }
            }
            return null;
        }
        style_1.getOffsetParent = getOffsetParent;
        ;
        /**
         * Calculates and returns the visible rectangle for a given element. Returns a
         * box describing the visible portion of the nearest scrollable offset ancestor.
         * Coordinates are given relative to the document.
         *
         * @param {Element} element Element to get the visible rect for.
         * @return {goog.math.Box} Bounding elementBox describing the visible rect or
         *     null if scrollable ancestor isn't inside the visible viewport.
         */
        function getVisibleRectForElement(element) {
            var visibleRect = new goog.math.Box(0, Infinity, Infinity, 0);
            var dom = goog.dom.getDomHelper(element);
            var body = dom.getDocument().body;
            var documentElement = dom.getDocument().documentElement;
            var scrollEl = dom.getDocumentScrollElement();
            // Determine the size of the visible rect by climbing the dom accounting for
            // all scrollable containers.
            for (var el = element; el = goog.style.getOffsetParent(el);) {
                // clientWidth is zero for inline block elements in IE.
                // on WEBKIT, body element can have clientHeight = 0 and scrollHeight > 0
                if ((!goog.userAgent.IE || el.clientWidth != 0) &&
                    (!goog.userAgent.WEBKIT || el.clientHeight != 0 || el != body) &&
                    // body may have overflow set on it, yet we still get the entire
                    // viewport. In some browsers, el.offsetParent may be
                    // document.documentElement, so check for that too.
                    (el != body && el != documentElement &&
                        goog.style.getStyle_(el, 'overflow') != 'visible')) {
                    var pos = goog.style.getPageOffset(el);
                    var client = goog.style.getClientLeftTop(el);
                    pos.x += client.x;
                    pos.y += client.y;
                    visibleRect.top = Math.max(visibleRect.top, pos.y);
                    visibleRect.right = Math.min(visibleRect.right, pos.x + el.clientWidth);
                    visibleRect.bottom =
                        Math.min(visibleRect.bottom, pos.y + el.clientHeight);
                    visibleRect.left = Math.max(visibleRect.left, pos.x);
                }
            }
            // Clip by window's viewport.
            var scrollX = scrollEl.scrollLeft, scrollY = scrollEl.scrollTop;
            visibleRect.left = Math.max(visibleRect.left, scrollX);
            visibleRect.top = Math.max(visibleRect.top, scrollY);
            var winSize = dom.getViewportSize();
            visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
            visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
            return visibleRect.top >= 0 && visibleRect.left >= 0 &&
                visibleRect.bottom > visibleRect.top &&
                visibleRect.right > visibleRect.left ?
                visibleRect :
                null;
        }
        style_1.getVisibleRectForElement = getVisibleRectForElement;
        ;
        /**
         * Calculate the scroll position of {@code container} with the minimum amount so
         * that the content and the borders of the given {@code element} become visible.
         * If the element is bigger than the container, its top left corner will be
         * aligned as close to the container's top left corner as possible.
         *
         * @param {Element} element The element to make visible.
         * @param {Element=} opt_container The container to scroll. If not set, then the
         *     document scroll element will be used.
         * @param {boolean=} opt_center Whether to center the element in the container.
         *     Defaults to false.
         * @return {!goog.math.Coordinate} The new scroll position of the container,
         *     in form of goog.math.Coordinate(scrollLeft, scrollTop).
         */
        function getContainerOffsetToScrollInto(element, opt_container, opt_center) {
            var container = opt_container || goog.dom.getDocumentScrollElement();
            // Absolute position of the element's border's top left corner.
            var elementPos = goog.style.getPageOffset(element);
            // Absolute position of the container's border's top left corner.
            var containerPos = goog.style.getPageOffset(container);
            var containerBorder = goog.style.getBorderBox(container);
            if (container == goog.dom.getDocumentScrollElement()) {
                // The element position is calculated based on the page offset, and the
                // document scroll element holds the scroll position within the page. We can
                // use the scroll position to calculate the relative position from the
                // element.
                var relX = elementPos.x - container.scrollLeft;
                var relY = elementPos.y - container.scrollTop;
                if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(10)) {
                    // In older versions of IE getPageOffset(element) does not include the
                    // container border so it has to be added to accommodate.
                    relX += containerBorder.left;
                    relY += containerBorder.top;
                }
            }
            else {
                // Relative pos. of the element's border box to the container's content box.
                var relX = elementPos.x - containerPos.x - containerBorder.left;
                var relY = elementPos.y - containerPos.y - containerBorder.top;
            }
            // How much the element can move in the container, i.e. the difference between
            // the element's bottom-right-most and top-left-most position where it's
            // fully visible.
            var elementSize = goog.style.getSizeWithDisplay_(element);
            var spaceX = container.clientWidth - elementSize.width;
            var spaceY = container.clientHeight - elementSize.height;
            var scrollLeft = container.scrollLeft;
            var scrollTop = container.scrollTop;
            if (opt_center) {
                // All browsers round non-integer scroll positions down.
                scrollLeft += relX - spaceX / 2;
                scrollTop += relY - spaceY / 2;
            }
            else {
                // This formula was designed to give the correct scroll values in the
                // following cases:
                // - element is higher than container (spaceY < 0) => scroll down by relY
                // - element is not higher that container (spaceY >= 0):
                //   - it is above container (relY < 0) => scroll up by abs(relY)
                //   - it is below container (relY > spaceY) => scroll down by relY - spaceY
                //   - it is in the container => don't scroll
                scrollLeft += Math.min(relX, Math.max(relX - spaceX, 0));
                scrollTop += Math.min(relY, Math.max(relY - spaceY, 0));
            }
            return new goog.math.Coordinate(scrollLeft, scrollTop);
        }
        style_1.getContainerOffsetToScrollInto = getContainerOffsetToScrollInto;
        ;
        /**
         * Changes the scroll position of {@code container} with the minimum amount so
         * that the content and the borders of the given {@code element} become visible.
         * If the element is bigger than the container, its top left corner will be
         * aligned as close to the container's top left corner as possible.
         *
         * @param {Element} element The element to make visible.
         * @param {Element=} opt_container The container to scroll. If not set, then the
         *     document scroll element will be used.
         * @param {boolean=} opt_center Whether to center the element in the container.
         *     Defaults to false.
         */
        function scrollIntoContainerView(element, opt_container, opt_center) {
            var container = opt_container || goog.dom.getDocumentScrollElement();
            var offset = goog.style.getContainerOffsetToScrollInto(element, container, opt_center);
            container.scrollLeft = offset.x;
            container.scrollTop = offset.y;
        }
        style_1.scrollIntoContainerView = scrollIntoContainerView;
        ;
        /**
         * Returns clientLeft (width of the left border and, if the directionality is
         * right to left, the vertical scrollbar) and clientTop as a coordinate object.
         *
         * @param {Element} el Element to get clientLeft for.
         * @return {!goog.math.Coordinate} Client left and top.
         */
        function getClientLeftTop(el) {
            return new goog.math.Coordinate(el.clientLeft, el.clientTop);
        }
        style_1.getClientLeftTop = getClientLeftTop;
        ;
        /**
         * Returns a Coordinate object relative to the top-left of the HTML document.
         * Implemented as a single function to save having to do two recursive loops in
         * opera and safari just to get both coordinates.  If you just want one value do
         * use goog.style.getPageOffsetLeft() and goog.style.getPageOffsetTop(), but
         * note if you call both those methods the tree will be analysed twice.
         *
         * @param {Element} el Element to get the page offset for.
         * @return {!goog.math.Coordinate} The page offset.
         */
        function getPageOffset(el) {
            var doc = goog.dom.getOwnerDocument(el);
            // TODO(gboyer): Update the jsdoc in a way that doesn't break the universe.
            goog.asserts.assertObject(el, 'Parameter is required');
            // NOTE(arv): If element is hidden (display none or disconnected or any the
            // ancestors are hidden) we get (0,0) by default but we still do the
            // accumulation of scroll position.
            // TODO(arv): Should we check if the node is disconnected and in that case
            //            return (0,0)?
            var pos = new goog.math.Coordinate(0, 0);
            var viewportElement = goog.style.getClientViewportElement(doc);
            if (el == viewportElement) {
                // viewport is always at 0,0 as that defined the coordinate system for this
                // function - this avoids special case checks in the code below
                return pos;
            }
            var box = goog.style.getBoundingClientRect_(el);
            // Must add the scroll coordinates in to get the absolute page offset
            // of element since getBoundingClientRect returns relative coordinates to
            // the viewport.
            var scrollCoord = goog.dom.getDomHelper(doc).getDocumentScroll();
            pos.x = box.left + scrollCoord.x;
            pos.y = box.top + scrollCoord.y;
            return pos;
        }
        style_1.getPageOffset = getPageOffset;
        ;
        /**
         * Returns the left coordinate of an element relative to the HTML document
         * @param {Element} el Elements.
         * @return {number} The left coordinate.
         */
        function getPageOffsetLeft(el) {
            return goog.style.getPageOffset(el).x;
        }
        style_1.getPageOffsetLeft = getPageOffsetLeft;
        ;
        /**
         * Returns the top coordinate of an element relative to the HTML document
         * @param {Element} el Elements.
         * @return {number} The top coordinate.
         */
        function getPageOffsetTop(el) {
            return goog.style.getPageOffset(el).y;
        }
        style_1.getPageOffsetTop = getPageOffsetTop;
        ;
        /**
         * Returns a Coordinate object relative to the top-left of an HTML document
         * in an ancestor frame of this element. Used for measuring the position of
         * an element inside a frame relative to a containing frame.
         *
         * @param {Element} el Element to get the page offset for.
         * @param {Window} relativeWin The window to measure relative to. If relativeWin
         *     is not in the ancestor frame chain of the element, we measure relative to
         *     the top-most window.
         * @return {!goog.math.Coordinate} The page offset.
         */
        function getFramedPageOffset(el, relativeWin) {
            var position = new goog.math.Coordinate(0, 0);
            // Iterate up the ancestor frame chain, keeping track of the current window
            // and the current element in that window.
            var currentWin = goog.dom.getWindow(goog.dom.getOwnerDocument(el));
            // MS Edge throws when accessing "parent" if el's containing iframe has been
            // deleted.
            if (!goog.reflect.canAccessProperty(currentWin, 'parent')) {
                return position;
            }
            var currentEl = el;
            do {
                // if we're at the top window, we want to get the page offset.
                // if we're at an inner frame, we only want to get the window position
                // so that we can determine the actual page offset in the context of
                // the outer window.
                var offset = currentWin == relativeWin ?
                    goog.style.getPageOffset(currentEl) :
                    goog.style.getClientPositionForElement_(goog.asserts.assert(currentEl));
                position.x += offset.x;
                position.y += offset.y;
            } while (currentWin && currentWin != relativeWin &&
                currentWin != currentWin.parent &&
                (currentEl = currentWin.frameElement) &&
                (currentWin = currentWin.parent));
            return position;
        }
        style_1.getFramedPageOffset = getFramedPageOffset;
        ;
        /**
         * Translates the specified rect relative to origBase page, for newBase page.
         * If origBase and newBase are the same, this function does nothing.
         *
         * @param {goog.math.Rect} rect The source rectangle relative to origBase page,
         *     and it will have the translated result.
         * @param {goog.dom.DomHelper} origBase The DomHelper for the input rectangle.
         * @param {goog.dom.DomHelper} newBase The DomHelper for the resultant
         *     coordinate.  This must be a DOM for an ancestor frame of origBase
         *     or the same as origBase.
         */
        function translateRectForAnotherFrame(rect, origBase, newBase) {
            if (origBase.getDocument() != newBase.getDocument()) {
                var body = origBase.getDocument().body;
                var pos = goog.style.getFramedPageOffset(body, newBase.getWindow());
                // Adjust Body's margin.
                pos = goog.math.Coordinate.difference(pos, goog.style.getPageOffset(body));
                if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9) &&
                    !origBase.isCss1CompatMode()) {
                    pos = goog.math.Coordinate.difference(pos, origBase.getDocumentScroll());
                }
                rect.left += pos.x;
                rect.top += pos.y;
            }
        }
        style_1.translateRectForAnotherFrame = translateRectForAnotherFrame;
        ;
        /**
         * Returns the position of an element relative to another element in the
         * document.  A relative to B
         * @param {Element|Event|goog.events.Event} a Element or mouse event whose
         *     position we're calculating.
         * @param {Element|Event|goog.events.Event} b Element or mouse event position
         *     is relative to.
         * @return {!goog.math.Coordinate} The relative position.
         */
        function getRelativePosition(a, b) {
            var ap = goog.style.getClientPosition(a);
            var bp = goog.style.getClientPosition(b);
            return new goog.math.Coordinate(ap.x - bp.x, ap.y - bp.y);
        }
        style_1.getRelativePosition = getRelativePosition;
        ;
        /**
         * Returns the position of the event or the element's border box relative to
         * the client viewport.
         * @param {!Element} el Element whose position to get.
         * @return {!goog.math.Coordinate} The position.
         * @private
         */
        function getClientPositionForElement_(el) {
            var box = goog.style.getBoundingClientRect_(el);
            return new goog.math.Coordinate(box.left, box.top);
        }
        style_1.getClientPositionForElement_ = getClientPositionForElement_;
        ;
        /**
         * Returns the position of the event or the element's border box relative to
         * the client viewport. If an event is passed, and if this event is a "touch"
         * event, then the position of the first changedTouches will be returned.
         * @param {Element|Event|goog.events.Event} el Element or a mouse / touch event.
         * @return {!goog.math.Coordinate} The position.
         */
        function getClientPosition(el) {
            goog.asserts.assert(el);
            if (el.nodeType == goog.dom.NodeType.ELEMENT) {
                return goog.style.getClientPositionForElement_(
                /** @type {!Element} */ (el));
            }
            else {
                var targetEvent = el.changedTouches ? el.changedTouches[0] : el;
                return new goog.math.Coordinate(targetEvent.clientX, targetEvent.clientY);
            }
        }
        style_1.getClientPosition = getClientPosition;
        ;
        /**
         * Moves an element to the given coordinates relative to the client viewport.
         * @param {Element} el Absolutely positioned element to set page offset for.
         *     It must be in the document.
         * @param {number|goog.math.Coordinate} x Left position of the element's margin
         *     box or a coordinate object.
         * @param {number=} opt_y Top position of the element's margin box.
         */
        function setPageOffset(el, x, opt_y) {
            // Get current pageoffset
            var cur = goog.style.getPageOffset(el);
            if (x instanceof goog.math.Coordinate) {
                opt_y = x.y;
                x = x.x;
            }
            // NOTE(arv): We cannot allow strings for x and y. We could but that would
            // require us to manually transform between different units
            // Work out deltas
            var dx = goog.asserts.assertNumber(x) - cur.x;
            var dy = Number(opt_y) - cur.y;
            // Set position to current left/top + delta
            goog.style.setPosition(el, /** @type {!HTMLElement} */ (el).offsetLeft + dx, 
            /** @type {!HTMLElement} */ (el).offsetTop + dy);
        }
        style_1.setPageOffset = setPageOffset;
        ;
        /**
         * Sets the width/height values of an element.  If an argument is numeric,
         * or a goog.math.Size is passed, it is assumed to be pixels and will add
         * 'px' after converting it to an integer in string form. (This just sets the
         * CSS width and height properties so it might set content-box or border-box
         * size depending on the box model the browser is using.)
         *
         * @param {Element} element Element to set the size of.
         * @param {string|number|goog.math.Size} w Width of the element, or a
         *     size object.
         * @param {string|number=} opt_h Height of the element. Required if w is not a
         *     size object.
         */
        function setSize(element, w, opt_h) {
            var h;
            if (w instanceof goog.math.Size) {
                h = w.height;
                w = w.width;
            }
            else {
                if (opt_h == undefined) {
                    throw new Error('missing height argument');
                }
                h = opt_h;
            }
            goog.style.setWidth(element, /** @type {string|number} */ (w));
            goog.style.setHeight(element, h);
        }
        style_1.setSize = setSize;
        ;
        /**
         * Helper function to create a string to be set into a pixel-value style
         * property of an element. Can round to the nearest integer value.
         *
         * @param {string|number} value The style value to be used. If a number,
         *     'px' will be appended, otherwise the value will be applied directly.
         * @param {boolean} round Whether to round the nearest integer (if property
         *     is a number).
         * @return {string} The string value for the property.
         * @private
         */
        function getPixelStyleValue_(value, round) {
            if (typeof value == 'number') {
                value = (round ? Math.round(value) : value) + 'px';
            }
            return value;
        }
        style_1.getPixelStyleValue_ = getPixelStyleValue_;
        ;
        /**
         * Set the height of an element.  Sets the element's style property.
         * @param {Element} element Element to set the height of.
         * @param {string|number} height The height value to set.  If a number, 'px'
         *     will be appended, otherwise the value will be applied directly.
         */
        function setHeight(element, height) {
            element.style.height = goog.style.getPixelStyleValue_(height, true);
        }
        style_1.setHeight = setHeight;
        ;
        /**
         * Set the width of an element.  Sets the element's style property.
         * @param {Element} element Element to set the width of.
         * @param {string|number} width The width value to set.  If a number, 'px'
         *     will be appended, otherwise the value will be applied directly.
         */
        function setWidth(element, width) {
            element.style.width = goog.style.getPixelStyleValue_(width, true);
        }
        style_1.setWidth = setWidth;
        ;
        /**
         * Gets the height and width of an element, even if its display is none.
         *
         * Specifically, this returns the height and width of the border box,
         * irrespective of the box model in effect.
         *
         * Note that this function does not take CSS transforms into account. Please see
         * {@code goog.style.getTransformedSize}.
         * @param {Element} element Element to get size of.
         * @return {!goog.math.Size} Object with width/height properties.
         */
        function getSize(element) {
            return goog.style.evaluateWithTemporaryDisplay_(goog.style.getSizeWithDisplay_, /** @type {!Element} */ (element));
        }
        style_1.getSize = getSize;
        ;
        /**
         * Call {@code fn} on {@code element} such that {@code element}'s dimensions are
         * accurate when it's passed to {@code fn}.
         * @param {function(!Element): T} fn Function to call with {@code element} as
         *     an argument after temporarily changing {@code element}'s display such
         *     that its dimensions are accurate.
         * @param {!Element} element Element (which may have display none) to use as
         *     argument to {@code fn}.
         * @return {T} Value returned by calling {@code fn} with {@code element}.
         * @template T
         * @private
         */
        function evaluateWithTemporaryDisplay_(fn, element) {
            if (goog.style.getStyle_(element, 'display') != 'none') {
                return fn(element);
            }
            var style = element.style;
            var originalDisplay = style.display;
            var originalVisibility = style.visibility;
            var originalPosition = style.position;
            style.visibility = 'hidden';
            style.position = 'absolute';
            style.display = 'inline';
            var retVal = fn(element);
            style.display = originalDisplay;
            style.position = originalPosition;
            style.visibility = originalVisibility;
            return retVal;
        }
        style_1.evaluateWithTemporaryDisplay_ = evaluateWithTemporaryDisplay_;
        ;
        /**
         * Gets the height and width of an element when the display is not none.
         * @param {Element} element Element to get size of.
         * @return {!goog.math.Size} Object with width/height properties.
         * @private
         */
        function getSizeWithDisplay_(element) {
            var offsetWidth = (element).offsetWidth;
            var offsetHeight = (element).offsetHeight;
            var webkitOffsetsZero = goog.userAgent.WEBKIT && !offsetWidth && !offsetHeight;
            if ((!goog.isDef(offsetWidth) || webkitOffsetsZero) &&
                element.getBoundingClientRect) {
                // Fall back to calling getBoundingClientRect when offsetWidth or
                // offsetHeight are not defined, or when they are zero in WebKit browsers.
                // This makes sure that we return for the correct size for SVG elements, but
                // will still return 0 on Webkit prior to 534.8, see
                // http://trac.webkit.org/changeset/67252.
                var clientRect = goog.style.getBoundingClientRect_(element);
                return new goog.math.Size(clientRect.right - clientRect.left, clientRect.bottom - clientRect.top);
            }
            return new goog.math.Size(offsetWidth, offsetHeight);
        }
        style_1.getSizeWithDisplay_ = getSizeWithDisplay_;
        ;
        /**
         * Gets the height and width of an element, post transform, even if its display
         * is none.
         *
         * This is like {@code goog.style.getSize}, except:
         * <ol>
         * <li>Takes webkitTransforms such as rotate and scale into account.
         * <li>Will return null if {@code element} doesn't respond to
         *     {@code getBoundingClientRect}.
         * <li>Currently doesn't make sense on non-WebKit browsers which don't support
         *    webkitTransforms.
         * </ol>
         * @param {!Element} element Element to get size of.
         * @return {goog.math.Size} Object with width/height properties.
         */
        function getTransformedSize(element) {
            if (!element.getBoundingClientRect) {
                return null;
            }
            var clientRect = goog.style.evaluateWithTemporaryDisplay_(goog.style.getBoundingClientRect_, element);
            return new goog.math.Size(clientRect.right - clientRect.left, clientRect.bottom - clientRect.top);
        }
        style_1.getTransformedSize = getTransformedSize;
        ;
        /**
         * Returns a bounding rectangle for a given element in page space.
         * @param {Element} element Element to get bounds of. Must not be display none.
         * @return {!goog.math.Rect} Bounding rectangle for the element.
         */
        function getBounds(element) {
            var o = goog.style.getPageOffset(element);
            var s = goog.style.getSize(element);
            return new goog.math.Rect(o.x, o.y, s.width, s.height);
        }
        style_1.getBounds = getBounds;
        ;
        /**
         * Converts a CSS selector in the form style-property to styleProperty.
         * @param {*} selector CSS Selector.
         * @return {string} Camel case selector.
         * @deprecated Use goog.string.toCamelCase instead.
         */
        function toCamelCase(selector) {
            return goog.string.toCamelCase(String(selector));
        }
        style_1.toCamelCase = toCamelCase;
        ;
        /**
         * Converts a CSS selector in the form styleProperty to style-property.
         * @param {string} selector Camel case selector.
         * @return {string} Selector cased.
         * @deprecated Use goog.string.toSelectorCase instead.
         */
        function toSelectorCase(selector) {
            return goog.string.toSelectorCase(selector);
        }
        style_1.toSelectorCase = toSelectorCase;
        ;
        /**
         * Gets the opacity of a node (x-browser). This gets the inline style opacity
         * of the node, and does not take into account the cascaded or the computed
         * style for this node.
         * @param {Element} el Element whose opacity has to be found.
         * @return {number|string} Opacity between 0 and 1 or an empty string {@code ''}
         *     if the opacity is not set.
         */
        function getOpacity(el) {
            goog.asserts.assert(el);
            var style = el.style;
            var result = '';
            if ('opacity' in style) {
                result = style.opacity;
            }
            else if ('MozOpacity' in style) {
                result = style.MozOpacity;
            }
            else if ('filter' in style) {
                var match = style.filter.match(/alpha\(opacity=([\d.]+)\)/);
                if (match) {
                    result = String(match[1] / 100);
                }
            }
            return result == '' ? result : Number(result);
        }
        style_1.getOpacity = getOpacity;
        ;
        /**
         * Sets the opacity of a node (x-browser).
         * @param {Element} el Elements whose opacity has to be set.
         * @param {number|string} alpha Opacity between 0 and 1 or an empty string
         *     {@code ''} to clear the opacity.
         */
        function setOpacity(el, alpha) {
            goog.asserts.assert(el);
            var style = el.style;
            if ('opacity' in style) {
                style.opacity = alpha;
            }
            else if ('MozOpacity' in style) {
                style.MozOpacity = alpha;
            }
            else if ('filter' in style) {
                // TODO(arv): Overwriting the filter might have undesired side effects.
                if (alpha === '') {
                    style.filter = '';
                }
                else {
                    style.filter = 'alpha(opacity=' + (Number(alpha) * 100) + ')';
                }
            }
        }
        style_1.setOpacity = setOpacity;
        ;
        /**
         * Sets the background of an element to a transparent image in a browser-
         * independent manner.
         *
         * This function does not support repeating backgrounds or alternate background
         * positions to match the behavior of Internet Explorer. It also does not
         * support sizingMethods other than crop since they cannot be replicated in
         * browsers other than Internet Explorer.
         *
         * @param {Element} el The element to set background on.
         * @param {string} src The image source URL.
         */
        function setTransparentBackgroundImage(el, src) {
            var style = el.style;
            // It is safe to use the style.filter in IE only. In Safari 'filter' is in
            // style object but access to style.filter causes it to throw an exception.
            // Note: IE8 supports images with an alpha channel.
            if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('8')) {
                // See TODO in setOpacity.
                style.filter = 'progid:DXImageTransform.Microsoft.AlphaImageLoader(' +
                    'src="' + src + '", sizingMethod="crop")';
            }
            else {
                // Set style properties individually instead of using background shorthand
                // to prevent overwriting a pre-existing background color.
                style.backgroundImage = 'url(' + src + ')';
                style.backgroundPosition = 'top left';
                style.backgroundRepeat = 'no-repeat';
            }
        }
        style_1.setTransparentBackgroundImage = setTransparentBackgroundImage;
        ;
        /**
         * Clears the background image of an element in a browser independent manner.
         * @param {Element} el The element to clear background image for.
         */
        function clearTransparentBackgroundImage(el) {
            var style = el.style;
            if ('filter' in style) {
                // See TODO in setOpacity.
                style.filter = '';
            }
            else {
                // Set style properties individually instead of using background shorthand
                // to prevent overwriting a pre-existing background color.
                style.backgroundImage = 'none';
            }
        }
        style_1.clearTransparentBackgroundImage = clearTransparentBackgroundImage;
        ;
        /**
         * Shows or hides an element from the page. Hiding the element is done by
         * setting the display property to "none", removing the element from the
         * rendering hierarchy so it takes up no space. To show the element, the default
         * inherited display property is restored (defined either in stylesheets or by
         * the browser's default style rules.)
         *
         * Caveat 1: if the inherited display property for the element is set to "none"
         * by the stylesheets, that is the property that will be restored by a call to
         * showElement(), effectively toggling the display between "none" and "none".
         *
         * Caveat 2: if the element display style is set inline (by setting either
         * element.style.display or a style attribute in the HTML), a call to
         * showElement will clear that setting and defer to the inherited style in the
         * stylesheet.
         * @param {Element} el Element to show or hide.
         * @param {*} display True to render the element in its default style,
         *     false to disable rendering the element.
         * @deprecated Use goog.style.setElementShown instead.
         */
        function showElement(el, display) {
            goog.style.setElementShown(el, display);
        }
        style_1.showElement = showElement;
        ;
        /**
         * Shows or hides an element from the page. Hiding the element is done by
         * setting the display property to "none", removing the element from the
         * rendering hierarchy so it takes up no space. To show the element, the default
         * inherited display property is restored (defined either in stylesheets or by
         * the browser's default style rules).
         *
         * Caveat 1: if the inherited display property for the element is set to "none"
         * by the stylesheets, that is the property that will be restored by a call to
         * setElementShown(), effectively toggling the display between "none" and
         * "none".
         *
         * Caveat 2: if the element display style is set inline (by setting either
         * element.style.display or a style attribute in the HTML), a call to
         * setElementShown will clear that setting and defer to the inherited style in
         * the stylesheet.
         * @param {Element} el Element to show or hide.
         * @param {*} isShown True to render the element in its default style,
         *     false to disable rendering the element.
         */
        function setElementShown(el, isShown) {
            el.style.display = isShown ? '' : 'none';
        }
        style_1.setElementShown = setElementShown;
        ;
        /**
         * Test whether the given element has been shown or hidden via a call to
         * {@link #setElementShown}.
         *
         * Note this is strictly a companion method for a call
         * to {@link #setElementShown} and the same caveats apply; in particular, this
         * method does not guarantee that the return value will be consistent with
         * whether or not the element is actually visible.
         *
         * @param {Element} el The element to test.
         * @return {boolean} Whether the element has been shown.
         * @see #setElementShown
         */
        function isElementShown(el) {
            return el.style.display != 'none';
        }
        style_1.isElementShown = isElementShown;
        ;
        /**
         * Installs the style sheet into the window that contains opt_node.  If
         * opt_node is null, the main window is used.
         * @param {!goog.html.SafeStyleSheet} safeStyleSheet The style sheet to install.
         * @param {?Node=} opt_node Node whose parent document should have the
         *     styles installed.
         * @return {!HTMLStyleElement|!StyleSheet} In IE<11, a StyleSheet object with no
         *     owning <style> tag (this is how IE creates style sheets).  In every other
         *     browser, a <style> element with an attached style.  This doesn't return a
         *     StyleSheet object so that setSafeStyleSheet can replace it (otherwise, if
         *     you pass a StyleSheet to setSafeStyleSheet, it will make a new StyleSheet
         *     and leave the original StyleSheet orphaned).
         */
        function installSafeStyleSheet(safeStyleSheet, opt_node) {
            var dh = goog.dom.getDomHelper(opt_node);
            // IE < 11 requires createStyleSheet. Note that doc.createStyleSheet will be
            // undefined as of IE 11.
            var doc = dh.getDocument();
            if (goog.userAgent.IE && doc.createStyleSheet) {
                var styleSheet = doc.createStyleSheet();
                goog.style.setSafeStyleSheet(styleSheet, safeStyleSheet);
                return styleSheet;
            }
            else {
                var head = dh.getElementsByTagNameAndClass(goog.dom.TagName.HEAD)[0];
                // In opera documents are not guaranteed to have a head element, thus we
                // have to make sure one exists before using it.
                if (!head) {
                    var body = dh.getElementsByTagNameAndClass(goog.dom.TagName.BODY)[0];
                    head = dh.createDom(goog.dom.TagName.HEAD);
                    body.parentNode.insertBefore(head, body);
                }
                var el = dh.createDom(goog.dom.TagName.STYLE);
                // NOTE(user): Setting styles after the style element has been appended
                // to the head results in a nasty Webkit bug in certain scenarios. Please
                // refer to https://bugs.webkit.org/show_bug.cgi?id=26307 for additional
                // details.
                goog.style.setSafeStyleSheet(el, safeStyleSheet);
                dh.appendChild(head, el);
                return el;
            }
        }
        style_1.installSafeStyleSheet = installSafeStyleSheet;
        ;
        /**
         * Removes the styles added by {@link #installStyles}.
         * @param {Element|StyleSheet} styleSheet The value returned by
         *     {@link #installStyles}.
         */
        function uninstallStyles(styleSheet) {
            var node = styleSheet.ownerNode || styleSheet.owningElement ||
                /** @type {Element} */ (styleSheet);
            goog.dom.removeNode(node);
        }
        style_1.uninstallStyles = uninstallStyles;
        ;
        /**
         * Sets the content of a style element.  The style element can be any valid
         * style element.  This element will have its content completely replaced by
         * the safeStyleSheet.
         * @param {!Element|!StyleSheet} element A stylesheet element as returned by
         *     installStyles.
         * @param {!goog.html.SafeStyleSheet} safeStyleSheet The new content of the
         *     stylesheet.
         */
        function setSafeStyleSheet(element, safeStyleSheet) {
            var stylesString = goog.html.SafeStyleSheet.unwrap(safeStyleSheet);
            if (goog.userAgent.IE && goog.isDef(element.cssText)) {
                // Adding the selectors individually caused the browser to hang if the
                // selector was invalid or there were CSS comments.  Setting the cssText of
                // the style node works fine and ignores CSS that IE doesn't understand.
                // However IE >= 11 doesn't support cssText any more, so we make sure that
                // cssText is a defined property and otherwise fall back to innerHTML.
                element.cssText = stylesString;
            }
            else {
                // Setting textContent doesn't work in Safari, see b/29340337.
                element.innerHTML = stylesString;
            }
        }
        style_1.setSafeStyleSheet = setSafeStyleSheet;
        ;
        /**
         * Sets 'white-space: pre-wrap' for a node (x-browser).
         *
         * There are as many ways of specifying pre-wrap as there are browsers.
         *
         * CSS3/IE8: white-space: pre-wrap;
         * Mozilla:  white-space: -moz-pre-wrap;
         * Opera:    white-space: -o-pre-wrap;
         * IE6/7:    white-space: pre; word-wrap: break-word;
         *
         * @param {Element} el Element to enable pre-wrap for.
         */
        function setPreWrap(el) {
            var style = el.style;
            if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('8')) {
                style.whiteSpace = 'pre';
                style.wordWrap = 'break-word';
            }
            else if (goog.userAgent.GECKO) {
                style.whiteSpace = '-moz-pre-wrap';
            }
            else {
                style.whiteSpace = 'pre-wrap';
            }
        }
        style_1.setPreWrap = setPreWrap;
        ;
        /**
         * Sets 'display: inline-block' for an element (cross-browser).
         * @param {Element} el Element to which the inline-block display style is to be
         *    applied.
         * @see ../demos/inline_block_quirks.html
         * @see ../demos/inline_block_standards.html
         */
        function setInlineBlock(el) {
            var style = el.style;
            // Without position:relative, weirdness ensues.  Just accept it and move on.
            style.position = 'relative';
            if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('8')) {
                // IE8 supports inline-block so fall through to the else
                // Zoom:1 forces hasLayout, display:inline gives inline behavior.
                style.zoom = '1';
                style.display = 'inline';
            }
            else {
                // Opera, Webkit, and Safari seem to do OK with the standard inline-block
                // style.
                style.display = 'inline-block';
            }
        }
        style_1.setInlineBlock = setInlineBlock;
        ;
        /**
         * Returns true if the element is using right to left (rtl) direction.
         * @param {Element} el  The element to test.
         * @return {boolean} True for right to left, false for left to right.
         */
        function isRightToLeft(el) {
            return 'rtl' == goog.style.getStyle_(el, 'direction');
        }
        style_1.isRightToLeft = isRightToLeft;
        ;
        /**
         * The CSS style property corresponding to an element being
         * unselectable on the current browser platform (null if none).
         * Opera and IE instead use a DOM attribute 'unselectable'. MS Edge uses
         * the Webkit prefix.
         * @type {?string}
         * @private
         */
        style_1.unselectableStyle_ = goog.userAgent.GECKO ?
            'MozUserSelect' :
            goog.userAgent.WEBKIT || goog.userAgent.EDGE ? 'WebkitUserSelect' : null;
        /**
         * Returns true if the element is set to be unselectable, false otherwise.
         * Note that on some platforms (e.g. Mozilla), even if an element isn't set
         * to be unselectable, it will behave as such if any of its ancestors is
         * unselectable.
         * @param {Element} el  Element to check.
         * @return {boolean}  Whether the element is set to be unselectable.
         */
        function isUnselectable(el) {
            if (goog.style.unselectableStyle_) {
                return el.style[goog.style.unselectableStyle_].toLowerCase() == 'none';
            }
            else if (goog.userAgent.IE || goog.userAgent.OPERA) {
                return el.getAttribute('unselectable') == 'on';
            }
            return false;
        }
        style_1.isUnselectable = isUnselectable;
        ;
        /**
         * Makes the element and its descendants selectable or unselectable.  Note
         * that on some platforms (e.g. Mozilla), even if an element isn't set to
         * be unselectable, it will behave as such if any of its ancestors is
         * unselectable.
         * @param {Element} el  The element to alter.
         * @param {boolean} unselectable  Whether the element and its descendants
         *     should be made unselectable.
         * @param {boolean=} opt_noRecurse  Whether to only alter the element's own
         *     selectable state, and leave its descendants alone; defaults to false.
         */
        function setUnselectable(el, unselectable, opt_noRecurse) {
            // TODO(attila): Do we need all of TR_DomUtil.makeUnselectable() in Closure?
            var descendants = !opt_noRecurse ? el.getElementsByTagName('*') : null;
            var name = goog.style.unselectableStyle_;
            if (name) {
                // Add/remove the appropriate CSS style to/from the element and its
                // descendants.
                var value = unselectable ? 'none' : '';
                // MathML elements do not have a style property. Verify before setting.
                if (el.style) {
                    el.style[name] = value;
                }
                if (descendants) {
                    for (var i = 0, descendant; descendant = descendants[i]; i++) {
                        if (descendant.style) {
                            descendant.style[name] = value;
                        }
                    }
                }
            }
            else if (goog.userAgent.IE || goog.userAgent.OPERA) {
                // Toggle the 'unselectable' attribute on the element and its descendants.
                var value = unselectable ? 'on' : '';
                el.setAttribute('unselectable', value);
                if (descendants) {
                    for (var i = 0, descendant; descendant = descendants[i]; i++) {
                        descendant.setAttribute('unselectable', value);
                    }
                }
            }
        }
        style_1.setUnselectable = setUnselectable;
        ;
        /**
         * Gets the border box size for an element.
         * @param {Element} element  The element to get the size for.
         * @return {!goog.math.Size} The border box size.
         */
        function getBorderBoxSize(element) {
            return new goog.math.Size(
            /** @type {!HTMLElement} */ (element).offsetWidth, 
            /** @type {!HTMLElement} */ (element).offsetHeight);
        }
        style_1.getBorderBoxSize = getBorderBoxSize;
        ;
        /**
         * Sets the border box size of an element. This is potentially expensive in IE
         * if the document is CSS1Compat mode
         * @param {Element} element  The element to set the size on.
         * @param {goog.math.Size} size  The new size.
         */
        function setBorderBoxSize(element, size) {
            var doc = goog.dom.getOwnerDocument(element);
            var isCss1CompatMode = goog.dom.getDomHelper(doc).isCss1CompatMode();
            if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('10') &&
                (!isCss1CompatMode || !goog.userAgent.isVersionOrHigher('8'))) {
                var style = element.style;
                if (isCss1CompatMode) {
                    var paddingBox = goog.style.getPaddingBox(element);
                    var borderBox = goog.style.getBorderBox(element);
                    style.pixelWidth = size.width - borderBox.left - paddingBox.left -
                        paddingBox.right - borderBox.right;
                    style.pixelHeight = size.height - borderBox.top - paddingBox.top -
                        paddingBox.bottom - borderBox.bottom;
                }
                else {
                    style.pixelWidth = size.width;
                    style.pixelHeight = size.height;
                }
            }
            else {
                goog.style.setBoxSizingSize_(element, size, 'border-box');
            }
        }
        style_1.setBorderBoxSize = setBorderBoxSize;
        ;
        /**
         * Gets the content box size for an element.  This is potentially expensive in
         * all browsers.
         * @param {Element} element  The element to get the size for.
         * @return {!goog.math.Size} The content box size.
         */
        function getContentBoxSize(element) {
            var doc = goog.dom.getOwnerDocument(element);
            var ieCurrentStyle = goog.userAgent.IE && element.currentStyle;
            if (ieCurrentStyle && goog.dom.getDomHelper(doc).isCss1CompatMode() &&
                ieCurrentStyle.width != 'auto' && ieCurrentStyle.height != 'auto' &&
                !ieCurrentStyle.boxSizing) {
                // If IE in CSS1Compat mode than just use the width and height.
                // If we have a boxSizing then fall back on measuring the borders etc.
                var width = goog.style.getIePixelValue_(element, /** @type {string} */ (ieCurrentStyle.width), 'width', 'pixelWidth');
                var height = goog.style.getIePixelValue_(element, /** @type {string} */ (ieCurrentStyle.height), 'height', 'pixelHeight');
                return new goog.math.Size(width, height);
            }
            else {
                var borderBoxSize = goog.style.getBorderBoxSize(element);
                var paddingBox = goog.style.getPaddingBox(element);
                var borderBox = goog.style.getBorderBox(element);
                return new goog.math.Size(borderBoxSize.width - borderBox.left - paddingBox.left -
                    paddingBox.right - borderBox.right, borderBoxSize.height - borderBox.top - paddingBox.top -
                    paddingBox.bottom - borderBox.bottom);
            }
        }
        style_1.getContentBoxSize = getContentBoxSize;
        ;
        /**
         * Sets the content box size of an element. This is potentially expensive in IE
         * if the document is BackCompat mode.
         * @param {Element} element  The element to set the size on.
         * @param {goog.math.Size} size  The new size.
         */
        function setContentBoxSize(element, size) {
            var doc = goog.dom.getOwnerDocument(element);
            var isCss1CompatMode = goog.dom.getDomHelper(doc).isCss1CompatMode();
            if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('10') &&
                (!isCss1CompatMode || !goog.userAgent.isVersionOrHigher('8'))) {
                var style = element.style;
                if (isCss1CompatMode) {
                    style.pixelWidth = size.width;
                    style.pixelHeight = size.height;
                }
                else {
                    var paddingBox = goog.style.getPaddingBox(element);
                    var borderBox = goog.style.getBorderBox(element);
                    style.pixelWidth = size.width + borderBox.left + paddingBox.left +
                        paddingBox.right + borderBox.right;
                    style.pixelHeight = size.height + borderBox.top + paddingBox.top +
                        paddingBox.bottom + borderBox.bottom;
                }
            }
            else {
                goog.style.setBoxSizingSize_(element, size, 'content-box');
            }
        }
        style_1.setContentBoxSize = setContentBoxSize;
        ;
        /**
         * Helper function that sets the box sizing as well as the width and height
         * @param {Element} element  The element to set the size on.
         * @param {goog.math.Size} size  The new size to set.
         * @param {string} boxSizing  The box-sizing value.
         * @private
         */
        function setBoxSizingSize_(element, size, boxSizing) {
            var style = element.style;
            if (goog.userAgent.GECKO) {
                style.MozBoxSizing = boxSizing;
            }
            else if (goog.userAgent.WEBKIT) {
                style.WebkitBoxSizing = boxSizing;
            }
            else {
                // Includes IE8 and Opera 9.50+
                style.boxSizing = boxSizing;
            }
            // Setting this to a negative value will throw an exception on IE
            // (and doesn't do anything different than setting it to 0).
            style.width = Math.max(size.width, 0) + 'px';
            style.height = Math.max(size.height, 0) + 'px';
        }
        style_1.setBoxSizingSize_ = setBoxSizingSize_;
        ;
        /**
         * IE specific function that converts a non pixel unit to pixels.
         * @param {Element} element  The element to convert the value for.
         * @param {string} value  The current value as a string. The value must not be
         *     ''.
         * @param {string} name  The CSS property name to use for the converstion. This
         *     should be 'left', 'top', 'width' or 'height'.
         * @param {string} pixelName  The CSS pixel property name to use to get the
         *     value in pixels.
         * @return {number} The value in pixels.
         * @private
         */
        function getIePixelValue_(element, value, name, pixelName) {
            // Try if we already have a pixel value. IE does not do half pixels so we
            // only check if it matches a number followed by 'px'.
            if (/^\d+px?$/.test(value)) {
                return parseInt(value, 10);
            }
            else {
                var oldStyleValue = element.style[name];
                var oldRuntimeValue = element.runtimeStyle[name];
                // set runtime style to prevent changes
                element.runtimeStyle[name] = element.currentStyle[name];
                element.style[name] = value;
                var pixelValue = element.style[pixelName];
                // restore
                element.style[name] = oldStyleValue;
                element.runtimeStyle[name] = oldRuntimeValue;
                return +pixelValue;
            }
        }
        style_1.getIePixelValue_ = getIePixelValue_;
        ;
        /**
         * Helper function for getting the pixel padding or margin for IE.
         * @param {Element} element  The element to get the padding for.
         * @param {string} propName  The property name.
         * @return {number} The pixel padding.
         * @private
         */
        function getIePixelDistance_(element, propName) {
            var value = goog.style.getCascadedStyle(element, propName);
            return value ?
                goog.style.getIePixelValue_(element, value, 'left', 'pixelLeft') :
                0;
        }
        style_1.getIePixelDistance_ = getIePixelDistance_;
        ;
        /**
         * Gets the computed paddings or margins (on all sides) in pixels.
         * @param {Element} element  The element to get the padding for.
         * @param {string} stylePrefix  Pass 'padding' to retrieve the padding box,
         *     or 'margin' to retrieve the margin box.
         * @return {!goog.math.Box} The computed paddings or margins.
         * @private
         */
        function getBox_(element, stylePrefix) {
            if (goog.userAgent.IE) {
                var left = goog.style.getIePixelDistance_(element, stylePrefix + 'Left');
                var right = goog.style.getIePixelDistance_(element, stylePrefix + 'Right');
                var top = goog.style.getIePixelDistance_(element, stylePrefix + 'Top');
                var bottom = goog.style.getIePixelDistance_(element, stylePrefix + 'Bottom');
                return new goog.math.Box(top, right, bottom, left);
            }
            else {
                // On non-IE browsers, getComputedStyle is always non-null.
                var left_1 = goog.style.getComputedStyle(element, stylePrefix + 'Left');
                var right_1 = goog.style.getComputedStyle(element, stylePrefix + 'Right');
                var top_1 = goog.style.getComputedStyle(element, stylePrefix + 'Top');
                var bottom_1 = goog.style.getComputedStyle(element, stylePrefix + 'Bottom');
                // NOTE(arv): Gecko can return floating point numbers for the computed
                // style values.
                return new goog.math.Box(parseFloat(top_1), parseFloat(right_1), parseFloat(bottom_1), parseFloat(left_1));
            }
        }
        style_1.getBox_ = getBox_;
        ;
        /**
         * Gets the computed paddings (on all sides) in pixels.
         * @param {Element} element  The element to get the padding for.
         * @return {!goog.math.Box} The computed paddings.
         */
        function getPaddingBox(element) {
            return goog.style.getBox_(element, 'padding');
        }
        style_1.getPaddingBox = getPaddingBox;
        ;
        /**
         * Gets the computed margins (on all sides) in pixels.
         * @param {Element} element  The element to get the margins for.
         * @return {!goog.math.Box} The computed margins.
         */
        function getMarginBox(element) {
            return goog.style.getBox_(element, 'margin');
        }
        style_1.getMarginBox = getMarginBox;
        ;
        /**
         * A map used to map the border width keywords to a pixel width.
         * @type {!Object}
         * @private
         */
        style_1.ieBorderWidthKeywords_ = {
            'thin': 2,
            'medium': 4,
            'thick': 6
        };
        /**
         * Helper function for IE to get the pixel border.
         * @param {Element} element  The element to get the pixel border for.
         * @param {string} prop  The part of the property name.
         * @return {number} The value in pixels.
         * @private
         */
        function getIePixelBorder_(element, prop) {
            if (goog.style.getCascadedStyle(element, prop + 'Style') == 'none') {
                return 0;
            }
            var width = goog.style.getCascadedStyle(element, prop + 'Width');
            if (width in goog.style.ieBorderWidthKeywords_) {
                return goog.style.ieBorderWidthKeywords_[width];
            }
            return goog.style.getIePixelValue_(element, width, 'left', 'pixelLeft');
        }
        style_1.getIePixelBorder_ = getIePixelBorder_;
        ;
        /**
         * Gets the computed border widths (on all sides) in pixels
         * @param {Element} element  The element to get the border widths for.
         * @return {!goog.math.Box} The computed border widths.
         */
        function getBorderBox(element) {
            if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
                var left = goog.style.getIePixelBorder_(element, 'borderLeft');
                var right = goog.style.getIePixelBorder_(element, 'borderRight');
                var top = goog.style.getIePixelBorder_(element, 'borderTop');
                var bottom = goog.style.getIePixelBorder_(element, 'borderBottom');
                return new goog.math.Box(top, right, bottom, left);
            }
            else {
                // On non-IE browsers, getComputedStyle is always non-null.
                var left_2 = goog.style.getComputedStyle(element, 'borderLeftWidth');
                var right_2 = goog.style.getComputedStyle(element, 'borderRightWidth');
                var top_2 = goog.style.getComputedStyle(element, 'borderTopWidth');
                var bottom_2 = goog.style.getComputedStyle(element, 'borderBottomWidth');
                return new goog.math.Box(parseFloat(top_2), parseFloat(right_2), parseFloat(bottom_2), parseFloat(left_2));
            }
        }
        style_1.getBorderBox = getBorderBox;
        ;
        /**
         * Returns the font face applied to a given node. Opera and IE should return
         * the font actually displayed. Firefox returns the author's most-preferred
         * font (whether the browser is capable of displaying it or not.)
         * @param {Element} el  The element whose font family is returned.
         * @return {string} The font family applied to el.
         */
        function getFontFamily(el) {
            var doc = goog.dom.getOwnerDocument(el);
            var font = '';
            // The moveToElementText method from the TextRange only works if the element
            // is attached to the owner document.
            if (doc.body.createTextRange && goog.dom.contains(doc, el)) {
                var range = doc.body.createTextRange();
                range.moveToElementText(el);
                try {
                    font = range.queryCommandValue('FontName');
                }
                catch (e) {
                    // This is a workaround for a awkward exception.
                    // On some IE, there is an exception coming from it.
                    // The error description from this exception is:
                    // This window has already been registered as a drop target
                    // This is bogus description, likely due to a bug in ie.
                    font = '';
                }
            }
            if (!font) {
                // Note if for some reason IE can't derive FontName with a TextRange, we
                // fallback to using currentStyle
                font = goog.style.getStyle_(el, 'fontFamily');
            }
            // Firefox returns the applied font-family string (author's list of
            // preferred fonts.) We want to return the most-preferred font, in lieu of
            // the *actually* applied font.
            var fontsArray = font.split(',');
            if (fontsArray.length > 1)
                font = fontsArray[0];
            // Sanitize for x-browser consistency:
            // Strip quotes because browsers aren't consistent with how they're
            // applied; Opera always encloses, Firefox sometimes, and IE never.
            return goog.string.stripQuotes(font, '"\'');
        }
        style_1.getFontFamily = getFontFamily;
        ;
        /**
         * Regular expression used for getLengthUnits.
         * @type {RegExp}
         * @private
         */
        style_1.lengthUnitRegex_ = /[^\d]+$/;
        /**
         * Returns the units used for a CSS length measurement.
         * @param {string} value  A CSS length quantity.
         * @return {?string} The units of measurement.
         */
        function getLengthUnits(value) {
            var units = value.match(goog.style.lengthUnitRegex_);
            return units && units[0] || null;
        }
        style_1.getLengthUnits = getLengthUnits;
        ;
        /**
         * Map of absolute CSS length units
         * @type {!Object}
         * @private
         */
        style_1.ABSOLUTE_CSS_LENGTH_UNITS_ = {
            'cm': 1,
            'in': 1,
            'mm': 1,
            'pc': 1,
            'pt': 1
        };
        /**
         * Map of relative CSS length units that can be accurately converted to px
         * font-size values using getIePixelValue_. Only units that are defined in
         * relation to a font size are convertible (%, small, etc. are not).
         * @type {!Object}
         * @private
         */
        style_1.CONVERTIBLE_RELATIVE_CSS_UNITS_ = {
            'em': 1,
            'ex': 1
        };
        /**
         * Returns the font size, in pixels, of text in an element.
         * @param {Element} el  The element whose font size is returned.
         * @return {number} The font size (in pixels).
         */
        function getFontSize(el) {
            var fontSize = goog.style.getStyle_(el, 'fontSize');
            var sizeUnits = goog.style.getLengthUnits(fontSize);
            if (fontSize && 'px' == sizeUnits) {
                // NOTE(user): This could be parseFloat instead, but IE doesn't return
                // decimal fractions in getStyle_ and Firefox reports the fractions, but
                // ignores them when rendering. Interestingly enough, when we force the
                // issue and size something to e.g., 50% of 25px, the browsers round in
                // opposite directions with Firefox reporting 12px and IE 13px. I punt.
                return parseInt(fontSize, 10);
            }
            // In IE, we can convert absolute length units to a px value using
            // goog.style.getIePixelValue_. Units defined in relation to a font size
            // (em, ex) are applied relative to the element's parentNode and can also
            // be converted.
            if (goog.userAgent.IE) {
                if (String(sizeUnits) in goog.style.ABSOLUTE_CSS_LENGTH_UNITS_) {
                    return goog.style.getIePixelValue_(el, fontSize, 'left', 'pixelLeft');
                }
                else if (el.parentNode && el.parentNode.nodeType == goog.dom.NodeType.ELEMENT &&
                    String(sizeUnits) in goog.style.CONVERTIBLE_RELATIVE_CSS_UNITS_) {
                    // Check the parent size - if it is the same it means the relative size
                    // value is inherited and we therefore don't want to count it twice.  If
                    // it is different, this element either has explicit style or has a CSS
                    // rule applying to it.
                    var parentElement = (el.parentNode);
                    var parentSize = goog.style.getStyle_(parentElement, 'fontSize');
                    return goog.style.getIePixelValue_(parentElement, fontSize == parentSize ? '1em' : fontSize, 'left', 'pixelLeft');
                }
            }
            // Sometimes we can't cleanly find the font size (some units relative to a
            // node's parent's font size are difficult: %, smaller et al), so we create
            // an invisible, absolutely-positioned span sized to be the height of an 'M'
            // rendered in its parent's (i.e., our target element's) font size. This is
            // the definition of CSS's font size attribute.
            var sizeElement = goog.dom.createDom(goog.dom.TagName.SPAN, {
                'style': 'visibility:hidden;position:absolute;' +
                    'line-height:0;padding:0;margin:0;border:0;height:1em;'
            });
            goog.dom.appendChild(el, sizeElement);
            fontSize = sizeElement.offsetHeight;
            goog.dom.removeNode(sizeElement);
            return fontSize;
        }
        style_1.getFontSize = getFontSize;
        ;
        /**
         * Parses a style attribute value.  Converts CSS property names to camel case.
         * @param {string} value The style attribute value.
         * @return {!Object} Map of CSS properties to string values.
         */
        function parseStyleAttribute(value) {
            var result = {};
            goog.array.forEach(value.split(/\s*;\s*/), function (pair) {
                var keyValue = pair.match(/\s*([\w-]+)\s*\:(.+)/);
                if (keyValue) {
                    var styleName = keyValue[1];
                    var styleValue = goog.string.trim(keyValue[2]);
                    result[goog.string.toCamelCase(styleName.toLowerCase())] = styleValue;
                }
            });
            return result;
        }
        style_1.parseStyleAttribute = parseStyleAttribute;
        ;
        /**
         * Reverse of parseStyleAttribute; that is, takes a style object and returns the
         * corresponding attribute value.  Converts camel case property names to proper
         * CSS selector names.
         * @param {Object} obj Map of CSS properties to values.
         * @return {string} The style attribute value.
         */
        function toStyleAttribute(obj) {
            var buffer = [];
            goog.object.forEach(obj, function (value, key) {
                buffer.push(goog.string.toSelectorCase(key), ':', value, ';');
            });
            return buffer.join('');
        }
        style_1.toStyleAttribute = toStyleAttribute;
        ;
        /**
         * Sets CSS float property on an element.
         * @param {Element} el The element to set float property on.
         * @param {string} value The value of float CSS property to set on this element.
         */
        function setFloat(el, value) {
            el.style[goog.userAgent.IE ? 'styleFloat' : 'cssFloat'] = value;
        }
        style_1.setFloat = setFloat;
        ;
        /**
         * Gets value of explicitly-set float CSS property on an element.
         * @param {Element} el The element to get float property of.
         * @return {string} The value of explicitly-set float CSS property on this
         *     element.
         */
        function getFloat(el) {
            return el.style[goog.userAgent.IE ? 'styleFloat' : 'cssFloat'] || '';
        }
        style_1.getFloat = getFloat;
        ;
        /**
         * Returns the scroll bar width (represents the width of both horizontal
         * and vertical scroll).
         *
         * @param {string=} opt_className An optional class name (or names) to apply
         *     to the invisible div created to measure the scrollbar. This is necessary
         *     if some scrollbars are styled differently than others.
         * @return {number} The scroll bar width in px.
         */
        function getScrollbarWidth(opt_className) {
            // Add two hidden divs.  The child div is larger than the parent and
            // forces scrollbars to appear on it.
            // Using overflow:scroll does not work consistently with scrollbars that
            // are styled with ::-webkit-scrollbar.
            var outerDiv = goog.dom.createElement(goog.dom.TagName.DIV);
            if (opt_className) {
                outerDiv.className = opt_className;
            }
            outerDiv.style.cssText = 'overflow:auto;' +
                'position:absolute;top:0;width:100px;height:100px';
            var innerDiv = goog.dom.createElement(goog.dom.TagName.DIV);
            goog.style.setSize(innerDiv, '200px', '200px');
            outerDiv.appendChild(innerDiv);
            goog.dom.appendChild(goog.dom.getDocument().body, outerDiv);
            var width = outerDiv.offsetWidth - outerDiv.clientWidth;
            goog.dom.removeNode(outerDiv);
            return width;
        }
        style_1.getScrollbarWidth = getScrollbarWidth;
        ;
        /**
         * Regular expression to extract x and y translation components from a CSS
         * transform Matrix representation.
         *
         * @type {!RegExp}
         * @const
         * @private
         */
        style_1.MATRIX_TRANSLATION_REGEX_ = new RegExp('matrix\\([0-9\\.\\-]+, [0-9\\.\\-]+, ' +
            '[0-9\\.\\-]+, [0-9\\.\\-]+, ' +
            '([0-9\\.\\-]+)p?x?, ([0-9\\.\\-]+)p?x?\\)');
        /**
         * Returns the x,y translation component of any CSS transforms applied to the
         * element, in pixels.
         *
         * @param {!Element} element The element to get the translation of.
         * @return {!goog.math.Coordinate} The CSS translation of the element in px.
         */
        function getCssTranslation(element) {
            var transform = goog.style.getComputedTransform(element);
            if (!transform) {
                return new goog.math.Coordinate(0, 0);
            }
            var matches = transform.match(goog.style.MATRIX_TRANSLATION_REGEX_);
            if (!matches) {
                return new goog.math.Coordinate(0, 0);
            }
            return new goog.math.Coordinate(parseFloat(matches[1]), parseFloat(matches[2]));
        }
        style_1.getCssTranslation = getCssTranslation;
        ;
    })(style = goog.style || (goog.style = {}));
})(goog || (goog = {}));
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Generator for unique element IDs.
 *
 */
goog.provide('goog.ui.IdGenerator');
var goog;
(function (goog) {
    var ui;
    (function (ui) {
        var IdGenerator = /** @class */ (function () {
            /**
             * Creates a new id generator.
             * @constructor
             * @final
             */
            function IdGenerator() {
                /**
                 * Next unique ID to use
                 * @type {number}
                 * @private
                 */
                this.nextId_ = 0;
            }
            /**
             * Gets the next unique ID.
             * @return {string} The next unique identifier.
             */
            IdGenerator.prototype.getNextUniqueId = function () {
                return ':' + (this.nextId_++).toString(36);
            };
            return IdGenerator;
        }());
        ui.IdGenerator = IdGenerator;
    })(ui = goog.ui || (goog.ui = {}));
})(goog || (goog = {}));
(function (goog) {
    var ui;
    (function (ui) {
        var IdGenerator;
        (function (IdGenerator) {
            IdGenerator.instance_ = undefined;
            function getInstance() {
                if (goog.ui.IdGenerator.instance_) {
                    return goog.ui.IdGenerator.instance_;
                }
                if (goog.DEBUG) {
                    // NOTE: JSCompiler can't optimize away Array#push.
                    goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = goog.ui.IdGenerator;
                }
                return goog.ui.IdGenerator.instance_ = new goog.ui.IdGenerator();
            }
            IdGenerator.getInstance = getInstance;
        })(IdGenerator = ui.IdGenerator || (ui.IdGenerator = {}));
    })(ui = goog.ui || (goog.ui = {}));
})(goog || (goog = {}));
goog.addSingletonGetter(goog.ui.IdGenerator);
/// <reference path="../array/array.ts" />
/// <reference path="../asserts/asserts.ts" />
/// <reference path="../dom/dom.ts" />
/// <reference path="../dom/nodetype.ts" />
/// <reference path="../dom/tagname.ts" />
/// <reference path="../events/eventhandler" />
/// <reference path="../events/eventtarget" />
/// <reference path="../object/object.ts" />
/// <reference path="../style/style.ts" />
/// <reference path="../ui/idgenerator.ts" />
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Abstract class for all UI components. This defines the standard
 * design pattern that all UI components should follow.
 *
 * @author attila@google.com (Attila Bodis)
 * @see ../demos/samplecomponent.html
 * @see http://code.google.com/p/closure-library/wiki/IntroToComponents
 */
goog.provide('goog.ui.Component');
goog.provide('goog.ui.Component.Error');
goog.provide('goog.ui.Component.EventType');
goog.provide('goog.ui.Component.State');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');
goog.require('goog.object');
goog.require('goog.style');
goog.require('goog.ui.IdGenerator');
var goog;
(function (goog) {
    var ui;
    (function (ui) {
        /**
         * Default implementation of UI component.
         *
         * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper.
         * @constructor
         * @extends {goog.events.EventTarget}
         * @suppress {underscore}
         */
        var Component = /** @class */ (function (_super) {
            __extends(Component, _super);
            function Component(opt_domHelper) {
                var _this = _super.call(this) || this;
                goog.events.EventTarget.call(_this);
                /**
                 * DomHelper used to interact with the document, allowing components to be
                 * created in a different window.
                 * @protected {!goog.dom.DomHelper}
                 * @suppress {underscore|visibility}
                 */
                _this.dom_ = opt_domHelper || goog.dom.getDomHelper();
                /**
                 * Whether the component is rendered right-to-left.  Right-to-left is set
                 * lazily when {@link #isRightToLeft} is called the first time, unless it has
                 * been set by calling {@link #setRightToLeft} explicitly.
                 * @private {?boolean}
                 */
                _this.rightToLeft_ = goog.ui.Component.defaultRightToLeft_;
                /**
                 * Unique ID of the component, lazily initialized in {@link
                 * goog.ui.Component#getId} if needed.  This property is strictly private and
                 * must not be accessed directly outside of this class!
                 * @private {?string}
                 */
                _this.id_ = null;
                /**
                 * Whether the component is in the document.
                 * @private {boolean}
                 */
                _this.inDocument_ = false;
                // TODO(attila): Stop referring to this private field in subclasses.
                /**
                 * The DOM element for the component.
                 * @private {Element}
                 */
                _this.element_ = null;
                /**
                 * Event handler.
                 * TODO(user): rename it to handler_ after all component subclasses in
                 * inside Google have been cleaned up.
                 * Code search: http://go/component_code_search
                 * @private {goog.events.EventHandler|undefined}
                 */
                _this.googUiComponentHandler_ = void 0;
                /**
                 * Arbitrary data object associated with the component.  Such as meta-data.
                 * @private {*}
                 */
                _this.model_ = null;
                /**
                 * Parent component to which events will be propagated.  This property is
                 * strictly private and must not be accessed directly outside of this class!
                 * @private {goog.ui.Component?}
                 */
                _this.parent_ = null;
                /**
                 * Array of child components.  Lazily initialized on first use.  Must be kept
                 * in sync with {@code childIndex_}.  This property is strictly private and
                 * must not be accessed directly outside of this class!
                 * @private {Array<goog.ui.Component>?}
                 */
                _this.children_ = null;
                /**
                 * Map of child component IDs to child components.  Used for constant-time
                 * random access to child components by ID.  Lazily initialized on first use.
                 * Must be kept in sync with {@code children_}.  This property is strictly
                 * private and must not be accessed directly outside of this class!
                 *
                 * We use a plain Object, not a {@link goog.structs.Map}, for simplicity.
                 * This means components can't have children with IDs such as 'constructor' or
                 * 'valueOf', but this shouldn't really be an issue in practice, and if it is,
                 * we can always fix it later without changing the API.
                 *
                 * @private {Object}
                 */
                _this.childIndex_ = null;
                /**
                 * Flag used to keep track of whether a component decorated an already
                 * existing element or whether it created the DOM itself.
                 *
                 * If an element is decorated, dispose will leave the node in the document.
                 * It is up to the app to remove the node.
                 *
                 * If an element was rendered, dispose will remove the node automatically.
                 *
                 * @private {boolean}
                 */
                _this.wasDecorated_ = false;
                /**
                 * Generator for unique IDs.
                 * @type {goog.ui.IdGenerator}
                 * @private
                 */
                _this.idGenerator_ = goog.ui.IdGenerator.getInstance();
                return _this;
            }
            /**
             * Static helper method; returns the type of event components are expected to
             * dispatch when transitioning to or from the given state.
             * @param {goog.ui.Component.State} state State to/from which the component
             *     is transitioning.
             * @param {boolean} isEntering Whether the component is entering or leaving the
             *     state.
             * @return {goog.ui.Component.EventType} Event type to dispatch.
             */
            Component.getStateTransitionEvent = function (state, isEntering) {
                switch (state) {
                    case goog.ui.Component.State.DISABLED:
                        return isEntering ? goog.ui.Component.EventType.DISABLE :
                            goog.ui.Component.EventType.ENABLE;
                    case goog.ui.Component.State.HOVER:
                        return isEntering ? goog.ui.Component.EventType.HIGHLIGHT :
                            goog.ui.Component.EventType.UNHIGHLIGHT;
                    case goog.ui.Component.State.ACTIVE:
                        return isEntering ? goog.ui.Component.EventType.ACTIVATE :
                            goog.ui.Component.EventType.DEACTIVATE;
                    case goog.ui.Component.State.SELECTED:
                        return isEntering ? goog.ui.Component.EventType.SELECT :
                            goog.ui.Component.EventType.UNSELECT;
                    case goog.ui.Component.State.CHECKED:
                        return isEntering ? goog.ui.Component.EventType.CHECK :
                            goog.ui.Component.EventType.UNCHECK;
                    case goog.ui.Component.State.FOCUSED:
                        return isEntering ? goog.ui.Component.EventType.FOCUS :
                            goog.ui.Component.EventType.BLUR;
                    case goog.ui.Component.State.OPENED:
                        return isEntering ? goog.ui.Component.EventType.OPEN :
                            goog.ui.Component.EventType.CLOSE;
                    default:
                }
                // Invalid state.
                throw new Error(goog.ui.Component.Error.STATE_INVALID);
            };
            ;
            /**
             * Set the default right-to-left value. This causes all component's created from
             * this point forward to have the given value. This is useful for cases where
             * a given page is always in one directionality, avoiding unnecessary
             * right to left determinations.
             * @param {?boolean} rightToLeft Whether the components should be rendered
             *     right-to-left. Null iff components should determine their directionality.
             */
            Component.setDefaultRightToLeft = function (rightToLeft) {
                goog.ui.Component.defaultRightToLeft_ = rightToLeft;
            };
            ;
            /**
             * Gets the unique ID for the instance of this component.  If the instance
             * doesn't already have an ID, generates one on the fly.
             * @return {string} Unique component ID.
             */
            Component.prototype.getId = function () {
                return this.id_ || (this.id_ = this.idGenerator_.getNextUniqueId());
            };
            ;
            /**
             * Assigns an ID to this component instance.  It is the caller's responsibility
             * to guarantee that the ID is unique.  If the component is a child of a parent
             * component, then the parent component's child index is updated to reflect the
             * new ID; this may throw an error if the parent already has a child with an ID
             * that conflicts with the new ID.
             * @param {string} id Unique component ID.
             */
            Component.prototype.setId = function (id) {
                if (this.parent_ && this.parent_.childIndex_) {
                    // Update the parent's child index.
                    goog.object.remove(this.parent_.childIndex_, this.id_);
                    goog.object.add(this.parent_.childIndex_, id, this);
                }
                // Update the component ID.
                this.id_ = id;
            };
            ;
            /**
             * Gets the component's element.
             * @return {Element} The element for the component.
             */
            Component.prototype.getElement = function () {
                return this.element_;
            };
            ;
            /**
             * Gets the component's element. This differs from getElement in that
             * it assumes that the element exists (i.e. the component has been
             * rendered/decorated) and will cause an assertion error otherwise (if
             * assertion is enabled).
             * @return {!Element} The element for the component.
             */
            Component.prototype.getElementStrict = function () {
                var el = this.element_;
                goog.asserts.assert(el, 'Can not call getElementStrict before rendering/decorating.');
                return el;
            };
            ;
            /**
             * Sets the component's root element to the given element.  Considered
             * protected and final.
             *
             * This should generally only be called during createDom. Setting the element
             * does not actually change which element is rendered, only the element that is
             * associated with this UI component.
             *
             * This should only be used by subclasses and its associated renderers.
             *
             * @param {Element} element Root element for the component.
             */
            Component.prototype.setElementInternal = function (element) {
                this.element_ = element;
            };
            ;
            /**
             * Returns an array of all the elements in this component's DOM with the
             * provided className.
             * @param {string} className The name of the class to look for.
             * @return {!IArrayLike<!Element>} The items found with the class name provided.
             */
            Component.prototype.getElementsByClass = function (className) {
                return this.element_ ?
                    this.dom_.getElementsByClass(className, this.element_) :
                    [];
            };
            ;
            /**
             * Returns the first element in this component's DOM with the provided
             * className.
             * @param {string} className The name of the class to look for.
             * @return {Element} The first item with the class name provided.
             */
            Component.prototype.getElementByClass = function (className) {
                return this.element_ ? this.dom_.getElementByClass(className, this.element_) :
                    null;
            };
            ;
            /**
             * Similar to {@code getElementByClass} except that it expects the
             * element to be present in the dom thus returning a required value. Otherwise,
             * will assert.
             * @param {string} className The name of the class to look for.
             * @return {!Element} The first item with the class name provided.
             */
            Component.prototype.getRequiredElementByClass = function (className) {
                var el = this.getElementByClass(className);
                goog.asserts.assert(el, 'Expected element in component with class: %s', className);
                return el;
            };
            ;
            /**
             * Returns the event handler for this component, lazily created the first time
             * this method is called.
             * @return {!goog.events.EventHandler<T>} Event handler for this component.
             * @protected
             * @this {T}
             * @template T
             */
            Component.prototype.getHandler = function () {
                // TODO(user): templated "this" values currently result in "this" being
                // "unknown" in the body of the function.
                var self = (this);
                if (!self.googUiComponentHandler_) {
                    self.googUiComponentHandler_ = new goog.events.EventHandler(self);
                }
                return self.googUiComponentHandler_;
            };
            ;
            /**
             * Sets the parent of this component to use for event bubbling.  Throws an error
             * if the component already has a parent or if an attempt is made to add a
             * component to itself as a child.  Callers must use {@code removeChild}
             * or {@code removeChildAt} to remove components from their containers before
             * calling this method.
             * @see goog.ui.Component#removeChild
             * @see goog.ui.Component#removeChildAt
             * @param {goog.ui.Component} parent The parent component.
             */
            Component.prototype.setParent = function (parent) {
                if (this == parent) {
                    // Attempting to add a child to itself is an error.
                    throw new Error(goog.ui.Component.Error.PARENT_UNABLE_TO_BE_SET);
                }
                if (parent && this.parent_ && this.id_ && this.parent_.getChild(this.id_) &&
                    this.parent_ != parent) {
                    // This component is already the child of some parent, so it should be
                    // removed using removeChild/removeChildAt first.
                    throw new Error(goog.ui.Component.Error.PARENT_UNABLE_TO_BE_SET);
                }
                this.parent_ = parent;
                goog.ui.Component.superClass_.setParentEventTarget.call(this, parent);
            };
            ;
            /**
             * Returns the component's parent, if any.
             * @return {goog.ui.Component?} The parent component.
             */
            Component.prototype.getParent = function () {
                return this.parent_;
            };
            ;
            /**
             * Overrides {@link goog.events.EventTarget#setParentEventTarget} to throw an
             * error if the parent component is set, and the argument is not the parent.
             * @override
             */
            Component.prototype.setParentEventTarget = function (parent) {
                if (this.parent_ && this.parent_ != parent) {
                    throw new Error(goog.ui.Component.Error.NOT_SUPPORTED);
                }
                goog.ui.Component.superClass_.setParentEventTarget.call(this, parent);
            };
            ;
            /**
             * Returns the dom helper that is being used on this component.
             * @return {!goog.dom.DomHelper} The dom helper used on this component.
             */
            Component.prototype.getDomHelper = function () {
                return this.dom_;
            };
            ;
            /**
             * Determines whether the component has been added to the document.
             * @return {boolean} TRUE if rendered. Otherwise, FALSE.
             */
            Component.prototype.isInDocument = function () {
                return this.inDocument_;
            };
            ;
            /**
             * Creates the initial DOM representation for the component.  The default
             * implementation is to set this.element_ = div.
             */
            Component.prototype.createDom = function () {
                this.element_ = this.dom_.createElement(goog.dom.TagName.DIV);
            };
            ;
            /**
             * Renders the component.  If a parent element is supplied, the component's
             * element will be appended to it.  If there is no optional parent element and
             * the element doesn't have a parentNode then it will be appended to the
             * document body.
             *
             * If this component has a parent component, and the parent component is
             * not in the document already, then this will not call {@code enterDocument}
             * on this component.
             *
             * Throws an Error if the component is already rendered.
             *
             * @param {Element=} opt_parentElement Optional parent element to render the
             *    component into.
             */
            Component.prototype.render = function (opt_parentElement) {
                this.render_(opt_parentElement);
            };
            ;
            /**
             * Renders the component before another element. The other element should be in
             * the document already.
             *
             * Throws an Error if the component is already rendered.
             *
             * @param {Node} sibling Node to render the component before.
             */
            Component.prototype.renderBefore = function (sibling) {
                this.render_(/** @type {Element} */ (sibling.parentNode), sibling);
            };
            ;
            /**
             * Renders the component.  If a parent element is supplied, the component's
             * element will be appended to it.  If there is no optional parent element and
             * the element doesn't have a parentNode then it will be appended to the
             * document body.
             *
             * If this component has a parent component, and the parent component is
             * not in the document already, then this will not call {@code enterDocument}
             * on this component.
             *
             * Throws an Error if the component is already rendered.
             *
             * @param {Element=} opt_parentElement Optional parent element to render the
             *    component into.
             * @param {Node=} opt_beforeNode Node before which the component is to
             *    be rendered.  If left out the node is appended to the parent element.
             * @private
             */
            Component.prototype.render_ = function (opt_parentElement, opt_beforeNode) {
                if (this.inDocument_) {
                    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
                }
                if (!this.element_) {
                    this.createDom();
                }
                if (opt_parentElement) {
                    opt_parentElement.insertBefore(this.element_, opt_beforeNode || null);
                }
                else {
                    this.dom_.getDocument().body.appendChild(this.element_);
                }
                // If this component has a parent component that isn't in the document yet,
                // we don't call enterDocument() here.  Instead, when the parent component
                // enters the document, the enterDocument() call will propagate to its
                // children, including this one.  If the component doesn't have a parent
                // or if the parent is already in the document, we call enterDocument().
                if (!this.parent_ || this.parent_.isInDocument()) {
                    this.enterDocument();
                }
            };
            ;
            /**
             * Decorates the element for the UI component. If the element is in the
             * document, the enterDocument method will be called.
             *
             * If goog.ui.Component.ALLOW_DETACHED_DECORATION is false, the caller must
             * pass an element that is in the document.
             *
             * @param {Element} element Element to decorate.
             */
            Component.prototype.decorate = function (element) {
                if (this.inDocument_) {
                    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
                }
                else if (element && this.canDecorate(element)) {
                    this.wasDecorated_ = true;
                    // Set the DOM helper of the component to match the decorated element.
                    var doc = goog.dom.getOwnerDocument(element);
                    if (!this.dom_ || this.dom_.getDocument() != doc) {
                        this.dom_ = goog.dom.getDomHelper(element);
                    }
                    // Call specific component decorate logic.
                    this.decorateInternal(element);
                    // If supporting detached decoration, check that element is in doc.
                    if (!goog.ui.Component.ALLOW_DETACHED_DECORATION ||
                        goog.dom.contains(doc, element)) {
                        this.enterDocument();
                    }
                }
                else {
                    throw new Error(goog.ui.Component.Error.DECORATE_INVALID);
                }
            };
            ;
            /**
             * Determines if a given element can be decorated by this type of component.
             * This method should be overridden by inheriting objects.
             * @param {Element} element Element to decorate.
             * @return {boolean} True if the element can be decorated, false otherwise.
             */
            Component.prototype.canDecorate = function (element) {
                return true;
            };
            ;
            /**
             * @return {boolean} Whether the component was decorated.
             */
            Component.prototype.wasDecorated = function () {
                return this.wasDecorated_;
            };
            ;
            /**
             * Actually decorates the element. Should be overridden by inheriting objects.
             * This method can assume there are checks to ensure the component has not
             * already been rendered have occurred and that enter document will be called
             * afterwards. This method is considered protected.
             * @param {Element} element Element to decorate.
             * @protected
             */
            Component.prototype.decorateInternal = function (element) {
                this.element_ = element;
            };
            ;
            /**
             * Called when the component's element is known to be in the document. Anything
             * using document.getElementById etc. should be done at this stage.
             *
             * If the component contains child components, this call is propagated to its
             * children.
             */
            Component.prototype.enterDocument = function () {
                this.inDocument_ = true;
                // Propagate enterDocument to child components that have a DOM, if any.
                // If a child was decorated before entering the document (permitted when
                // goog.ui.Component.ALLOW_DETACHED_DECORATION is true), its enterDocument
                // will be called here.
                this.forEachChild(function (child) {
                    if (!child.isInDocument() && child.getElement()) {
                        child.enterDocument();
                    }
                });
            };
            ;
            /**
             * Called by dispose to clean up the elements and listeners created by a
             * component, or by a parent component/application who has removed the
             * component from the document but wants to reuse it later.
             *
             * If the component contains child components, this call is propagated to its
             * children.
             *
             * It should be possible for the component to be rendered again once this method
             * has been called.
             */
            Component.prototype.exitDocument = function () {
                // Propagate exitDocument to child components that have been rendered, if any.
                this.forEachChild(function (child) {
                    if (child.isInDocument()) {
                        child.exitDocument();
                    }
                });
                if (this.googUiComponentHandler_) {
                    this.googUiComponentHandler_.removeAll();
                }
                this.inDocument_ = false;
            };
            ;
            /**
             * Disposes of the component.  Calls {@code exitDocument}, which is expected to
             * remove event handlers and clean up the component.  Propagates the call to
             * the component's children, if any. Removes the component's DOM from the
             * document unless it was decorated.
             * @override
             * @protected
             */
            Component.prototype.disposeInternal = function () {
                if (this.inDocument_) {
                    this.exitDocument();
                }
                if (this.googUiComponentHandler_) {
                    this.googUiComponentHandler_.dispose();
                    delete this.googUiComponentHandler_;
                }
                // Disposes of the component's children, if any.
                this.forEachChild(function (child) { child.dispose(); });
                // Detach the component's element from the DOM, unless it was decorated.
                if (!this.wasDecorated_ && this.element_) {
                    goog.dom.removeNode(this.element_);
                }
                this.children_ = null;
                this.childIndex_ = null;
                this.element_ = null;
                this.model_ = null;
                this.parent_ = null;
                goog.ui.Component.superClass_.disposeInternal.call(this);
            };
            ;
            /**
             * Helper function for subclasses that gets a unique id for a given fragment,
             * this can be used by components to generate unique string ids for DOM
             * elements.
             * @param {string} idFragment A partial id.
             * @return {string} Unique element id.
             */
            Component.prototype.makeId = function (idFragment) {
                return this.getId() + '.' + idFragment;
            };
            ;
            /**
             * Makes a collection of ids.  This is a convenience method for makeId.  The
             * object's values are the id fragments and the new values are the generated
             * ids.  The key will remain the same.
             * @param {Object} object The object that will be used to create the ids.
             * @return {!Object<string, string>} An object of id keys to generated ids.
             */
            Component.prototype.makeIds = function (object) {
                var ids = {};
                for (var key in object) {
                    ids[key] = this.makeId(object[key]);
                }
                return ids;
            };
            ;
            /**
             * Returns the model associated with the UI component.
             * @return {*} The model.
             */
            Component.prototype.getModel = function () {
                return this.model_;
            };
            ;
            /**
             * Sets the model associated with the UI component.
             * @param {*} obj The model.
             */
            Component.prototype.setModel = function (obj) {
                this.model_ = obj;
            };
            ;
            /**
             * Helper function for returning the fragment portion of an id generated using
             * makeId().
             * @param {string} id Id generated with makeId().
             * @return {string} Fragment.
             */
            Component.prototype.getFragmentFromId = function (id) {
                return id.substring(this.getId().length + 1);
            };
            ;
            /**
             * Helper function for returning an element in the document with a unique id
             * generated using makeId().
             * @param {string} idFragment The partial id.
             * @return {Element} The element with the unique id, or null if it cannot be
             *     found.
             */
            Component.prototype.getElementByFragment = function (idFragment) {
                if (!this.inDocument_) {
                    throw new Error(goog.ui.Component.Error.NOT_IN_DOCUMENT);
                }
                return this.dom_.getElement(this.makeId(idFragment));
            };
            ;
            /**
             * Adds the specified component as the last child of this component.  See
             * {@link goog.ui.Component#addChildAt} for detailed semantics.
             *
             * @see goog.ui.Component#addChildAt
             * @param {goog.ui.Component} child The new child component.
             * @param {boolean=} opt_render If true, the child component will be rendered
             *    into the parent.
             */
            Component.prototype.addChild = function (child, opt_render) {
                // TODO(gboyer): addChildAt(child, this.getChildCount(), false) will
                // reposition any already-rendered child to the end.  Instead, perhaps
                // addChild(child, false) should never reposition the child; instead, clients
                // that need the repositioning will use addChildAt explicitly.  Right now,
                // clients can get around this by calling addChild before calling decorate.
                this.addChildAt(child, this.getChildCount(), opt_render);
            };
            ;
            /**
             * Adds the specified component as a child of this component at the given
             * 0-based index.
             *
             * Both {@code addChild} and {@code addChildAt} assume the following contract
             * between parent and child components:
             *  <ul>
             *    <li>the child component's element must be a descendant of the parent
             *        component's element, and
             *    <li>the DOM state of the child component must be consistent with the DOM
             *        state of the parent component (see {@code isInDocument}) in the
             *        steady state -- the exception is to addChildAt(child, i, false) and
             *        then immediately decorate/render the child.
             *  </ul>
             *
             * In particular, {@code parent.addChild(child)} will throw an error if the
             * child component is already in the document, but the parent isn't.
             *
             * Clients of this API may call {@code addChild} and {@code addChildAt} with
             * {@code opt_render} set to true.  If {@code opt_render} is true, calling these
             * methods will automatically render the child component's element into the
             * parent component's element. If the parent does not yet have an element, then
             * {@code createDom} will automatically be invoked on the parent before
             * rendering the child.
             *
             * Invoking {@code parent.addChild(child, true)} will throw an error if the
             * child component is already in the document, regardless of the parent's DOM
             * state.
             *
             * If {@code opt_render} is true and the parent component is not already
             * in the document, {@code enterDocument} will not be called on this component
             * at this point.
             *
             * Finally, this method also throws an error if the new child already has a
             * different parent, or the given index is out of bounds.
             *
             * @see goog.ui.Component#addChild
             * @param {goog.ui.Component} child The new child component.
             * @param {number} index 0-based index at which the new child component is to be
             *    added; must be between 0 and the current child count (inclusive).
             * @param {boolean=} opt_render If true, the child component will be rendered
             *    into the parent.
             * @return {void} Nada.
             */
            Component.prototype.addChildAt = function (child, index, opt_render) {
                goog.asserts.assert(!!child, 'Provided element must not be null.');
                if (child.inDocument_ && (opt_render || !this.inDocument_)) {
                    // Adding a child that's already in the document is an error, except if the
                    // parent is also in the document and opt_render is false (e.g. decorate()).
                    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
                }
                if (index < 0 || index > this.getChildCount()) {
                    // Allowing sparse child arrays would lead to strange behavior, so we don't.
                    throw new Error(goog.ui.Component.Error.CHILD_INDEX_OUT_OF_BOUNDS);
                }
                // Create the index and the child array on first use.
                if (!this.childIndex_ || !this.children_) {
                    this.childIndex_ = {};
                    this.children_ = [];
                }
                // Moving child within component, remove old reference.
                if (child.getParent() == this) {
                    goog.object.set(this.childIndex_, child.getId(), child);
                    goog.array.remove(this.children_, child);
                    // Add the child to this component.  goog.object.add() throws an error if
                    // a child with the same ID already exists.
                }
                else {
                    goog.object.add(this.childIndex_, child.getId(), child);
                }
                // Set the parent of the child to this component.  This throws an error if
                // the child is already contained by another component.
                child.setParent(this);
                goog.array.insertAt(this.children_, child, index);
                if (child.inDocument_ && this.inDocument_ && child.getParent() == this) {
                    // Changing the position of an existing child, move the DOM node (if
                    // necessary).
                    var contentElement = this.getContentElement();
                    var insertBeforeElement = contentElement.childNodes[index] || null;
                    if (insertBeforeElement != child.getElement()) {
                        contentElement.insertBefore(child.getElement(), insertBeforeElement);
                    }
                }
                else if (opt_render) {
                    // If this (parent) component doesn't have a DOM yet, call createDom now
                    // to make sure we render the child component's element into the correct
                    // parent element (otherwise render_ with a null first argument would
                    // render the child into the document body, which is almost certainly not
                    // what we want).
                    if (!this.element_) {
                        this.createDom();
                    }
                    // Render the child into the parent at the appropriate location.  Note that
                    // getChildAt(index + 1) returns undefined if inserting at the end.
                    // TODO(attila): We should have a renderer with a renderChildAt API.
                    var sibling = this.getChildAt(index + 1);
                    // render_() calls enterDocument() if the parent is already in the document.
                    child.render_(this.getContentElement(), sibling ? sibling.element_ : null);
                }
                else if (this.inDocument_ && !child.inDocument_ && child.element_ &&
                    child.element_.parentNode &&
                    // Under some circumstances, IE8 implicitly creates a Document Fragment
                    // for detached nodes, so ensure the parent is an Element as it should be.
                    child.element_.parentNode.nodeType == goog.dom.NodeType.ELEMENT) {
                    // We don't touch the DOM, but if the parent is in the document, and the
                    // child element is in the document but not marked as such, then we call
                    // enterDocument on the child.
                    // TODO(gboyer): It would be nice to move this condition entirely, but
                    // there's a large risk of breaking existing applications that manually
                    // append the child to the DOM and then call addChild.
                    child.enterDocument();
                }
            };
            ;
            /**
             * Returns the DOM element into which child components are to be rendered,
             * or null if the component itself hasn't been rendered yet.  This default
             * implementation returns the component's root element.  Subclasses with
             * complex DOM structures must override this method.
             * @return {Element} Element to contain child elements (null if none).
             */
            Component.prototype.getContentElement = function () {
                return this.element_;
            };
            ;
            /**
             * Returns true if the component is rendered right-to-left, false otherwise.
             * The first time this function is invoked, the right-to-left rendering property
             * is set if it has not been already.
             * @return {boolean} Whether the control is rendered right-to-left.
             */
            Component.prototype.isRightToLeft = function () {
                if (this.rightToLeft_ == null) {
                    this.rightToLeft_ = goog.style.isRightToLeft(this.inDocument_ ? this.element_ : this.dom_.getDocument().body);
                }
                return this.rightToLeft_;
            };
            ;
            /**
             * Set is right-to-left. This function should be used if the component needs
             * to know the rendering direction during dom creation (i.e. before
             * {@link #enterDocument} is called and is right-to-left is set).
             * @param {boolean} rightToLeft Whether the component is rendered
             *     right-to-left.
             */
            Component.prototype.setRightToLeft = function (rightToLeft) {
                if (this.inDocument_) {
                    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
                }
                this.rightToLeft_ = rightToLeft;
            };
            ;
            /**
             * Returns true if the component has children.
             * @return {boolean} True if the component has children.
             */
            Component.prototype.hasChildren = function () {
                return !!this.children_ && this.children_.length != 0;
            };
            ;
            /**
             * Returns the number of children of this component.
             * @return {number} The number of children.
             */
            Component.prototype.getChildCount = function () {
                return this.children_ ? this.children_.length : 0;
            };
            ;
            /**
             * Returns an array containing the IDs of the children of this component, or an
             * empty array if the component has no children.
             * @return {!Array<string>} Child component IDs.
             */
            Component.prototype.getChildIds = function () {
                var ids = [];
                // We don't use goog.object.getKeys(this.childIndex_) because we want to
                // return the IDs in the correct order as determined by this.children_.
                this.forEachChild(function (child) {
                    // addChild()/addChildAt() guarantee that the child array isn't sparse.
                    ids.push(child.getId());
                });
                return ids;
            };
            ;
            /**
             * Returns the child with the given ID, or null if no such child exists.
             * @param {string} id Child component ID.
             * @return {goog.ui.Component?} The child with the given ID; null if none.
             */
            Component.prototype.getChild = function (id) {
                // Use childIndex_ for O(1) access by ID.
                return (this.childIndex_ && id) ?
                    /** @type {goog.ui.Component} */ (goog.object.get(this.childIndex_, id)) ||
                        null :
                    null;
            };
            ;
            /**
             * Returns the child at the given index, or null if the index is out of bounds.
             * @param {number} index 0-based index.
             * @return {goog.ui.Component?} The child at the given index; null if none.
             */
            Component.prototype.getChildAt = function (index) {
                // Use children_ for access by index.
                return this.children_ ? this.children_[index] || null : null;
            };
            ;
            /**
             * Calls the given function on each of this component's children in order.  If
             * {@code opt_obj} is provided, it will be used as the 'this' object in the
             * function when called.  The function should take two arguments:  the child
             * component and its 0-based index.  The return value is ignored.
             * @param {function(this:T,?,number):?} f The function to call for every
             * child component; should take 2 arguments (the child and its index).
             * @param {T=} opt_obj Used as the 'this' object in f when called.
             * @template T
             */
            Component.prototype.forEachChild = function (f, opt_obj) {
                if (this.children_) {
                    goog.array.forEach(this.children_, f, opt_obj);
                }
            };
            ;
            /**
             * Returns the 0-based index of the given child component, or -1 if no such
             * child is found.
             * @param {goog.ui.Component?} child The child component.
             * @return {number} 0-based index of the child component; -1 if not found.
             */
            Component.prototype.indexOfChild = function (child) {
                return (this.children_ && child) ? goog.array.indexOf(this.children_, child) :
                    -1;
            };
            ;
            /**
             * Removes the given child from this component, and returns it.  Throws an error
             * if the argument is invalid or if the specified child isn't found in the
             * parent component.  The argument can either be a string (interpreted as the
             * ID of the child component to remove) or the child component itself.
             *
             * If {@code opt_unrender} is true, calls {@link goog.ui.component#exitDocument}
             * on the removed child, and subsequently detaches the child's DOM from the
             * document.  Otherwise it is the caller's responsibility to clean up the child
             * component's DOM.
             *
             * @see goog.ui.Component#removeChildAt
             * @param {string|goog.ui.Component|null} child The ID of the child to remove,
             *    or the child component itself.
             * @param {boolean=} opt_unrender If true, calls {@code exitDocument} on the
             *    removed child component, and detaches its DOM from the document.
             * @return {goog.ui.Component} The removed component, if any.
             */
            Component.prototype.removeChild = function (child, opt_unrender) {
                if (child) {
                    // Normalize child to be the object and id to be the ID string.  This also
                    // ensures that the child is really ours.
                    var id = goog.isString(child) ? child : child.getId();
                    child = this.getChild(id);
                    if (id && child) {
                        goog.object.remove(this.childIndex_, id);
                        goog.array.remove(this.children_, child);
                        if (opt_unrender) {
                            // Remove the child component's DOM from the document.  We have to call
                            // exitDocument first (see documentation).
                            child.exitDocument();
                            if (child.element_) {
                                goog.dom.removeNode(child.element_);
                            }
                        }
                        // Child's parent must be set to null after exitDocument is called
                        // so that the child can unlisten to its parent if required.
                        child.setParent(null);
                    }
                }
                if (!child) {
                    throw new Error(goog.ui.Component.Error.NOT_OUR_CHILD);
                }
                return /** @type {!goog.ui.Component} */ (child);
            };
            ;
            /**
             * Removes the child at the given index from this component, and returns it.
             * Throws an error if the argument is out of bounds, or if the specified child
             * isn't found in the parent.  See {@link goog.ui.Component#removeChild} for
             * detailed semantics.
             *
             * @see goog.ui.Component#removeChild
             * @param {number} index 0-based index of the child to remove.
             * @param {boolean=} opt_unrender If true, calls {@code exitDocument} on the
             *    removed child component, and detaches its DOM from the document.
             * @return {goog.ui.Component} The removed component, if any.
             */
            Component.prototype.removeChildAt = function (index, opt_unrender) {
                // removeChild(null) will throw error.
                return this.removeChild(this.getChildAt(index), opt_unrender);
            };
            ;
            /**
             * Removes every child component attached to this one and returns them.
             *
             * @see goog.ui.Component#removeChild
             * @param {boolean=} opt_unrender If true, calls {@link #exitDocument} on the
             *    removed child components, and detaches their DOM from the document.
             * @return {!Array<goog.ui.Component>} The removed components if any.
             */
            Component.prototype.removeChildren = function (opt_unrender) {
                var removedChildren = [];
                while (this.hasChildren()) {
                    removedChildren.push(this.removeChildAt(0, opt_unrender));
                }
                return removedChildren;
            };
            ;
            return Component;
        }(goog.events.EventTarget));
        ui.Component = Component;
    })(ui = goog.ui || (goog.ui = {}));
})(goog || (goog = {}));
(function (goog) {
    var ui;
    (function (ui) {
        var Component;
        (function (Component) {
            /**
             * Common events fired by components so that event propagation is useful.  Not
             * all components are expected to dispatch or listen for all event types.
             * Events dispatched before a state transition should be cancelable to prevent
             * the corresponding state change.
             * @enum {string}
             * @const
             */
            var EventType;
            (function (EventType) {
                /** Dispatched before the component becomes visible. */
                EventType["BEFORE_SHOW"] = "beforeshow";
                /**
                 * Dispatched after the component becomes visible.
                 * NOTE(user) = For goog.ui.Container, this actually fires before containers
                 * are shown.  Use goog.ui.Container.EventType.AFTER_SHOW if you want an event
                 * that fires after a goog.ui.Container is shown.
                 */
                EventType["SHOW"] = "show";
                /** Dispatched before the component becomes hidden. */
                EventType["HIDE"] = "hide";
                /** Dispatched before the component becomes disabled. */
                EventType["DISABLE"] = "disable";
                /** Dispatched before the component becomes enabled. */
                EventType["ENABLE"] = "enable";
                /** Dispatched before the component becomes highlighted. */
                EventType["HIGHLIGHT"] = "highlight";
                /** Dispatched before the component becomes un-highlighted. */
                EventType["UNHIGHLIGHT"] = "unhighlight";
                /** Dispatched before the component becomes activated. */
                EventType["ACTIVATE"] = "activate";
                /** Dispatched before the component becomes deactivated. */
                EventType["DEACTIVATE"] = "deactivate";
                /** Dispatched before the component becomes selected. */
                EventType["SELECT"] = "select";
                /** Dispatched before the component becomes un-selected. */
                EventType["UNSELECT"] = "unselect";
                /** Dispatched before a component becomes checked. */
                EventType["CHECK"] = "check";
                /** Dispatched before a component becomes un-checked. */
                EventType["UNCHECK"] = "uncheck";
                /** Dispatched before a component becomes focused. */
                EventType["FOCUS"] = "focus";
                /** Dispatched before a component becomes blurred. */
                EventType["BLUR"] = "blur";
                /** Dispatched before a component is opened (expanded). */
                EventType["OPEN"] = "open";
                /** Dispatched before a component is closed (collapsed). */
                EventType["CLOSE"] = "close";
                /** Dispatched after a component is moused over. */
                EventType["ENTER"] = "enter";
                /** Dispatched after a component is moused out of. */
                EventType["LEAVE"] = "leave";
                /** Dispatched after the user activates the component. */
                EventType["ACTION"] = "action";
                /** Dispatched after the external-facing state of a component is changed. */
                EventType["CHANGE"] = "change";
            })(EventType = Component.EventType || (Component.EventType = {}));
            ;
            /**
             * Errors thrown by the component.
             * @const
             * @enum {string}
             */
            var Error;
            (function (Error) {
                /**
                 * Error when a method is not supported.
                 */
                Error["NOT_SUPPORTED"] = "Method not supported";
                /**
                 * Error when the given element can not be decorated.
                 */
                Error["DECORATE_INVALID"] = "Invalid element to decorate";
                /**
                 * Error when the component is already rendered and another render attempt is
                 * made.
                 */
                Error["ALREADY_RENDERED"] = "Component already rendered";
                /**
                 * Error when an attempt is made to set the parent of a component in a way
                 * that would result in an inconsistent object graph.
                 */
                Error["PARENT_UNABLE_TO_BE_SET"] = "Unable to set parent component";
                /**
                 * Error when an attempt is made to add a child component at an out-of-bounds
                 * index.  We don't support sparse child arrays.
                 */
                Error["CHILD_INDEX_OUT_OF_BOUNDS"] = "Child component index out of bounds";
                /**
                 * Error when an attempt is made to remove a child component from a component
                 * other than its parent.
                 */
                Error["NOT_OUR_CHILD"] = "Child is not in parent component";
                /**
                 * Error when an operation requiring DOM interaction is made when the
                 * component is not in the document
                 */
                Error["NOT_IN_DOCUMENT"] = "Operation not supported while component is not in document";
                /**
                 * Error when an invalid component state is encountered.
                 */
                Error["STATE_INVALID"] = "Invalid component state";
            })(Error = Component.Error || (Component.Error = {}));
            ;
            /**
             * Common component states.  Components may have distinct appearance depending
             * on what state(s) apply to them.  Not all components are expected to support
             * all states.
             * @const
             * @enum {number}
             */
            var State;
            (function (State) {
                /**
                 * Union of all supported component states.
                 */
                State[State["ALL"] = 255] = "ALL";
                /**
                 * Component is disabled.
                 * @see goog.ui.Component.EventType.DISABLE
                 * @see goog.ui.Component.EventType.ENABLE
                 */
                State[State["DISABLED"] = 1] = "DISABLED";
                /**
                 * Component is highlighted.
                 * @see goog.ui.Component.EventType.HIGHLIGHT
                 * @see goog.ui.Component.EventType.UNHIGHLIGHT
                 */
                State[State["HOVER"] = 2] = "HOVER";
                /**
                 * Component is active (or "pressed").
                 * @see goog.ui.Component.EventType.ACTIVATE
                 * @see goog.ui.Component.EventType.DEACTIVATE
                 */
                State[State["ACTIVE"] = 4] = "ACTIVE";
                /**
                 * Component is selected.
                 * @see goog.ui.Component.EventType.SELECT
                 * @see goog.ui.Component.EventType.UNSELECT
                 */
                State[State["SELECTED"] = 8] = "SELECTED";
                /**
                 * Component is checked.
                 * @see goog.ui.Component.EventType.CHECK
                 * @see goog.ui.Component.EventType.UNCHECK
                 */
                State[State["CHECKED"] = 16] = "CHECKED";
                /**
                 * Component has focus.
                 * @see goog.ui.Component.EventType.FOCUS
                 * @see goog.ui.Component.EventType.BLUR
                 */
                State[State["FOCUSED"] = 32] = "FOCUSED";
                /**
                 * Component is opened (expanded).  Applies to tree nodes, menu buttons,
                 * submenus, zippys (zippies?), etc.
                 * @see goog.ui.Component.EventType.OPEN
                 * @see goog.ui.Component.EventType.CLOSE
                 */
                State[State["OPENED"] = 64] = "OPENED";
            })(State = Component.State || (Component.State = {}));
            ;
            /**
             * The default right to left value.
             * @type {?boolean}
             * @private
             */
            Component.defaultRightToLeft_ = (goog.ui.Component.DEFAULT_BIDI_DIR == 1) ?
                false :
                (goog.ui.Component.DEFAULT_BIDI_DIR == -1) ? true : null;
        })(Component = ui.Component || (ui.Component = {}));
    })(ui = goog.ui || (goog.ui = {}));
})(goog || (goog = {}));
/**
 * @define {boolean} Whether to support calling decorate with an element that is
 *     not yet in the document. If true, we check if the element is in the
 *     document, and avoid calling enterDocument if it isn't. If false, we
 *     maintain legacy behavior (always call enterDocument from decorate).
 */
goog.define('goog.ui.Component.ALLOW_DETACHED_DECORATION', false);
// TODO(gboyer): See if we can remove this and just check goog.i18n.bidi.IS_RTL.
/**
 * @define {number} Defines the default BIDI directionality.
 *     0: Unknown.
 *     1: Left-to-right.
 *     -1: Right-to-left.
 */
goog.define('goog.ui.Component.DEFAULT_BIDI_DIR', 0);
